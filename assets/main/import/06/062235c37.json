[1,["d3lyzFJgBPO4PUGi8x1duf","20qxUvARBIorm9ZNYUe/kP@a804a","828oJ67QlCL6V20Dfc/4hp","311ZifWFhCu5BYNPzRqvwn@9bae2","12Y9dMgWdJKJGmTiZyQR9H@a804a","d3x4IMKphEKYvHuEU7yaxB","8a/B88GitEg5pDkG2YBC1u","62C2vzA2lFYIN/KiwAtzwm","3bX06MvR1FgYqWtbqxMLNZ","f0Y4mvzXJJF5AQ9rWC3lA8@ef5e1","d78ZiNgI9PA4UWAilAqMMY","54GXU0ZPBLAqNR4bz8vSbc@bbae8","a7YStUNeNCOKGpSntUY1g5","23zFVgkP9HM4zB1XUMvfCu@6c48a","95wyzed8BM0KKLuaYchJHC","a5qgPkWx1BFbEm8UjpY0Yb@0441e","6eWh3yj+dF3IO6N5AFBS94@6c48a","08y3eKlztJwrv+NXFQt+OM@d2426","fesaXwJphLArYCso+jrghx","d7zebLEhlL/L6QqkMDZpF5","22W/R/W3RLEa7765KFMzTh@c2546","36ldlWQoBCJ6M4EbVGZzOf@6c48a","5cbFeD4MNGX4mdPFLWE6ok@6c48a","6dqXl9XoJCqbjthCUEA4Px@6c48a","c89m0XNRpI2qEsAhLShXXE","5b7wA/QZRB8b0BG9bAr9Wn@6c48a","2asuscaFtPkJ5Fow1dnm8r@6c48a","e4XQnn6QpM4p3rwXfseteM@6c48a","65GMtAUhJIRZjwqTUWlceV@6c48a","41bn4kcmBNkYb+GVH3uGN2@6c48a","1brw/JvvpFnIvdrxpFCgMZ","50e5MXb35PGbJ6yeQ6D7HV@80ac1","45Gph9wi5G3bt6OYhKOFnV","9fbwYovnZJdr6mEBBklCYG@6c48a","2bB6GNsPhEoY3o+Z9DEB9F","f08WhK+hlKoYlg4psavaaX","a0/LrvtChNBrcT24SdxJWr","d0ysydqhdIKoKEp0jusBSS@73b7f","f3vj9VnCpKcrNqGKQmDSrk","e9nJc8z+FMiJhMPWQNLfsg","08y3eKlztJwrv+NXFQt+OM@d3321","08y3eKlztJwrv+NXFQt+OM@56fbb","08y3eKlztJwrv+NXFQt+OM@04497","2ewRRY+FVJeLFN8+1c9pf6","2cnIB0AkdGM6L7lyw89prU@23c7e","2cnIB0AkdGM6L7lyw89prU@0af0b","50e5MXb35PGbJ6yeQ6D7HV@434dd","50e5MXb35PGbJ6yeQ6D7HV@e04d0","dd7S80CBtIKYmDmAGMc7e4","15vL6XV5VPU6Lev5lDn4MH@87c98","22VACpY71GWbjvlp235Oar@6c48a","9bIKUUbMNJ3rIWtrhjBGJJ","4aFEZtRkNLN6U+bvVGw5Oc@6c48a","cbun4lq+tON75PnmiQenlI@6c48a","d1WjFzLvtHt4yC/RdGGVi5@6c48a","f1sBlnfBBAh7/gWpyu2bUr@2e66d","653WM+KUZM3KI5YHIt3a22","b3yP5Ra8dFDq3u7N1eHDiw@4dc6f","d8yXWzGyZGHKOltah41dBF","baYom81gtHlZHrw+KV5S33@63569","acYJTaSn9MvIzDOc/lWYpx","2cnIB0AkdGM6L7lyw89prU@2555d","9d3oW5cT9Mcqsoe8rxzNs4","81anyTRTBClIdJSstLdiyx","55Xtui8nhJDKEsQRwGD2T9","cfPykwNgRE+6Q2y0u01YX7","27aZqmZz5JH4PWuRYOcVwP","7428Hn/ThI+4Mew/eTO7NC","78V+ropPpBhY91lLCFlwoD","d0ysydqhdIKoKEp0jusBSS@dbf3b","d0ysydqhdIKoKEp0jusBSS@30732","d0ysydqhdIKoKEp0jusBSS@72fa9","d0ysydqhdIKoKEp0jusBSS@f1394","6ag+sTxlxP1KCC9GdQN9P1","54jEceuXNJf7OMTmSezjnI@37cce","2fQwnLIG5I37rN+zcC8MVQ","ef+NNilyRJu6SOASWfuuy9","b7Ha9ghXpB+JZAr/mb8srg","b0YGHwvhVDUK1y7OgDzBf4@6c48a","a3zQCfCrBCDZJ4uf2rk5u8"],["node","_mesh","root","asset","targetInfo","_parent","_effectAsset","mainTexture","shadeMap1","shadeMap2","data","value","_defaultClip","_skeleton","baseColorMap","normalMap","pbrMap","occlusionMap","_cameraComponent","cameraManager","propGroupNode","playerGroupNode","logicManager","scene","propLogic","playerLogic","camera","coinPrefab","hammerPrefab","pfCoinTips","virtualPlayerPrefab","virtualCoinPrefab","virtualHammerPrefab","specularMap"],[["cc.Node",["_name","_objFlags","_id","_layer","__editorExtras__","_active","_parent","_children","_components","_lpos","_euler","_lscale","_lrot","_prefab"],-3,1,2,9,5,5,5,5,4],["cc.MeshRenderer",["_shadowCastingMode","_name","_enabled","_shadowReceivingMode","node","_materials","bakeSettings","_mesh","__prefab"],-1,1,3,4,6,4],["cc.Node",["_name","_objFlags","_id","_layer","_parent","_components","_lpos","_children","_lrot","_euler"],-1,1,2,5,2,5,5],["cc.Widget",["_alignFlags","_originalWidth","_originalHeight","_left","_right","_top","_bottom","_name","_alignMode","node"],-6,1],["cc.Material",["_states","_defines","_name","_props"],0,12],["cc.Prefab",["_name"],2],["cc.Node",["_name","_objFlags","_id","_parent","_children","_components"],0,1,12,9],["cc.Node",["_name","_objFlags","_parent","_children","_lpos","_lscale","_lrot","_euler"],1,1,9,5,5,5,5],["cc.ModelBakeSettings",["_bakeable","_castShadow","_receiveShadow"],0],["cc.UITransform",["_name","node","_contentSize"],2,1,5],["cc.Animation",["playOnLoad","node","_clips","_defaultClip"],2,1,3,6],["cc.Camera",["_visibility","_name","_fov","_projection","_priority","_orthoHeight","_far","_clearFlags","node","_color"],-5,1,5],["cc.SkinnedMeshRenderer",["_shadowCastingMode","_shadowReceivingMode","node","_materials","bakeSettings","_skinningRoot","_mesh","_skeleton"],1,1,3,4,1,6,6],["cc.Mesh",["_native","_hash","_struct"],1,11],["cc.Node",["_name","_objFlags","_id","_parent","_children","_components","_lpos","_lrot","_euler"],0,1,2,12,5,5,5],["cc.PrefabInfo",["fileId","instance","targetOverrides","nestedPrefabInstanceRoots","root","asset"],-1,1,1],["cc.PrefabInfo",["fileId","instance","targetOverrides","root","asset","nestedPrefabInstanceRoots"],0,1,1,2],["cc.PrefabInfo",["fileId","targetOverrides","nestedPrefabInstanceRoots","root","instance","asset"],0,1,4,6],["cc.PrefabInfo",["root","asset","fileId","instance","targetOverrides","nestedPrefabInstanceRoots"],-2,2],["cc.CompPrefabInfo",["fileId"],2],["cc.EffectAsset",["_name","shaders","techniques"],0],["cc.TargetInfo",["localID"],2],["cc.PrefabInstance",["fileId","prefabRootNode","propertyOverrides"],2,1,9],["cc.PrefabInstance",["fileId","prefabRootNode","propertyOverrides"],1,9],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,1],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,8],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,6],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,4],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,8],["cc.Skeleton",["_name","_hash","_joints","_bindposes"],0,12],["cc.SceneAsset",["_name"],2],["0bf32ApFU5Mu6jx9+9tx9KG",["_showMesh","node"],2,1],["cc.Scene",["_name","_children","_prefab","_globals"],2,2,4,4],["cc.SceneGlobals",["ambient","shadows","_skybox","fog","octree","lightProbeInfo"],3,4,4,4,4,4,4],["cc.AmbientInfo",["_skyIllumHDR","_skyIllumLDR","_skyColorHDR","_groundAlbedoHDR","_skyColorLDR"],1,5,5,5],["cc.ShadowsInfo",["_enabled","_type","_size"],1,5],["cc.SkyboxInfo",[],3],["cc.FogInfo",["_fogColor"],3,5],["cc.OctreeInfo",[],3],["cc.LightProbeInfo",[],3],["cc.Canvas",["_name","node","_cameraComponent"],2,1,1],["cc.SkeletalAnimation",["playOnLoad","node","_clips","_defaultClip"],2,1,3,6],["e542d/3GJRLWYGHcJyxlKkU",["node","logicManager","playerGroupNode","propGroupNode","cameraManager","aiPosNode","coinPrefab","hammerPrefab"],3,1,1,1,1,1,1,6,6],["03627MpYD9GQ5cp4Rc77nQa",["_name","node","pfCoinTips"],2,1,6],["cc.DirectionalLight",["_colorTemperature","_illuminanceHDR","_illuminanceLDR","_shadowEnabled","_shadowPcf","_shadowBias","_shadowDistance","_shadowNear","_shadowFar","_shadowOrthoSize","node","_staticSettings"],-7,1,4],["cc.StaticLightSettings",[],3],["d5c7e+7srFCRZQfAJvjyREK",["_name","node","needBatches"],2,1,2],["549cbz5PQRIrrDQ5jFvESJj",["node"],3,1],["2176apmEQ1HSa37kyBFOpny",["node","obstacleGroupNode"],3,1,1],["1e563P/T2tP+Ivr4OJZMArO",["node"],3,1],["30104VtL2VPDKHTFanbljZB",["node"],3,1]],[[8,1],[0,0,1,6,7,3],[19,0,2],[0,0,1,6,8,12,10,3],[25,0,1,2,2],[1,0,4,8,5,6,7,2],[0,0,1,6,7,9,11,3],[24,0,1,2,3],[21,0,2],[0,0,1,6,7,9,12,11,10,3],[0,1,4,6,13,3],[17,0,1,2,3,4,5,4],[1,1,2,4,8,5,6,7,3],[23,0,1,2,3],[1,0,4,5,6,7,2],[0,0,1,5,6,8,9,4],[1,1,4,5,6,7,2],[0,0,1,6,8,9,12,11,10,3],[1,4,8,5,6,7,1],[0,0,1,6,8,10,3],[0,0,1,6,8,9,11,3],[28,0,1,2,2],[4,2,0,1,3,4],[15,0,1,2,3,4,5,5],[13,0,1,2,3],[0,0,1,6,8,11,10,3],[26,0,1,2,2],[0,0,7,13,2],[22,0,1,2,2],[5,0,2],[0,0,6,7,13,2],[0,0,1,7,3],[27,0,1,2,3],[0,0,1,6,3],[1,4,5,6,7,1],[8,0,1,2,4],[5,1],[0,0,1,7,8,3],[0,0,1,6,9,12,10,3],[9,1,2,1],[3,0,1,2,9,4],[0,0,6,8,13,11,10,2],[0,0,6,8,13,12,10,2],[0,0,6,8,13,10,2],[0,0,1,7,9,3],[0,0,1,2,7,4],[0,0,1,3,6,8,4],[0,0,1,6,8,3],[0,0,1,6,7,9,3],[2,0,1,4,5,3],[16,0,1,2,3,4,5,4],[20,0,1,2,4],[29,0,1,2,3,4],[9,0,1,2,2],[10,0,1,2,3,2],[4,0,1,3,3],[0,0,7,13,9,12,11,10,2],[0,0,7,13,9,2],[0,0,1,7,12,10,3],[0,0,1,3,2,6,7,8,9,5],[0,0,1,7,8,9,11,3],[0,0,1,3,6,7,8,4],[0,0,1,6,9,12,11,10,3],[0,0,1,3,6,8,9,4],[0,0,1,2,6,8,9,12,10,4],[0,0,1,6,7,11,3],[0,0,1,2,6,7,9,12,11,10,4],[0,0,1,6,8,9,12,10,3],[0,0,1,2,6,7,9,4],[0,0,1,6,8,9,10,3],[6,0,1,2,3,4,5,4],[6,0,1,3,4,3],[2,0,1,2,4,7,5,4],[2,0,1,4,5,6,8,9,3],[2,0,1,3,4,5,6,4],[14,0,1,2,3,4,5,6,7,8,4],[7,0,1,2,3,4,5,3],[7,0,1,2,3,4,6,7,3],[18,0,1,2,3,4,5,6],[1,0,3,4,5,6,7,3],[30,0,2],[31,0,1,2],[32,0,1,2,3,2],[33,0,1,2,3,4,5,1],[34,0,1,2,3,4,3],[35,0,1,2,3],[36,1],[37,0,1],[38,1],[39,1],[40,0,1,2,2],[3,0,3,4,5,6,9,6],[3,7,0,1,2,8,9,6],[41,0,1,2,3,2],[42,0,1,2,3,4,5,6,7,1],[10,1,2,3,1],[43,0,1,2,2],[44,0,1,2,3,4,5,6,7,8,9,10,11,11],[45,1],[46,0,1,2,2],[47,0,1],[48,0,1,1],[49,0,1],[50,0,1],[11,1,2,0,8,9,4],[11,3,4,5,6,7,0,8,9,7],[12,0,1,2,3,4,5,6,7,3],[12,2,3,4,5,6,7,1]],[[[[24,".bin",2674103165,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":16752,"length":1824,"count":912,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":16752,"count":349,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.4504486322402954,-0.03693576157093048,-0.1791437864303589],"maxPosition",8,[1,0.41814905405044556,0.04106947034597397,0.17778997123241425]]],-1],0,0,[],[],[]],[[[55,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"USE_ALBEDO_MAP":true},{},{}],[[[{"roughness":0.70710676908493,"metallic":0.400000005960464},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[7,6],[40,30]],[[[36],[27,"fishBone",[-2],[23,"dbOPg73aZd84HLIpJi6hXs",null,null,null,-1,0]],[30,"RootNode",1,[-3],[23,"c192yZb09fSoroyCdO9Z/2",null,null,null,1,0]],[41,"fishBone",2,[[18,-4,[2,"35RWGfmqZQcIYfCKtpCCRe"],[0],[0],1]],[23,"f4X4WSWoJSuKFuGMmLhDyC",null,null,null,1,0],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,0.00000250447806548767,0,0]]],0,[0,2,1,0,-1,2,0,-1,3,0,0,3,0,10,1,4],[0,0],[-1,1],[41,42]],[[[24,".bin",938765904,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":28896,"length":3888,"count":1944,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":28896,"count":602,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.13352638483047485,-0.001244611688889563,-0.11863791942596436],"maxPosition",8,[1,0.13352638483047485,0.14976735413074493,0.1701211929321289]]],-1],0,0,[],[],[]],[[[24,".bin",103760498,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":4224,"length":456,"count":228,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":4224,"count":88,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.5,-0.5,-3.814697180359872e-8],"maxPosition",8,[1,0.5,0.5,1.0153764486312866]]],-1],0,0,[],[],[]],[[[24,".bin",3200391346,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":19440,"length":804,"count":402,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":19440,"count":270,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-4.407285213470459,0.33485016226768494,-4.407382488250732],"maxPosition",8,[1,4.407285213470459,8.94036865234375,4.407187461853027]]],-1],0,0,[],[],[]],[[[22,"scene",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_OUTLINE_PASS":true,"USE_BASE_COLOR_MAP":true},{"USE_BASE_COLOR_MAP":true,"USE_1ST_SHADE_MAP":true,"USE_2ND_SHADE_MAP":true,"SHADE_MAP_1_AS_SHADE_MAP_2":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{},{}],[[[{"lineWidth":100,"depthBias":0.04},"baseColor",8,[4,4294967295],"baseColorMap",6,0],[{"baseStep":1,"baseFeather":1.5,"shadowCover":1},"mainColor",8,[4,4294769916],"shadeColor1",8,[4,4278190080],"shadeColor2",8,[4,4294967295],"specular",8,[4,0],"mainTexture",6,1,"shadeMap1",6,2,"shadeMap2",6,3],{},{}],11,11,0,0]]],0,0,[0,0,0,0,0],[14,7,8,9,6],[16,16,16,16,12]],[[[24,".bin",1316673301,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1344,"length":156,"count":78,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1344,"count":28,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-70.34906768798828,-40.28403091430664,0],"maxPosition",8,[1,69.95880126953125,45.804534912109375,0]]],-1],0,0,[],[],[]],[[[22,"ground",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"albedoScale":1,"metallic":0,"roughness":0,"emissiveScale":1,"alphaSource":1},"mainColor",8,[4,4290559164],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[6],[43]],[[[36],[27,"ground",[-2],[23,"0dbpdUWKdV57/5BohZgCIy",null,null,null,-1,0]],[42,"ground",1,[[18,-3,[2,"eepWTEwpRTvLhgYPeKaNWU"],[0],[0],1]],[23,"b4RNNQ3CtW5IuAonPy9jyt",null,null,null,1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]]],0,[0,2,1,0,-1,2,0,0,2,0,10,1,3],[0,0],[-1,1],[44,45]],[[[51,"util/dcc/imported-metallic-roughness",[{"hash":2664252233,"name":"util/dcc/imported-metallic-roughness|standard-vs|standard-fs","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScale","type":13,"count":1},{"name":"occlusion","type":13,"count":1},{"name":"roughness","type":13,"count":1},{"name":"metallic","type":13,"count":1},{"name":"normalStrength","type":13,"count":1},{"name":"alphaSource","type":13,"count":1},{"name":"albedoScale","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]},{"name":"baseWeightMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_WEIGHT_MAP"]},{"name":"metallicMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_METALLIC_MAP"]},{"name":"roughnessMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_ROUGHNESS_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_OCCLUSION_MAP"]},{"name":"transparencyMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_TRANSPARENCY_MAP"]},{"name":"transparencyColorMap","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["USE_TRANSPARENCYCOLOR_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":8,"defines":["USE_EMISSIVE_MAP"]},{"name":"emissiveScaleMap","type":28,"count":1,"stageFlags":16,"binding":9,"defines":["USE_EMISSIVESCALE_MAP"]},{"name":"alphaSourceMap","type":28,"count":1,"stageFlags":16,"binding":10,"defines":["USE_OPACITY_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":11,"defines":["USE_NORMAL_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_color","format":44,"location":6,"defines":["USE_VERTEX_COLOR"]},{"name":"a_texCoord1","format":21,"location":7,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":12,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBiasAndProbeId","format":44,"isInstanced":true,"location":13,"defines":["USE_INSTANCING"]},{"name":"a_sh_linear_const_r","format":44,"isInstanced":true,"location":14,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_g","format":44,"isInstanced":true,"location":15,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_b","format":44,"isInstanced":true,"location":16,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_vertexId","format":11,"location":17,"defines":["CC_USE_MORPH"]}],"fragColors":[{"name":"fragColorX","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"tags":[],"defines":[]},{"name":"fragColor0","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":1,"tags":["CC_PIPELINE_TYPE"],"defines":["CC_PIPELINE_TYPE"]},{"name":"fragColor1","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":2,"defines":["CC_PIPELINE_TYPE"]},{"name":"fragColor2","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":3,"defines":["CC_PIPELINE_TYPE"]}],"descriptors":[{"rate":0,"blocks":[{"name":"CCLocal","stageFlags":17,"tags":{"builtin":"local"},"members":[{"name":"cc_matWorld","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matWorldIT","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_lightingMapUVParam","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_localShadowBias","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData2","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["!USE_INSTANCING"]},{"name":"CCMorph","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_displacementWeights","typename":"vec4","type":16,"count":15,"isArray":true},{"name":"cc_displacementTextureInfo","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointTextureInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointAnimInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_joints","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true}],"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCForwardLight","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_lightPos","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true},{"name":"cc_lightColor","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightSizeRangeAngle","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightDir","typename":"vec4","type":16,"count":0,"isArray":true}],"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CCSH","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_sh_linear_const_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_a","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeDataMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":1,"blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScale","type":13,"count":1},{"name":"occlusion","type":13,"count":1},{"name":"roughness","type":13,"count":1},{"name":"metallic","type":13,"count":1},{"name":"normalStrength","type":13,"count":1},{"name":"alphaSource","type":13,"count":1},{"name":"albedoScale","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]},{"name":"baseWeightMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_WEIGHT_MAP"]},{"name":"metallicMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_METALLIC_MAP"]},{"name":"roughnessMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_ROUGHNESS_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_OCCLUSION_MAP"]},{"name":"transparencyMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_TRANSPARENCY_MAP"]},{"name":"transparencyColorMap","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["USE_TRANSPARENCYCOLOR_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":8,"defines":["USE_EMISSIVE_MAP"]},{"name":"emissiveScaleMap","type":28,"count":1,"stageFlags":16,"binding":9,"defines":["USE_EMISSIVESCALE_MAP"]},{"name":"alphaSourceMap","type":28,"count":1,"stageFlags":16,"binding":10,"defines":["USE_OPACITY_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":11,"defines":["USE_NORMAL_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":2,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":3,"blocks":[{"name":"CCGlobal","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_time","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_screenSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nativeSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_probeInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_mode","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCamera","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_cameraPos","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_surfaceTransform","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_screenScale","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_exposure","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitDir","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientSky","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientGround","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogBase","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogAdd","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nearFar","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_viewPort","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCShadow","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matLightView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matLightViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_shadowInvProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowNFLSInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowWHPBInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowLPNNInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowColor","typename":"vec4","type":16,"count":1,"precision":"lowp "},{"name":"cc_planarNDInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCSM","stageFlags":16,"tags":{"builtin":"global"},"members":[{"name":"cc_csmViewDir0","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir1","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir2","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmAtlas","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_matCSMViewProj","typename":"mat4","type":25,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjDepthInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmSplitsInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_environment","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"global"},"defines":[]},{"name":"cc_diffuseMap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]},{"name":"cc_shadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]}],"glsl1":{"vert":"\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE USE_REFLECTION_DENOISE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING USE_COMPATIBLE_LIGHTING\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#ifndef CC_SURFACES_LIGHTING_CALCULATE_DIFFUSE\n  #define CC_SURFACES_LIGHTING_CALCULATE_DIFFUSE 1\n#endif\n#ifndef CC_SURFACES_LIGHTING_CALCULATE_SPECULAR\n  #define CC_SURFACES_LIGHTING_CALCULATE_SPECULAR 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  attribute vec4 a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  attribute vec4 a_color;\n#endif\n#if CC_SURFACES_USE_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    attribute vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    attribute vec4 a_sh_linear_const_r;\n    attribute vec4 a_sh_linear_const_g;\n    attribute vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n#endif\nvarying highp vec3 v_worldPos;\nvarying mediump vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  varying mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  varying highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define VSOutput_worldPos v_worldPos\n#define VSOutput_worldNormal v_normal.xyz\n#define VSOutput_faceSideSign v_normal.w\n#define VSOutput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define VSOutput_vertexColor v_color\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define VSOutput_worldTangent v_tangent.xyz\n  #define VSOutput_mirrorNormal v_tangent.w\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define VSOutput_texcoord1 v_uv1\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define VSOutput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define VSOutput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define VSOutput_reflectionProbeId v_shadowBiasAndProbeId.z\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define VSOutput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define VSOutput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define VSOutput_clipPos v_clipPos\n#endif\nstruct SurfacesStandardVertexIntermediate\n{\n  highp vec4 position;\n  vec3 normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  vec4 color;\n#endif\n  vec2 texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  vec2 texCoord1;\n#endif\n  highp vec4 clipPos;\n  highp vec3 worldPos;\n  vec4 worldNormal;\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 worldTangent, worldBinormal;\n  #endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  vec4 shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  float fogFactor;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  vec3 lightmapUV;\n#endif\n};\n#if CC_USE_MORPH\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\nuniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_POINT 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_SPHERE 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if !USE_INSTANCING\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  uniform highp vec4 cc_lightingMapUVParam;\n  uniform highp vec4 cc_localShadowBias;\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #if CC_USE_FOG != 4\n    float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n        vec4 wPos = pos;\n        float cam_dis = distance(cameraPos, wPos.xyz);\n        return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n    }\n    float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n        vec4 wPos = pos;\n        float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n        float f = exp(-cam_dis * fogDensity);\n        return f;\n    }\n    float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n        vec4 wPos = pos;\n        float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n        float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n        return f;\n    }\n    float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n        vec4 wPos = pos;\n        vec3 camWorldProj = cameraPos.xyz;\n        camWorldProj.y = 0.;\n        vec3 worldPosProj = wPos.xyz;\n        worldPosProj.y = 0.;\n        float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n        float fDeltaY, fDensityIntegral;\n        if (cameraPos.y > fogTop) {\n            if (wPos.y < fogTop) {\n                fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n                fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n            }\n            else {\n                fDeltaY = 0.;\n                fDensityIntegral = 0.;\n            }\n        }\n        else {\n            if (wPos.y < fogTop) {\n                float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n                float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n                fDeltaY = abs(fDeltaA - fDeltaB);\n                fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n            }\n            else {\n                fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n                fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n            }\n        }\n        float fDensity;\n        if (fDeltaY != 0.) {\n            fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n        }\n        else {\n            fDensity = 0.;\n        }\n        float f = exp(-fDensity);\n        return f;\n    }\n  #endif\n  void CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n  {\n  #if CC_USE_FOG == 0\n  \tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n  #elif CC_USE_FOG == 1\n  \tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n  #elif CC_USE_FOG == 2\n  \tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n  #elif CC_USE_FOG == 3\n  \tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n  #else\n  \tfactor = 1.0;\n  #endif\n  }\n#endif\n    uniform vec4 tilingOffset;\n#define CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord * tilingOffset.xy + tilingOffset.zw;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = In.texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\n}\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_POS\nvec3 SurfacesVertexModifyLocalPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.position.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_NORMAL\nvec3 SurfacesVertexModifyLocalNormal(in SurfacesStandardVertexIntermediate In)\n{\n  return In.normal.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_TANGENT\n  #if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 SurfacesVertexModifyLocalTangent(in SurfacesStandardVertexIntermediate In)\n    {\n      return In.tangent;\n    }\n  #endif\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_SHARED_DATA\nvoid SurfacesVertexModifyLocalSharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_POS\nvec3 SurfacesVertexModifyWorldPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.worldPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_CLIP_POS\nvec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.clipPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_NORMAL\nvec3 SurfacesVertexModifyWorldNormal(in SurfacesStandardVertexIntermediate In)\n{\n    vec3 worldNormal = In.worldNormal.xyz;\n  #if CC_SURFACES_USE_TWO_SIDED\n      worldNormal.xyz *= In.worldNormal.w;\n  #endif\n  return worldNormal;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHARED_DATA\nvoid SurfacesVertexModifySharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\nvoid CCSurfacesVertexInput(out SurfacesStandardVertexIntermediate In)\n{\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  In.tangent = a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  In.color = a_color;\n#endif\n  In.texCoord = a_texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = a_texCoord1;\n#endif\n}\nvoid CCSurfacesVertexOutput(in SurfacesStandardVertexIntermediate In)\n{\n  gl_Position = In.clipPos;\n  VSOutput_worldNormal = In.worldNormal.xyz;\n  VSOutput_faceSideSign = In.worldNormal.w;\n  VSOutput_worldPos = In.worldPos;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  VSOutput_worldTangent = In.worldTangent.xyz;\n  VSOutput_mirrorNormal = In.tangent.w > 0.0 ? 1.0 : -1.0;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  VSOutput_vertexColor = In.color;\n#endif\n  VSOutput_texcoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  VSOutput_texcoord1 = In.texCoord1;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  VSOutput_fogFactor = In.fogFactor;\n#endif\n#if CC_RECEIVE_SHADOW\n  VSOutput_shadowBias = In.shadowBiasAndProbeId.xy;\n#endif\n#if CC_USE_REFLECTION_PROBE\n  VSOutput_reflectionProbeId = In.shadowBiasAndProbeId.z;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  VSOutput_lightMapUV = In.lightmapUV;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  VSOutput_localPos = In.position;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  VSOutput_clipPos = In.clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    v_sh_linear_const_r = a_sh_linear_const_r;\n    v_sh_linear_const_g = a_sh_linear_const_g;\n    v_sh_linear_const_b = a_sh_linear_const_b;\n  #endif\n#endif\n}\nvoid CCSurfacesVertexAnimation(inout SurfacesStandardVertexIntermediate In)\n{\nvec4 temp = vec4(0.0);\n#if CC_USE_MORPH\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    applyMorph(In.position, In.normal, In.tangent);\n  #else\n    applyMorph(In.position, In.normal, temp);\n  #endif\n#endif\n#if CC_USE_SKINNING\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    CCSkin(In.position, In.normal, In.tangent);\n  #else\n    CCSkin(In.position, In.normal, temp);\n  #endif\n#endif\n}\nvoid CCSurfacesVertexWorldTransform(inout SurfacesStandardVertexIntermediate In)\n{\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    In.worldPos = (matWorld * In.position).xyz;\n    In.worldNormal.xyz = normalize((matWorldIT * vec4(In.normal.xyz, 0.0)).xyz);\n    #if CC_SURFACES_USE_TANGENT_SPACE\n      In.worldTangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      In.worldBinormal = cross(In.worldNormal.xyz, In.worldTangent) * In.tangent.w;\n    #endif\n}\nvoid CCSurfacesVertexTransformUV(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_SURFACES_FLIP_UV\n    In.texCoord = cc_cameraPos.w > 1.0 ? vec2(In.texCoord.x, 1.0 - In.texCoord.y) : In.texCoord;\n    #if CC_SURFACES_USE_SECOND_UV\n      In.texCoord1 = cc_cameraPos.w > 1.0 ? vec2(In.texCoord1.x, 1.0 - In.texCoord1.y) : In.texCoord1;\n    #endif\n  #endif\n}\nvoid CCSurfacesVertexTransferFog(inout SurfacesStandardVertexIntermediate In)\n{\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(vec4(In.worldPos, 1.0), In.fogFactor);\n#endif\n}\nvoid CCSurfacesVertexTransferShadow(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    In.shadowBiasAndProbeId = vec4(0.0);\n  #endif\n  #if CC_RECEIVE_SHADOW\n    In.shadowBiasAndProbeId.xy = vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n    #if USE_INSTANCING\n      In.shadowBiasAndProbeId.xy += a_localShadowBiasAndProbeId.xy;\n    #else\n      In.shadowBiasAndProbeId.xy += cc_localShadowBias.xy;\n    #endif\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    #if USE_INSTANCING\n      In.shadowBiasAndProbeId.zw = a_localShadowBiasAndProbeId.zw;\n    #else\n      In.shadowBiasAndProbeId.zw = cc_localShadowBias.zw;\n    #endif\n  #endif\n}\nvoid CCSurfacesVertexTransferLightMapUV(inout SurfacesStandardVertexIntermediate In)\n{\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #if USE_INSTANCING\n    In.lightmapUV.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    In.lightmapUV.z = a_lightingMapUVParam.w;\n  #else\n    In.lightmapUV.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    In.lightmapUV.z = cc_lightingMapUVParam.w;\n  #endif\n#endif\n}\nvoid main()\n{\n  SurfacesStandardVertexIntermediate In;\n  CCSurfacesVertexInput(In);\n  CCSurfacesVertexAnimation(In);\n  In.position.xyz = SurfacesVertexModifyLocalPos(In);\n  In.normal.xyz = SurfacesVertexModifyLocalNormal(In);\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    In.tangent = SurfacesVertexModifyLocalTangent(In);\n  #endif\n  SurfacesVertexModifyLocalSharedData(In);\n  CCSurfacesVertexWorldTransform(In);\n  In.worldPos = SurfacesVertexModifyWorldPos(In);\n  In.clipPos = cc_matProj * cc_matView * vec4(In.worldPos, 1.0);\n  In.clipPos = SurfacesVertexModifyClipPos(In);\n  vec3 viewDirect = normalize(cc_cameraPos.xyz - In.worldPos);\n  In.worldNormal.w = dot(In.worldNormal.xyz, viewDirect) < 0.0 ? -1.0 : 1.0;\n  In.worldNormal.xyz = SurfacesVertexModifyWorldNormal(In);\n  SurfacesVertexModifyUV(In);\n  SurfacesVertexModifySharedData(In);\n  CCSurfacesVertexTransformUV(In);\n  CCSurfacesVertexTransferFog(In);\n  CCSurfacesVertexTransferShadow(In);\n  CCSurfacesVertexTransferLightMapUV(In);\n  CCSurfacesVertexOutput(In);\n}","frag":"\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE USE_REFLECTION_DENOISE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING USE_COMPATIBLE_LIGHTING\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#ifndef CC_SURFACES_LIGHTING_CALCULATE_DIFFUSE\n  #define CC_SURFACES_LIGHTING_CALCULATE_DIFFUSE 1\n#endif\n#ifndef CC_SURFACES_LIGHTING_CALCULATE_SPECULAR\n  #define CC_SURFACES_LIGHTING_CALCULATE_SPECULAR 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nvarying highp vec3 v_worldPos;\nvarying mediump vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  varying mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  varying highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define FSInput_worldPos v_worldPos\n#define FSInput_worldNormal v_normal.xyz\n#define FSInput_faceSideSign v_normal.w\n#define FSInput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define FSInput_vertexColor v_color\n#else\n  #define FSInput_vertexColor vec4(1.0)\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define FSInput_worldTangent v_tangent.xyz\n  #define FSInput_mirrorNormal v_tangent.w\n#else\n  #define FSInput_worldTangent vec3(0.0, 0.0, 0.0)\n  #define FSInput_mirrorNormal 1.0\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define FSInput_texcoord1 v_uv1\n#else\n  #define FSInput_texcoord1 vec2(0.0, 0.0)\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define FSInput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define FSInput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define FSInput_reflectionProbeId v_shadowBiasAndProbeId.z\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define FSInput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define FSInput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define FSInput_clipPos v_clipPos\n#endif\nuniform highp vec4 cc_time;\n  uniform mediump vec4 cc_probeInfo;\n  uniform mediump vec4 cc_debug_view_mode;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_surfaceTransform;\n  uniform mediump vec4 cc_exposure;\n  uniform mediump vec4 cc_mainLitDir;\n  uniform mediump vec4 cc_mainLitColor;\n  uniform mediump vec4 cc_ambientSky;\n  uniform mediump vec4 cc_ambientGround;\n  uniform mediump vec4 cc_fogColor;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n  uniform mediump vec4 cc_nearFar;\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_IOR CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_IOR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FRESNEL CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_FRESNEL + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRT_DIRECT CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_TRT_ENVIRONMENT CC_SURFACES_DEBUG_VIEW_TRT_DIRECT + 1\n#define CC_SURFACES_DEBUG_VIEW_TRT_ALL CC_SURFACES_DEBUG_VIEW_TRT_ENVIRONMENT + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_TRT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#define IS_DEBUG_VIEW_ENABLE_WITH_CAMERA (cc_surfaceTransform.y != 3.0)\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (UnpackBitFromFloat(cc_debug_view_mode.w, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (UnpackBitFromFloat(cc_debug_view_mode.w, 7) && IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (UnpackBitFromFloat(cc_debug_view_mode.y, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (UnpackBitFromFloat(cc_debug_view_mode.y, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (UnpackBitFromFloat(cc_debug_view_mode.y, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (UnpackBitFromFloat(cc_debug_view_mode.y, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (UnpackBitFromFloat(cc_debug_view_mode.z, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (UnpackBitFromFloat(cc_debug_view_mode.z, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (UnpackBitFromFloat(cc_debug_view_mode.z, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (UnpackBitFromFloat(cc_debug_view_mode.z, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL (UnpackBitFromFloat(cc_debug_view_mode.z, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.z, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRT (UnpackBitFromFloat(cc_debug_view_mode.z, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT (UnpackBitFromFloat(cc_debug_view_mode.w, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    #if CC_PIPELINE_TYPE == 0\n      #define LIGHTS_PER_PASS 1\n    #else\n      #define LIGHTS_PER_PASS 10\n    #endif\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n    uniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightColor[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n    #endif\n  #endif\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if !USE_INSTANCING\n    uniform vec4 cc_sh_linear_const_r;\n  uniform vec4 cc_sh_linear_const_g;\n  uniform vec4 cc_sh_linear_const_b;\n  uniform vec4 cc_sh_quadratic_r;\n  uniform vec4 cc_sh_quadratic_g;\n  uniform vec4 cc_sh_quadratic_b;\n  uniform vec4 cc_sh_quadratic_a;\n  #endif\n#endif\nuniform highp mat4 cc_matLightView;\n  uniform highp mat4 cc_matLightViewProj;\n  uniform highp vec4 cc_shadowInvProjDepthInfo;\n  uniform highp vec4 cc_shadowProjDepthInfo;\n  uniform highp vec4 cc_shadowProjInfo;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  uniform highp vec4 cc_csmViewDir0[4];\n  uniform highp vec4 cc_csmViewDir1[4];\n  uniform highp vec4 cc_csmViewDir2[4];\n  uniform highp vec4 cc_csmAtlas[4];\n  uniform highp mat4 cc_matCSMViewProj[4];\n  uniform highp vec4 cc_csmProjDepthInfo[4];\n  uniform highp vec4 cc_csmProjInfo[4];\n  uniform highp vec4 cc_csmSplitsInfo;\n#endif\nuniform samplerCube cc_environment;\n#if CC_USE_IBL\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform samplerCube cc_reflectionProbeCubemap;\n  uniform sampler2D cc_reflectionProbePlanarMap;\n  uniform sampler2D cc_reflectionProbeDataMap;\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_POINT 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_SPHERE 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    #ifdef GL_EXT_shader_texture_lod\n      return texture2DLodEXT(tex, coord, lod);\n    #else\n      return texture2D(tex, coord, lod);\n    #endif\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    #ifdef GL_EXT_shader_texture_lod\n      return textureCubeLodEXT(tex, coord, lod);\n    #else\n      return textureCube(tex, coord, lod);\n    #endif\n}\n#define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nvec4 packRGBE (vec3 rgb) {\n  highp float maxComp = max(max(rgb.r, rgb.g), rgb.b);\n  highp float e = 128.0;\n  if (maxComp > 0.0001) {\n    e = log(maxComp) / log(1.1);\n    e = ceil(e);\n    e = clamp(e + 128.0, 0.0, 255.0);\n  }\n  highp float sc = 1.0 / pow(1.1, e - 128.0);\n  vec3 encode = clamp(rgb * sc, vec3(0.0), vec3(1.0)) * 255.0;\n  vec3 encode_rounded = floor(encode) + step(encode - floor(encode), vec3(0.5));\n  return vec4(encode_rounded, e) / 255.0;\n}\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return gamma;\n    }\n  #endif\n#endif\n  return gamma * gamma;\n}\nvec3 LinearToSRGB(vec3 linear) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return linear;\n    }\n  #endif\n#endif\n  return sqrt(linear);\n}\nbool isnan(float val) {\n  return (val < 0.0 || 0.0 < val || val == 0.0) ? false : true;\n}\nbool isinf(float x) {\n  return x == x * 2.0 && x != 0.0;\n}\nbool isnans(vec2 val) {\n    return isnan(val.x) || isnan(val.y);\n}\nbool isnans(vec3 val) {\n    return isnan(val.x) || isnan(val.y) || isnan(val.z);\n}\nbool isnans(vec4 val) {\n    return isnan(val.x) || isnan(val.y) || isnan(val.z) || isnan(val.w);\n}\nbool isinfs(vec2 val) {\n    return isinf(val.x) || isinf(val.y);\n}\nbool isinfs(vec3 val) {\n    return isinf(val.x) || isinf(val.y) || isinf(val.z);\n}\nbool isinfs(vec4 val) {\n    return isinf(val.x) || isinf(val.y) || isinf(val.z) || isinf(val.w);\n}\nfloat saturate(float value) {\n    return min(max(value, 0.0), 1.0);\n}\nvec2 saturate(vec2 value) { return vec2(saturate(value.x), saturate(value.y)); }\nvec3 saturate(vec3 value) { return vec3(saturate(value.x), saturate(value.y), saturate(value.z)); }\nvec4 saturate(vec4 value) { return vec4(saturate(value.x), saturate(value.y), saturate(value.z), saturate(value.w)); }\nvec2 GetPlanarReflectScreenUV(vec3 worldPos, mat4 matVirtualCameraViewProj, float flipNDCSign, vec3 viewDir, vec3 reflectDir)\n{\n  vec4 clipPos = matVirtualCameraViewProj * vec4(worldPos, 1.0);\n  vec2 screenUV = clipPos.xy / clipPos.w * 0.5 + 0.5;\n  screenUV = vec2(1.0 - screenUV.x, screenUV.y);\n  screenUV = flipNDCSign == 1.0 ? vec2(screenUV.x, 1.0 - screenUV.y) : screenUV;\n  return screenUV;\n}\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\nvec3 CalculateBinormal(vec3 normal, vec3 tangent, float mirrorNormal)\n{\n    return cross(normal.xyz, tangent) * mirrorNormal;\n}\nvec3 CalculateNormalFromTangentSpace(vec3 normalFromTangentSpace, float normalStrength, vec3 normal, vec3 tangent, float mirrorNormal)\n{\n    vec3 binormal = CalculateBinormal(normal, tangent, mirrorNormal);\n    return (normalFromTangentSpace.x * normalStrength) * normalize(tangent) +\n           (normalFromTangentSpace.y * normalStrength) * normalize(binormal) +\n            normalFromTangentSpace.z * normalize(normal);\n}\nvec3 RotationVecFromAxisY(vec3 v, float cosTheta, float sinTheta)\n{\n    vec3 result;\n    result.x = dot(v, vec3(cosTheta, 0.0, -sinTheta));\n    result.y = v.y;\n    result.z = dot(v, vec3(sinTheta, 0.0,  cosTheta));\n    return result;\n}\nvoid RotateTangentAndBinormal(inout vec3 tangent, inout vec3 binormal, vec3 normal, float rotationAngle)\n{\n    float cosTheta = cos(rotationAngle), sinTheta = sin(rotationAngle);\n    vec3 B = RotationVecFromAxisY(vec3(1.0, 0.0, 0.0), cosTheta, sinTheta);\n    vec3 T = RotationVecFromAxisY(vec3(0.0, 0.0, 1.0), cosTheta, sinTheta);\n    vec3 tangentNew, binormalNew;\n    binormalNew = B.x * binormal + B.y * normal + B.z * tangent;\n    binormal = normalize(binormalNew);\n    tangentNew = T.x * binormal + T.y * normal + T.z * tangent;\n    tangent = normalize(tangentNew);\n}\nvec2 signNotZero(vec2 v) {\n  return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n}\nvec2 float32x3_to_oct(in vec3 v) {\n  vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n  return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n}\n  vec3 EnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n      #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n        roughness = pow(roughness, 0.5);\n      #endif\n    \tfloat mip = roughness * (mipCount - 1.0);\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n      vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    \tvec4 biased = fragTextureLod(cc_environment, rotationDir, mip + mipBias);\n     \tvec4 filtered = textureCube(cc_environment, rotationDir);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n  vec3 EnvReflection(samplerCube tex, vec3 R, float roughness, float mipCount) {\n    #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n      roughness = pow(roughness, 0.5);\n    #endif\n    vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    vec4 envmap = fragTextureLod(tex, rotationDir, roughness * (mipCount - 1.0));\n    #if CC_USE_IBL == 2 || CC_USE_REFLECTION_PROBE != REFLECTION_PROBE_TYPE_NONE\n      return unpackRGBE(envmap);\n    #else\n      return SRGBToLinear(envmap.rgb);\n    #endif\n  }\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n#endif\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  float SampleShadowMap (vec3 shadowNDCPos, highp sampler2D shadowMap)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return dot(texture2D(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    #else\n      return texture2D(shadowMap, shadowNDCPos.xy).x;\n    #endif\n  }\n  float NativePCFShadowFactorHard (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return step(shadowNDCPos.z, dot(texture2D(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      return step(shadowNDCPos.z, texture2D(shadowMap, shadowNDCPos.xy).x);\n    #endif\n  }\n  float NativePCFShadowFactorSoft (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block1 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)).x);\n      block2 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)).x);\n      block3 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)).x);\n    #endif\n    float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float NativePCFShadowFactorSoft3X (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    float shadowNDCPos_offset_L = shadowNDCPos.x - oneTap.x;\n    float shadowNDCPos_offset_R = shadowNDCPos.x + oneTap.x;\n    float shadowNDCPos_offset_U = shadowNDCPos.y - oneTap.y;\n    float shadowNDCPos_offset_D = shadowNDCPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)).x);\n      block1 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)).x);\n      block2 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)).x);\n      block3 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)).x);\n      block4 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block5 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)).x);\n      block6 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)).x);\n      block7 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)).x);\n      block8 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)).x);\n    #endif\n    float coefX = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float coefY = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float NativePCFShadowFactorSoft5X (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 twoTap = oneTap * 2.0;\n    vec2 offset1 = shadowNDCPos.xy + vec2(-twoTap.x, -twoTap.y);\n    vec2 offset2 = shadowNDCPos.xy + vec2(-oneTap.x, -twoTap.y);\n    vec2 offset3 = shadowNDCPos.xy + vec2(0.0, -twoTap.y);\n    vec2 offset4 = shadowNDCPos.xy + vec2(oneTap.x, -twoTap.y);\n    vec2 offset5 = shadowNDCPos.xy + vec2(twoTap.x, -twoTap.y);\n    vec2 offset6 = shadowNDCPos.xy + vec2(-twoTap.x, -oneTap.y);\n    vec2 offset7 = shadowNDCPos.xy + vec2(-oneTap.x, -oneTap.y);\n    vec2 offset8 = shadowNDCPos.xy + vec2(0.0, -oneTap.y);\n    vec2 offset9 = shadowNDCPos.xy + vec2(oneTap.x, -oneTap.y);\n    vec2 offset10 = shadowNDCPos.xy + vec2(twoTap.x, -oneTap.y);\n    vec2 offset11 = shadowNDCPos.xy + vec2(-twoTap.x, 0.0);\n    vec2 offset12 = shadowNDCPos.xy + vec2(-oneTap.x, 0.0);\n    vec2 offset13 = shadowNDCPos.xy + vec2(0.0, 0.0);\n    vec2 offset14 = shadowNDCPos.xy + vec2(oneTap.x, 0.0);\n    vec2 offset15 = shadowNDCPos.xy + vec2(twoTap.x, 0.0);\n    vec2 offset16 = shadowNDCPos.xy + vec2(-twoTap.x, oneTap.y);\n    vec2 offset17 = shadowNDCPos.xy + vec2(-oneTap.x, oneTap.y);\n    vec2 offset18 = shadowNDCPos.xy + vec2(0.0, oneTap.y);\n    vec2 offset19 = shadowNDCPos.xy + vec2(oneTap.x, oneTap.y);\n    vec2 offset20 = shadowNDCPos.xy + vec2(twoTap.x, oneTap.y);\n    vec2 offset21 = shadowNDCPos.xy + vec2(-twoTap.x, twoTap.y);\n    vec2 offset22 = shadowNDCPos.xy + vec2(-oneTap.x, twoTap.y);\n    vec2 offset23 = shadowNDCPos.xy + vec2(0.0, twoTap.y);\n    vec2 offset24 = shadowNDCPos.xy + vec2(oneTap.x, twoTap.y);\n    vec2 offset25 = shadowNDCPos.xy + vec2(twoTap.x, twoTap.y);\n    float block1, block2, block3, block4, block5, block6, block7, block8, block9, block10, block11, block12, block13, block14, block15, block16, block17, block18, block19, block20, block21, block22, block23, block24, block25;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block1 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset1), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset2), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset3), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset4), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset5), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset6), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset7), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset8), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block9 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset9), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block10 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset10), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block11 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset11), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block12 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset12), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block13 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset13), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block14 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset14), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block15 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset15), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block16 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset16), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block17 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset17), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block18 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset18), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block19 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset19), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block20 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset20), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block21 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset21), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block22 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset22), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block23 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset23), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block24 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset24), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block25 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset25), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block1 = step(shadowNDCPos.z, texture2D(shadowMap, offset1).x);\n      block2 = step(shadowNDCPos.z, texture2D(shadowMap, offset2).x);\n      block3 = step(shadowNDCPos.z, texture2D(shadowMap, offset3).x);\n      block4 = step(shadowNDCPos.z, texture2D(shadowMap, offset4).x);\n      block5 = step(shadowNDCPos.z, texture2D(shadowMap, offset5).x);\n      block6 = step(shadowNDCPos.z, texture2D(shadowMap, offset6).x);\n      block7 = step(shadowNDCPos.z, texture2D(shadowMap, offset7).x);\n      block8 = step(shadowNDCPos.z, texture2D(shadowMap, offset8).x);\n      block9 = step(shadowNDCPos.z, texture2D(shadowMap, offset9).x);\n      block10 = step(shadowNDCPos.z, texture2D(shadowMap, offset10).x);\n      block11 = step(shadowNDCPos.z, texture2D(shadowMap, offset11).x);\n      block12 = step(shadowNDCPos.z, texture2D(shadowMap, offset12).x);\n      block13 = step(shadowNDCPos.z, texture2D(shadowMap, offset13).x);\n      block14 = step(shadowNDCPos.z, texture2D(shadowMap, offset14).x);\n      block15 = step(shadowNDCPos.z, texture2D(shadowMap, offset15).x);\n      block16 = step(shadowNDCPos.z, texture2D(shadowMap, offset16).x);\n      block17 = step(shadowNDCPos.z, texture2D(shadowMap, offset17).x);\n      block18 = step(shadowNDCPos.z, texture2D(shadowMap, offset18).x);\n      block19 = step(shadowNDCPos.z, texture2D(shadowMap, offset19).x);\n      block20 = step(shadowNDCPos.z, texture2D(shadowMap, offset20).x);\n      block21 = step(shadowNDCPos.z, texture2D(shadowMap, offset21).x);\n      block22 = step(shadowNDCPos.z, texture2D(shadowMap, offset22).x);\n      block23 = step(shadowNDCPos.z, texture2D(shadowMap, offset23).x);\n      block24 = step(shadowNDCPos.z, texture2D(shadowMap, offset24).x);\n      block25 = step(shadowNDCPos.z, texture2D(shadowMap, offset25).x);\n    #endif\n    vec2 coef = fract(shadowNDCPos.xy * shadowMapResolution);\n    vec2 v1X1 = mix(vec2(block1, block6), vec2(block2, block7), coef.xx);\n    vec2 v1X2 = mix(vec2(block2, block7), vec2(block3, block8), coef.xx);\n    vec2 v1X3 = mix(vec2(block3, block8), vec2(block4, block9), coef.xx);\n    vec2 v1X4 = mix(vec2(block4, block9), vec2(block5, block10), coef.xx);\n    float v1 = mix(v1X1.x, v1X1.y, coef.y) + mix(v1X2.x, v1X2.y, coef.y) + mix(v1X3.x, v1X3.y, coef.y) + mix(v1X4.x, v1X4.y, coef.y);\n    vec2 v2X1 = mix(vec2(block6, block11), vec2(block7, block12), coef.xx);\n    vec2 v2X2 = mix(vec2(block7, block12), vec2(block8, block13), coef.xx);\n    vec2 v2X3 = mix(vec2(block8, block13), vec2(block9, block14), coef.xx);\n    vec2 v2X4 = mix(vec2(block9, block14), vec2(block10, block15), coef.xx);\n    float v2 = mix(v2X1.x, v2X1.y, coef.y) + mix(v2X2.x, v2X2.y, coef.y) + mix(v2X3.x, v2X3.y, coef.y) + mix(v2X4.x, v2X4.y, coef.y);\n    vec2 v3X1 = mix(vec2(block11, block16), vec2(block12, block17), coef.xx);\n    vec2 v3X2 = mix(vec2(block12, block17), vec2(block13, block18), coef.xx);\n    vec2 v3X3 = mix(vec2(block13, block18), vec2(block14, block19), coef.xx);\n    vec2 v3X4 = mix(vec2(block14, block19), vec2(block15, block20), coef.xx);\n    float v3 = mix(v3X1.x, v3X1.y, coef.y) + mix(v3X2.x, v3X2.y, coef.y) + mix(v3X3.x, v3X3.y, coef.y) + mix(v3X4.x, v3X4.y, coef.y);\n    vec2 v4X1 = mix(vec2(block16, block21), vec2(block17, block22), coef.xx);\n    vec2 v4X2 = mix(vec2(block17, block22), vec2(block18, block23), coef.xx);\n    vec2 v4X3 = mix(vec2(block18, block23), vec2(block19, block24), coef.xx);\n    vec2 v4X4 = mix(vec2(block19, block24), vec2(block20, block25), coef.xx);\n    float v4 = mix(v4X1.x, v4X1.y, coef.y) + mix(v4X2.x, v4X2.y, coef.y) + mix(v4X3.x, v4X3.y, coef.y) + mix(v4X4.x, v4X4.y, coef.y);\n    float fAvg = (v1 + v2 + v3 + v4) * 0.0625;\n    return fAvg;\n  }\n  bool GetShadowNDCPos(out vec3 shadowNDCPos, vec4 shadowPosWithDepthBias)\n  {\n  \tshadowNDCPos = shadowPosWithDepthBias.xyz / shadowPosWithDepthBias.w * 0.5 + 0.5;\n  \tif (shadowNDCPos.x < 0.0 || shadowNDCPos.x > 1.0 ||\n  \t\tshadowNDCPos.y < 0.0 || shadowNDCPos.y > 1.0 ||\n  \t\tshadowNDCPos.z < 0.0 || shadowNDCPos.z > 1.0) {\n  \t\treturn false;\n  \t}\n  \tshadowNDCPos.xy = cc_cameraPos.w == 1.0 ? vec2(shadowNDCPos.xy.x, 1.0 - shadowNDCPos.xy.y) : shadowNDCPos.xy;\n  \treturn true;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, vec3 matViewDir0, vec3 matViewDir1, vec3 matViewDir2, vec2 projScaleXY)\n  {\n    vec4 newShadowPos = shadowPos;\n    if (normalBias > EPSILON_LOWP)\n    {\n      vec3 viewNormal = vec3(dot(matViewDir0, worldNormal), dot(matViewDir1, worldNormal), dot(matViewDir2, worldNormal));\n      if (viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, mat4 matLightView, vec2 projScaleXY)\n  {\n  \tvec4 newShadowPos = shadowPos;\n  \tif (normalBias > EPSILON_LOWP)\n  \t{\n  \t\tvec4 viewNormal = matLightView * vec4(worldNormal, 0.0);\n  \t\tif (viewNormal.z < 0.1)\n  \t\t\tnewShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n  \t}\n  \treturn newShadowPos;\n  }\n  float GetViewSpaceDepthFromNDCDepth_Orthgraphic(float NDCDepth, float projScaleZ, float projBiasZ)\n  {\n  \treturn (NDCDepth - projBiasZ) / projScaleZ;\n  }\n  float GetViewSpaceDepthFromNDCDepth_Perspective(float NDCDepth, float homogenousDividW, float invProjScaleZ, float invProjBiasZ)\n  {\n  \treturn NDCDepth * invProjScaleZ + homogenousDividW * invProjBiasZ;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n  \tvec3 viewSpacePos;\n  \tviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n  \tviewSpacePos.z = GetViewSpaceDepthFromNDCDepth_Perspective(shadowPos.z, shadowPos.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n  \tviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n  \tvec4 clipSpacePos;\n  \tclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n  \tclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n  \t#if CC_SHADOWMAP_USE_LINEAR_DEPTH\n  \t\tclipSpacePos.z = GetLinearDepthFromViewSpace(viewSpacePos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n  \t\tclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n  \t#endif\n  \treturn clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias, float projScaleZ, float projBiasZ)\n  {\n  \tfloat coeffA = projScaleZ;\n  \tfloat coeffB = projBiasZ;\n  \tfloat viewSpacePos_z = GetViewSpaceDepthFromNDCDepth_Orthgraphic(shadowPos.z, projScaleZ, projBiasZ);\n  \tviewSpacePos_z += viewspaceDepthBias;\n  \tvec4 result = shadowPos;\n  \tresult.z = viewSpacePos_z * coeffA + coeffB;\n  \treturn result;\n  }\n  vec4 ApplyShadowDepthBias_PerspectiveLinearDepth(vec4 shadowPos, float viewspaceDepthBias, vec3 worldPos)\n  {\n    shadowPos.z = CCGetLinearDepth(worldPos, viewspaceDepthBias) * 2.0 - 1.0;\n    shadowPos.z *= shadowPos.w;\n    return shadowPos;\n  }\n  float CCGetDirLightShadowFactorHard (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCSpotShadowFactorBase(out vec4 shadowNDCPosWithBias, vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    float pcf = cc_shadowWHPBInfo.z;\n    vec4 pos = vec4(1.0);\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      pos = ApplyShadowDepthBias_PerspectiveLinearDepth(shadowPos, shadowBias.x, worldPos);\n    #else\n      pos = ApplyShadowDepthBias_Perspective(shadowPos, shadowBias.x);\n    #endif\n    float realtimeShadow = 1.0;\n    if (pcf > 2.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft5X(pos, worldPos);\n    }else if (pcf > 1.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft3X(pos, worldPos);\n    }else if (pcf > 0.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft(pos, worldPos);\n    }else {\n      realtimeShadow = CCGetSpotLightShadowFactorHard(pos, worldPos);\n    }\n    shadowNDCPosWithBias = pos;\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  float CCShadowFactorBase(out vec4 shadowNDCPosWithBias, vec4 shadowPos, vec3 N, vec2 shadowBias)\n  {\n    vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y, cc_matLightView, cc_shadowProjInfo.xy);\n    pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, cc_shadowProjDepthInfo.x, cc_shadowProjDepthInfo.y);\n    float realtimeShadow = 1.0;\n    #if CC_DIR_SHADOW_PCF_TYPE == 3\n      realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 2\n      realtimeShadow =  CCGetDirLightShadowFactorSoft3X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 1\n      realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 0\n      realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n    #endif\n    shadowNDCPosWithBias = pos;\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n    bool CCGetCSMLevelWithTransition(out highp float ratio, vec3 clipPos) {\n      highp float maxRange = 1.0 - cc_csmSplitsInfo.x;\n      highp float minRange = cc_csmSplitsInfo.x;\n      highp float thresholdInvert = 1.0 / cc_csmSplitsInfo.x;\n      ratio = 0.0;\n      if (clipPos.x <= minRange) {\n        ratio = clipPos.x * thresholdInvert;\n        return true;\n      }\n      if (clipPos.x >= maxRange) {\n        ratio = 1.0 - (clipPos.x - maxRange) * thresholdInvert;\n        return true;\n      }\n      if (clipPos.y <= minRange) {\n        ratio = clipPos.y  * thresholdInvert;\n        return true;\n      }\n      if (clipPos.y >= maxRange) {\n        ratio = 1.0 - (clipPos.y - maxRange) * thresholdInvert;\n        return true;\n      }\n      return false;\n    }\n    bool CCHasCSMLevel(int level, vec3 worldPos) {\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      bool hasLevel = false;\n      for (int i = 0; i < 4; i++) {\n        if (i == level) {\n          vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n          if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n              clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n              clipPos.z >= 0.0 && clipPos.z <= 1.0) {\n            hasLevel = true;\n          }\n        }\n      }\n      return hasLevel;\n    }\n    void CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos, int level) {\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && i == level) {\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n        }\n      }\n    }\n    int CCGetCSMLevel(out bool isTransitionArea, out highp float transitionRatio, out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n    {\n      int level = -1;\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && level < 0) {\n          #if CC_CASCADED_LAYERS_TRANSITION\n            isTransitionArea = CCGetCSMLevelWithTransition(transitionRatio, clipPos);\n          #endif\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n          level = i;\n        }\n      }\n      return level;\n    }\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n    {\n      bool isTransitionArea = false;\n      highp float transitionRatio = 0.0;\n      return CCGetCSMLevel(isTransitionArea, transitionRatio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n    }\n    float CCCSMFactorBase(out vec4 csmPos, out vec4 csmNDCPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias)\n    {\n      bool isTransitionArea = false;\n      highp float ratio = 0.0;\n      csmPos = vec4(1.0);\n      vec4 shadowProjDepthInfo, shadowProjInfo;\n      vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n      int level = -1;\n      #if CC_CASCADED_LAYERS_TRANSITION\n        level = CCGetCSMLevel(isTransitionArea, ratio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      #else\n        level = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      #endif\n      if (level < 0) { return 1.0; }\n      vec4 pos = ApplyShadowDepthBias_FaceNormal(csmPos, N, shadowBias.y, shadowViewDir0, shadowViewDir1, shadowViewDir2, shadowProjInfo.xy);\n      pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n      csmNDCPosWithBias = pos;\n      float realtimeShadow = 1.0;\n      #if CC_DIR_SHADOW_PCF_TYPE == 3\n        realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 2\n        realtimeShadow = CCGetDirLightShadowFactorSoft3X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 1\n        realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 0\n        realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n      #endif\n      #if CC_CASCADED_LAYERS_TRANSITION\n        vec4 nextCSMPos = vec4(1.0);\n        vec4 nextShadowProjDepthInfo, nextShadowProjInfo;\n        vec3 nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2;\n        float nextRealtimeShadow = 1.0;\n        CCGetCSMLevel(nextCSMPos, nextShadowProjDepthInfo, nextShadowProjInfo, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, worldPos, level + 1);\n        bool hasNextLevel = CCHasCSMLevel(level + 1, worldPos);\n        if (hasNextLevel && isTransitionArea) {\n          vec4 nexPos = ApplyShadowDepthBias_FaceNormal(nextCSMPos, N, shadowBias.y, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, nextShadowProjInfo.xy);\n          nexPos = ApplyShadowDepthBias_Orthographic(nexPos, shadowBias.x, nextShadowProjDepthInfo.x, nextShadowProjDepthInfo.y);\n          #if CC_DIR_SHADOW_PCF_TYPE == 3\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft5X(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 2\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft3X(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 1\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 0\n            nextRealtimeShadow = CCGetDirLightShadowFactorHard(nexPos);\n          #endif\n          return mix(mix(nextRealtimeShadow, realtimeShadow, ratio), 1.0, cc_shadowNFLSInfo.w);\n        }\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      #else\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      #endif\n    }\n  #else\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos) {\n      return -1;\n    }\n    float CCCSMFactorBase(out vec4 csmPos, out vec4 csmNDCPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias) {\n      csmPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n      return CCShadowFactorBase(csmNDCPosWithBias, csmPos, N, shadowBias);\n    }\n  #endif\n  float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias) {\n    vec4 shadowNDCPosWithBias;\n    return CCShadowFactorBase(shadowNDCPosWithBias, shadowPos, N, shadowBias);\n  }\n  float CCCSMFactorBase(vec3 worldPos, vec3 N, vec2 shadowBias) {\n    vec4 csmPos, csmNDCPosWithBias;\n    return CCCSMFactorBase(csmPos, csmNDCPosWithBias, worldPos, N, shadowBias);\n  }\n  float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    vec4 shadowNDCPosWithBias;\n    return CCSpotShadowFactorBase(shadowNDCPosWithBias, shadowPos, worldPos, shadowBias);\n  }\n#endif\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n\tcolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if CC_USE_LIGHT_PROBE\n  #if CC_USE_LIGHT_PROBE\n  vec3 SHEvaluate(vec3 normal)\n  {\n      vec3 result;\n  #if USE_INSTANCING\n      vec4 normal4 = vec4(normal, 1.0);\n      result.r = dot(v_sh_linear_const_r, normal4);\n      result.g = dot(v_sh_linear_const_g, normal4);\n      result.b = dot(v_sh_linear_const_b, normal4);\n  #else\n      vec4 normal4 = vec4(normal, 1.0);\n      result.r = dot(cc_sh_linear_const_r, normal4);\n      result.g = dot(cc_sh_linear_const_g, normal4);\n      result.b = dot(cc_sh_linear_const_b, normal4);\n      vec4 n14 = normal.xyzz * normal.yzzx;\n      float n5 = normal.x * normal.x - normal.y * normal.y;\n      result.r += dot(cc_sh_quadratic_r, n14);\n      result.g += dot(cc_sh_quadratic_g, n14);\n      result.b += dot(cc_sh_quadratic_b, n14);\n      result += (cc_sh_quadratic_a.rgb * n5);\n  #endif\n    #if CC_USE_HDR\n      result *= cc_exposure.w * cc_exposure.x;\n    #endif\n    return result;\n  }\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform highp vec4 cc_reflectionProbeData1;\n  uniform highp vec4 cc_reflectionProbeData2;\n  vec4 GetTexData(sampler2D dataMap, float dataMapWidth, float x, float uv_y)\n  {\n    return vec4(\n        decode32(texture2D(dataMap, vec2(((x + 0.5)/dataMapWidth), uv_y))),\n        decode32(texture2D(dataMap, vec2(((x + 1.5)/dataMapWidth), uv_y))),\n        decode32(texture2D(dataMap, vec2(((x + 2.5)/dataMapWidth), uv_y))),\n        decode32(texture2D(dataMap, vec2(((x + 3.5)/dataMapWidth), uv_y)))\n      );\n  }\n  void GetPlanarReflectionProbeData(out vec4 plane, out float planarReflectionDepthScale, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        plane.xyz = texData1.xyz;\n        plane.w = texData2.x;\n        planarReflectionDepthScale = texData2.y;\n        mipCount = texData2.z;\n      #else\n        plane = cc_reflectionProbeData1;\n        planarReflectionDepthScale = cc_reflectionProbeData2.x;\n        mipCount = cc_reflectionProbeData2.w;\n      #endif\n  }\n  void GetCubeReflectionProbeData(out vec3 centerPos, out vec3 boxHalfSize, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        vec4 texData3 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 8.0, uv_y);\n        centerPos = texData1.xyz;\n        boxHalfSize = texData2.xyz;\n        mipCount = texData3.x;\n      #else\n        centerPos = cc_reflectionProbeData1.xyz;\n        boxHalfSize = cc_reflectionProbeData2.xyz;\n        mipCount = cc_reflectionProbeData2.w;\n      #endif\n  }\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  uniform sampler2D cc_lightingMap;\n  void SampleAndDecodeLightMapColor(out vec3 lightmapColor, out float dirShadow, out float ao, sampler2D lightingMap, vec2 luv, float lum, vec3 worldNormal)\n  {\n  #if CC_LIGHT_MAP_VERSION > 2\n  #elif CC_LIGHT_MAP_VERSION > 1\n  \tvec4 dataLow = texture2D(lightingMap, luv);\n  \tvec4 dataHigh = texture2D(lightingMap, luv + vec2(0.5, 0.0));\n  \tlightmapColor.xyz = dataLow.xyz + dataHigh.xyz * 0.00392156862745098;\n      lightmapColor.rgb *= lum;\n  \tdirShadow = dataLow.a;\n  \tao = dataHigh.a;\n  #else\n      vec4 lightmap = texture2D(lightingMap, luv);\n      lightmapColor = lightmap.rgb * lum;\n  \tdirShadow = lightmap.a;\n  \tao = 1.0;\n  #endif\n  }\n  void GetLightMapColor(out vec3 lightmapColor, out float dirShadow, out float ao, sampler2D lightingMap, vec2 luv, float lum, vec3 worldNormal)\n  {\n  \tvec4 lightmap;\n  \tvec2 occlusion;\n  \tSampleAndDecodeLightMapColor(lightmapColor, dirShadow, ao, lightingMap, luv, lum, worldNormal);\n  #if CC_USE_HDR\n      lightmapColor.rgb *= cc_exposure.w * cc_exposure.x;\n  #endif\n  }\n#endif\n    uniform vec4 albedo;\n    uniform vec4 albedoScaleAndCutoff;\n    uniform vec4 emissive;\n    uniform float emissiveScale;\n    uniform float occlusion;\n    uniform float roughness;\n    uniform float metallic;\n    uniform float normalStrength;\n    uniform float alphaSource;\n    uniform float albedoScale;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_WEIGHT_MAP\n  uniform sampler2D baseWeightMap;\n#endif\n#if USE_METALLIC_MAP\n  uniform sampler2D metallicMap;\n#endif\n#if USE_ROUGHNESS_MAP\n  uniform sampler2D roughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  uniform sampler2D transparencyMap;\n#endif\n#if USE_TRANSPARENCYCOLOR_MAP\n  uniform sampler2D transparencyColorMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_EMISSIVESCALE_MAP\n  uniform sampler2D emissiveScaleMap;\n#endif\n#if USE_OPACITY_MAP\n  uniform sampler2D alphaSourceMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\nfloat discolor(vec3 srcColor) {\n  return dot(GRAY_VECTOR, srcColor);\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\nvec4 SurfacesFragmentModifyBaseColorAndTransparency()\n{\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(FSInput_vertexColor.rgb);\n    baseColor.a *= FSInput_vertexColor.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture2D(albedoMap, TEXTURE_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor = texColor;\n  #endif\n  #if USE_WEIGHT_MAP\n      vec4 weightColor = texture2D(baseWeightMap, TEXTURE_UV);\n      weightColor.rgb = SRGBToLinear(weightColor.rgb);\n      baseColor.rgb *= weightColor.rgb;\n  #else\n      baseColor.rgb *= albedoScale;\n  #endif\n  #if ALPHA_SOURCE_IS_OPACITY\n    #if USE_OPACITY_MAP\n      baseColor.a = 1.0 - texture2D(alphaSourceMap, TEXTURE_UV).ALPHA_SOURCE_CHANNEL;\n    #else\n      baseColor.a = 1.0 - alphaSource;\n    #endif\n  #else\n    #if USE_OPACITY_MAP\n      baseColor.a = texture2D(alphaSourceMap, TEXTURE_UV).ALPHA_SOURCE_CHANNEL;\n    #else\n      baseColor.a = alphaSource;\n    #endif\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.a < albedoScaleAndCutoff.w) discard;\n  #endif\n  return baseColor;\n}\n#define CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n#define CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\nvec3 SurfacesFragmentModifyWorldNormal()\n{\n  vec3 normal = FSInput_worldNormal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    normal = CalculateNormalFromTangentSpace(nmmp, normalStrength, normal.xyz, FSInput_worldTangent, FSInput_mirrorNormal);\n  #endif\n  return normalize(normal);\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\nvec3 SurfacesFragmentModifyEmissive()\n{\n  vec3 emissiveColor = emissive.rgb;\n  #if USE_EMISSIVE_MAP\n      emissiveColor.rgb = SRGBToLinear(texture2D(emissiveMap, TEXTURE_UV).rgb);\n  #endif\n  #if USE_EMISSIVESCALE_MAP\n      vec4 emissiveScaleColor = texture2D(emissiveScaleMap, TEXTURE_UV);\n      emissiveScaleColor.rgb = SRGBToLinear(emissiveScaleColor.rgb);\n      emissiveColor.rgb *= emissiveScaleColor.rgb;\n  #else\n      emissiveColor.rgb *= emissiveScale;\n  #endif\n  return emissiveColor.rgb;\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\nvec4 SurfacesFragmentModifyPBRParams()\n{\n  vec4 pbr = vec4(1.0,1.0,1.0,1.0);\n  float occlusionValue = 1.0;\n  #if USE_OCCLUSION_MAP\n     vec4 occlusionColor = texture2D(occlusionMap, TEXTURE_UV);\n     float occlusionColorValue = discolor(occlusionColor.rgb);\n     #if USE_OCCLUSION_CHANNEL\n         occlusionColor.rgb = SRGBToLinear(occlusionColor.rgb);\n         occlusionColorValue = occlusionColor.OCCLUSION_CHANNEL;\n     #endif\n     occlusionValue = mix(1.0, occlusionColorValue, occlusion);\n  #endif\n  pbr.x = occlusionValue;\n  float roughnessValue = roughness;\n  #if USE_ROUGHNESS_MAP\n     vec4 roughnessColor = texture2D(roughnessMap, TEXTURE_UV);\n     roughnessValue = discolor(roughnessColor.rgb);\n     #if USE_ROUGHNESS_CHANNEL\n         roughnessColor.rgb = SRGBToLinear(roughnessColor.rgb);\n         roughnessValue = roughnessColor.ROUGHNESS_CHANNEL;\n     #endif\n  #endif\n  pbr.y = max(0.02, roughnessValue);\n  float metallicValue = metallic;\n  #if USE_METALLIC_MAP\n     vec4 metallicColor = texture2D(metallicMap, TEXTURE_UV);\n     metallicValue = discolor(metallicColor.rgb);\n     #if USE_METALLIC_CHANNEL\n         metallicColor.rgb = SRGBToLinear(metallicColor.rgb);\n         metallicValue = metallicColor.METALLIC_CHANNEL;\n     #endif\n  #endif\n  pbr.z = metallicValue;\n  pbr.w = 0.5;\n  return pbr;\n}\nstruct LightingIntermediateData\n{\n  vec3 N, H, L, V;\n  float distToLight, distToLightSqr;\n  float distToCamera, distToCameraSqr;\n  float NoL, NoV, NoH;\n  float NoLSat, NoVSat, NoHSat;\n  float NoVAbsSat;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPosition, worldPosition_fract_part;\n  #else\n  vec3 worldPosition;\n  #endif\n  vec3 T, B;\n  float specularParam;\n  float ior;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 shadowPosAndDepth;\n  vec4 transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 transmitParams;\n  vec3 inScatteringLightColor;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 baseColorTT;\n  float ttIntensity, ttScatterCoef;\n#endif\n};\nvoid CCSurfacesLightingGetIntermediateData_PerPixel(inout LightingIntermediateData data, vec3 worldNormal, vec3 worldPos, vec3 worldTangent, vec3 worldBinormal\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n    , float anisotropyShape\n#endif\n)\n{\n  data.N = worldNormal;\n  data.V = cc_cameraPos.xyz - worldPos;\n  data.distToCameraSqr = dot(data.V, data.V);\n  data.distToCamera = sqrt(data.distToCameraSqr);\n  data.V /= data.distToCamera;\n  data.NoV = dot(data.N, data.V);\n  data.NoVSat = max(data.NoV, 0.0);\n  data.NoVAbsSat = max(abs(data.NoV), 0.0);\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(data.worldPosition, data.worldPosition_fract_part, worldPos);\n  #else\n  data.worldPosition = worldPos;\n  #endif\n  data.T = worldTangent;\n  data.B = worldBinormal;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  data.anisotropyShape = anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  data.inScatteringLightColor = vec3(0.0);\n  data.transmitParams = vec4(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  data.shadowPosAndDepth = vec4(0.0, 0.0, 999999.0, 999999.0);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  data.baseColorTT = vec3(0.0);\n  data.ttIntensity = data.ttScatterCoef = 0.0;\n#endif\n}\nvoid CCSurfacesLightingGetIntermediateData_PerLight(inout LightingIntermediateData data, vec3 lightDirWithDist)\n{\n  data.L = lightDirWithDist;\n  data.distToLightSqr = dot(data.L, data.L);\n  data.distToLight = sqrt(data.distToLightSqr);\n  data.L /= data.distToLight;\n  data.H = normalize(data.L + data.V);\n  data.NoL = dot(data.N, data.L);\n  data.NoH = dot(data.N, data.H);\n  data.NoLSat = max(data.NoL, 0.0);\n  data.NoHSat = max(data.NoH, 0.0);\n}\nstruct LightingResult\n{\n  vec3 diffuseColorWithLighting, specularColorWithLighting;\n  vec3 directDiffuse, directSpecular;\n  vec3 environmentDiffuse, environmentSpecular;\n  float shadow, ao;\n  vec3 lightmapColor;\n  vec3 emissive;\n#if CC_SURFACES_LIGHTING_USE_FRESNEL\n  float fresnel;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  vec3 directTransmitSpecular, environmentTransmitSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec3 directTransmitDiffuse, environmentTransmitDiffuse;\n#endif\n#if CC_SURFACES_LIGHTING_TRT\n  vec3 directTRT, environmentTRT;\n  vec3 specularColorWithLightingTRT;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 directTT;\n  vec3 diffuseColorWithLightingTT;\n#endif\n};\nstruct LightingMiscData\n{\n  float lightType;\n  vec3 lightPos, lightDir;\n  vec4 lightColorAndIntensity;\n  vec4 lightSizeRangeAngle;\n};\nfloat D_GGX(float roughness, float NoH)\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float d = (NoH * m2 - NoH) * NoH + 1.0;\n    return m2 / max(EPSILON, d * d);\n}\nfloat D_GGXMobile(float roughness, float NoH) {\n  float OneMinusNoHSqr = 1.0 - NoH * NoH;\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / max(EPSILON, OneMinusNoHSqr + n * n);\n  return p * p;\n}\nvoid GetAnisotropicRoughness(float roughness, float anisotropyShape, out float roughnessX, out float roughnessY)\n{\n    float shapeSign = sign(anisotropyShape);\n    anisotropyShape *= anisotropyShape;\n    float r1 = roughness, r2 = roughness;\n    float lerpedRoughness = mix(1.0, 10.0, anisotropyShape);\n    r2 *= shapeSign < 0.0 ? lerpedRoughness : 1.0;\n    r1 *= shapeSign > 0.0 ? lerpedRoughness : 1.0;\n    roughnessX = saturate(r1);\n    roughnessY = saturate(r2);\n}\nfloat D_GGXAniso(float RoughnessX, float RoughnessY, float NoH, vec3 H, vec3 X, vec3 Y)\n{\n    float mx = max(EPSILON_LOWP, RoughnessX * RoughnessX);\n    float my = max(EPSILON_LOWP, RoughnessY * RoughnessY);\n    float XoH = dot(X, H);\n    float YoH = dot(Y, H);\n    float d = XoH * XoH / (mx * mx) + YoH * YoH / (my * my) + NoH * NoH;\n    return 1.0 / max(EPSILON_LOWP, mx * my * d * d);\n}\nvec3 GetAnisotropicReflect(float roughness, float anisotropyShape, vec3 V, vec3 N, vec3 X, vec3 Y)\n{\n    float shapeSign = sign(anisotropyShape);\n    anisotropyShape *= anisotropyShape;\n    anisotropyShape = min(anisotropyShape, 0.4);\n    anisotropyShape *= smoothstep(0.0, 0.03, roughness);\n    vec3 reflectTarget = shapeSign < 0.0 ? mix(N, -Y, anisotropyShape) :\n                         shapeSign > 0.0 ? mix(N, -X, anisotropyShape) : N;\n    return reflect(-V, reflectTarget);\n}\nvec3 IntegratedGFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return max(vec3(0.0), specular * AB.x + AB.y);\n}\n#define DiffuseCoefficient_EnergyConservation INV_PI\nfloat CalculateFresnelCoefficient(float ior, float NoVSat)\n{\n\tfloat g, c, n, prev, next;\n\tn = ior;\n\tc = ior * NoVSat;\n\tg = sqrt(1.0 + c * c - c);\n\tprev = (g - c) / (g + c);\n\tnext = (c * (g+c) - n*n) / (c * (g-c) + n*n);\n\tprev *= prev;\n\tnext *= next;\n\treturn 0.5 * prev * (1.0 + next);\n}\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\nfloat CalculateDistanceAttenuation(float distToLightSqr, float lightRadius, float lightRange)\n{\n  float litRadiusSqr = lightRadius * lightRadius;\n  float attRadiusSqrInv = 1.0 / max(lightRange, 0.01);\n  attRadiusSqrInv *= attRadiusSqrInv;\n  float edgeAttenuation = litRadiusSqr / max(litRadiusSqr, distToLightSqr);\n  return GetDistAtt(distToLightSqr, attRadiusSqrInv) * edgeAttenuation;\n}\nfloat CalculateAngleAttenuation(vec3 spotLightDir, vec3 L, float cosAngleOuter)\n{\n  float cosInner = max(dot(spotLightDir, L), 0.01);\n  float litAngleScale = 1.0 / max(0.001, cosInner - cosAngleOuter);\n  float litAngleOffset = -cosAngleOuter * litAngleScale;\n  return GetAngleAtt(L, spotLightDir, litAngleScale, litAngleOffset);\n}\nvec3 CalculateRefractDirection(vec3 N, vec3 V, float NoV, float ior)\n{\n  float NoVAbs = abs(NoV);\n  float sideSign = NoV < 0.0 ? -1.0 : 1.0;\n  N *= sideSign;\n  NoV *= sideSign;\n  float sinB = sqrt(1.0 - NoVAbs*NoVAbs) / ior;\n  vec3 X = normalize(-V + N * NoVAbs);\n  vec3 R = -N + X * sinB;\n  return R;\n}\nvec3 CalculateReflectDirection(vec3 N, vec3 V, float NoV)\n{\n  float sideSign = NoV < 0.0 ? -1.0 : 1.0;\n  N *= sideSign;\n  return reflect(-V, N);\n}\nvec3 CalculatePlanarReflectPositionOnPlane(vec3 N, vec3 V, vec3 worldPos, vec4 plane, vec3 cameraPos, float probeReflectedDepth)\n{\n  float distPixelToPlane = -dot(plane, vec4(worldPos, 1.0));\n  plane.w += distPixelToPlane;\n  float distCameraToPlane = abs(-dot(plane, vec4(cameraPos, 1.0)));\n  vec3 planeN = plane.xyz;\n  vec3 virtualCameraPos = cameraPos - 2.0 * distCameraToPlane * planeN;\n  vec3 bumpedR = normalize(reflect(-V, N));\n  vec3 reflectedPointPos = worldPos + probeReflectedDepth * bumpedR;\n  vec3 virtualCameraToReflectedPoint = normalize(reflectedPointPos - virtualCameraPos);\n  float y = distCameraToPlane / max(EPSILON_LOWP, dot(planeN, virtualCameraToReflectedPoint));\n  return virtualCameraPos + y * virtualCameraToReflectedPoint;\n}\nvec4 CalculateBoxProjectedDirection(vec3 R, vec3 worldPos, vec3 cubeCenterPos, vec3 cubeBoxHalfSize)\n{\n  vec3 W = worldPos - cubeCenterPos;\n  vec3 projectedLength = (sign(R) * cubeBoxHalfSize - W) / (R + vec3(EPSILON));\n  float len = min(min(projectedLength.x, projectedLength.y), projectedLength.z);\n  vec3 P = W + len * R;\n  float weight = len < 0.0 ? 0.0 : 1.0;\n  return vec4(P, weight);\n}\nvec3 CalculateDirectDiffuse(in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n    vec3 irradiance = vec3(lightingData.NoLSat) * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    return irradiance * DiffuseCoefficient_EnergyConservation;\n}\nvec3 CalculateDirectSpecular(in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n    vec3 irradiance = vec3(lightingData.NoLSat) * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    float roughness = lightingData.specularParam;\n  #if CC_SURFACES_LIGHTING_ANISOTROPIC\n      float rT, rB;\n      GetAnisotropicRoughness(roughness, lightingData.anisotropyShape, rT, rB);\n      float calcSpec = D_GGXAniso(rT, rB, lightingData.NoHSat, lightingData.H, lightingData.T, lightingData.B);\n  #else\n    #if CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n      float calcSpec = (roughness * 0.25 + 0.25) * D_GGXMobile(roughness, lightingData.NoHSat);\n    #else\n      float calcSpec = D_GGX(roughness, lightingData.NoHSat);\n    #endif\n  #endif\n    return irradiance * calcSpec;\n}\n#if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  vec3 EnvAnisotropicReflection(samplerCube tex, vec3 R, float roughness, float mipCount, float anisotropyShape, vec3 V, vec3 N, vec3 T, vec3 B) {\n      R = normalize(R);\n      float integratedBRDF = 0.0;\n      vec3 envSpec = vec3(0.0);\n      const int SAMPLE_STEP_COUNT = CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT;\n      float sampleAngleRange = PI * abs(anisotropyShape);\n      vec3 anisoDirection = anisotropyShape < 0.0 ? T : B;\n      vec3 ROnNormalPlane = normalize(R - anisoDirection * dot(R, anisoDirection));\n      vec3 stepOffset = normalize(ROnNormalPlane - N) * (sampleAngleRange / float(SAMPLE_STEP_COUNT * 2));\n      for (int i = -SAMPLE_STEP_COUNT; i <= SAMPLE_STEP_COUNT; ++i)\n      {\n          float rT, rB;\n          GetAnisotropicRoughness(roughness, anisotropyShape, rT, rB);\n          #if CC_IBL_CONVOLUTED\n            float coef = abs(float(i)) / float(SAMPLE_STEP_COUNT) * float(SAMPLE_STEP_COUNT);\n          #else\n            float coef = pow(abs(float(i)) / float(SAMPLE_STEP_COUNT), 1.3) * float(SAMPLE_STEP_COUNT);\n          #endif\n          vec3 H = normalize(N + stepOffset * sign(float(i)) * coef);\n          vec3 L = reflect(-V, H);\n          float NoHSat = saturate(dot(N, H));\n          float calcSpec = D_GGXAniso(rT, rB, NoHSat, H, T, B);\n          envSpec += calcSpec * EnvReflection(tex, L, roughness, mipCount);\n          integratedBRDF += calcSpec;\n      }\n      envSpec /= integratedBRDF;\n      return envSpec;\n  }\n#endif\nvec3 SampleEnvironmentSpecular(samplerCube tex, in LightingIntermediateData lightingData, float mipCount)\n{\n    vec3 envSpec = vec3(0.0);\n    float roughness = lightingData.specularParam;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && !CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      vec3 R = GetAnisotropicReflect(roughness, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      vec3 R = CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV);\n    #endif\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      envSpec = EnvAnisotropicReflection(tex, R, roughness, mipCount, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      #if CC_SURFACES_USE_REFLECTION_DENOISE && !CC_IBL_CONVOLUTED\n        envSpec = EnvReflectionWithMipFiltering(normalize(R), roughness, mipCount, 0.6);\n      #else\n        envSpec = EnvReflection(tex, R, roughness, mipCount);\n      #endif\n    #endif\n    return envSpec;\n}\nvec3 SampleEnvironmentSpecular(samplerCube tex, in LightingIntermediateData lightingData, float mipCount, vec3 worldPos, vec3 cubeCenterPos, vec3 boxHalfSize)\n{\n    vec3 envSpec = vec3(0.0);\n    float roughness = lightingData.specularParam;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && !CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      vec3 R = GetAnisotropicReflect(roughness, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      vec3 R = CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV);\n    #endif\n    vec4 fixedR = CalculateBoxProjectedDirection(R, worldPos, cubeCenterPos, boxHalfSize);\n    R = fixedR.xyz;\n    vec3 envmap = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w).xyz;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      envSpec = EnvAnisotropicReflection(tex, fixedR.xyz, roughness, mipCount, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n      envSpec = mix(envmap, envSpec, fixedR.w);\n    #else\n      #if CC_SURFACES_USE_REFLECTION_DENOISE && !CC_IBL_CONVOLUTED\n        envSpec = EnvReflectionWithMipFiltering(normalize(R), roughness, mipCount, 0.6);\n      #else\n        envSpec = mix(envmap, EnvReflection(tex, R, roughness, mipCount), fixedR.w);\n      #endif\n    #endif\n    return envSpec;\n}\nvec3 CalculateEnvironmentDiffuse(in LightingIntermediateData lightingData, float lightIntensity)\n{\n  float fAmb = max(EPSILON, 0.5 - lightingData.N.y * 0.5);\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP && !CC_USE_LIGHT_PROBE\n      vec3 rotationDir = RotationVecFromAxisY(lightingData.N, cc_surfaceTransform.z, cc_surfaceTransform.w);\n      vec4 diffuseMap = textureCube(cc_diffuseMap, rotationDir);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n  #endif\n  ambDiff.rgb *= lightIntensity;\n  #if CC_USE_LIGHT_PROBE\n    ambDiff.rgb += SHEvaluate(lightingData.N);\n  #endif\n  return ambDiff.rgb;\n}\nvec3 CalculateEnvironmentSpecular(in LightingIntermediateData lightingData, float lightIntensity)\n{\n  vec3 envSpec = vec3(0.0);\n#if CC_USE_REFLECTION_PROBE\n    vec3 worldPos;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    worldPos = unpackHighpData(lightingData.worldPosition, lightingData.worldPosition_fract_part);\n    #else\n    worldPos = lightingData.worldPosition;\n    #endif\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n    if(FSInput_reflectionProbeId < 0.0){\n        envSpec = SampleEnvironmentSpecular(cc_reflectionProbeCubemap, lightingData, cc_ambientGround.w);\n    }else{\n      vec3 centerPos, boxHalfSize;\n      float mipCount;\n      GetCubeReflectionProbeData(centerPos, boxHalfSize, mipCount, FSInput_reflectionProbeId);\n      envSpec = SampleEnvironmentSpecular(cc_reflectionProbeCubemap, lightingData, mipCount, worldPos, centerPos, boxHalfSize);\n    }\n  #elif CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_PLANAR\n    vec3 R = normalize(CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV));\n    if(FSInput_reflectionProbeId < 0.0){\n        vec2 screenUV = GetPlanarReflectScreenUV(worldPos, cc_matViewProj, cc_cameraPos.w, lightingData.V, R);\n        envSpec = unpackRGBE(fragTextureLod(cc_reflectionProbePlanarMap, screenUV, 1.0)).xyz;\n    }else{\n        vec4 plane;\n        float planarReflectionDepthScale, mipCount;\n        GetPlanarReflectionProbeData(plane, planarReflectionDepthScale, mipCount, FSInput_reflectionProbeId);\n        vec3 worldPosOffset = CalculatePlanarReflectPositionOnPlane(lightingData.N, lightingData.V, worldPos, plane, cc_cameraPos.xyz, planarReflectionDepthScale);\n        vec2 screenUV = GetPlanarReflectScreenUV(worldPosOffset, cc_matViewProj, cc_cameraPos.w, lightingData.V, R);\n        envSpec = unpackRGBE(fragTextureLod(cc_reflectionProbePlanarMap, screenUV, mipCount)).xyz;\n    }\n  #endif\n#elif CC_USE_IBL\n    envSpec = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w);\n#endif\n  return envSpec * lightIntensity;\n}\nbool CCSurfacesLightingEnableShadow(in float NoL)\n{\n  return NoL > 0.0;\n}\nfloat CCSurfacesLightingCalculateDistanceAttenuation(in LightingIntermediateData lightingData, in vec4 lightSizeRangeAngle)\n{\n  return CalculateDistanceAttenuation(lightingData.distToLightSqr, lightSizeRangeAngle.x, lightSizeRangeAngle.y);\n}\nfloat CCSurfacesLightingCalculateAngleAttenuation(in LightingIntermediateData lightingData, in vec4 lightSizeRangeAngle, in vec3 spotLightDir)\n{\n  return CalculateAngleAttenuation(spotLightDir, lightingData.L, lightSizeRangeAngle.z);\n}\nvoid CCSurfacesLightingCalculateDirect(out vec3 lightingDiffuse, out vec3 lightingSpecular, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n#if CC_SURFACES_LIGHTING_CALCULATE_DIFFUSE\n  lightingDiffuse = CalculateDirectDiffuse(lightingData, lightSourceColorAndIntensity);\n#else\n  lightingDiffuse = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_CALCULATE_SPECULAR\n  lightingSpecular = CalculateDirectSpecular(lightingData, lightSourceColorAndIntensity);\n#else\n  lightingSpecular = vec3(0.0);\n#endif\n}\nvoid CCSurfacesLightingCalculateEnvironment(out vec3 lightingDiffuse, out vec3 lightingSpecular, in LightingIntermediateData lightingData, float lightIntensity)\n{\n#if CC_SURFACES_LIGHTING_CALCULATE_DIFFUSE\n  lightingDiffuse = CalculateEnvironmentDiffuse(lightingData, lightIntensity);\n#else\n  lightingDiffuse = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_CALCULATE_SPECULAR\n  lightingSpecular = CalculateEnvironmentSpecular(lightingData, lightIntensity);\n#else\n  lightingSpecular = vec3(0.0);\n#endif\n}\n#if CC_SURFACES_LIGHTING_USE_FRESNEL\n  float CCSurfaceLightingCalculateFresnel(in LightingIntermediateData lightingData)\n  {\n    return CalculateFresnelCoefficient(lightingData.ior, abs(lightingData.NoV));\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  void CCSurfacesLightingCalculateDirectTransmitSpecular(out vec3 lightingSpecular, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n  {\n    float roughness = lightingData.specularParam;\n    float NoLSat = saturate(dot(lightingData.N, -lightingData.L));\n    vec3 irradiance = NoLSat * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    vec3 R = CalculateRefractDirection(lightingData.N, lightingData.V, lightingData.NoV, lightingData.ior);\n    float RoL = dot(lightingData.L, normalize(R));\n    float calcSpec = D_GGX(roughness, saturate(RoL));\n    lightingSpecular = irradiance * calcSpec;\n  }\n  void CCSurfacesLightingCalculateEnvironmentTransmitSpecular(out vec3 lightingSpecular, in LightingIntermediateData lightingData, float lightIntensity)\n  {\n    vec3 envSpec = vec3(0.0);\n    vec3 R = CalculateRefractDirection(lightingData.N, lightingData.V, lightingData.NoV, lightingData.ior);\n    float roughness = lightingData.specularParam;\n  #if CC_USE_REFLECTION_PROBE\n    #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n      envSpec = EnvReflection(cc_reflectionProbeCubemap, R, roughness, cc_ambientGround.w);\n    #endif\n  #endif\n  #if CC_USE_IBL && CC_USE_REFLECTION_PROBE != REFLECTION_PROBE_TYPE_CUBE\n    envSpec = EnvReflection(cc_environment, R, roughness, cc_ambientGround.w);\n  #endif\n    lightingSpecular = envSpec * lightIntensity;\n    float distance = lightingData.transmitParams.w, inScatterCoef = lightingData.transmitParams.z;\n    vec2 e = lightingData.transmitParams.xy;\n    vec2 extinction = exp(-e * distance * vec2(1.0, inScatterCoef));\n    vec3 inScattered = (1.0 - extinction.y) * lightingData.inScatteringLightColor.rgb;\n    lightingSpecular = lightingSpecular * extinction.x + inScattered;\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  void CCSurfacesLightingCalculateDirectTransmitDiffuse(out vec3 transmitDiffuse, in LightingResult lightingResult, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n  {\n    vec3 backIrradiance = vec3(saturate(-lightingData.NoL)) * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    vec3 transmitDiffuse = backIrradiance * DiffuseCoefficient_EnergyConservation;\n    lightingData.transmitParams;\n    lightingData.transmitDiffuseParams;\n    transmitDiffuse = vec3(0.0);\n  }\n  void CCSurfacesLightingCalculateEnvironmentTransmitDiffuse(out vec3 transmitDiffuse, in LightingResult lightingResult, in LightingIntermediateData lightingData, float lightIntensity)\n  {\n    lightingData.N *= -1.0;\n    vec3 backIrradiance = CalculateEnvironmentDiffuse(lightingData, lightIntensity);\n    lightingData.transmitParams;\n    lightingData.transmitDiffuseParams;\n    transmitDiffuse = vec3(0.0);\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TRT\n  #ifndef CC_SURFACES_FRAGMENT_MODIFY_TRT_SPECULAR_COLOR\n    vec3 SurfacesLightingGetTRTSpecularColor(float specBRDF, bool isSaturated)\n    {\n      return vec3(specBRDF);\n    }\n  #endif\n  void CCSurfacesLightingCalculateDirectTRT(out vec3 TRTLighting, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n  {\n    vec3 unused;\n    CCSurfacesLightingCalculateDirect(unused, TRTLighting, lightingData, vec4(1.0));\n    float brdf = TRTLighting.x;\n    vec3 Color = SurfacesLightingGetTRTSpecularColor(brdf, true);\n    TRTLighting *= Color * lightSourceColorAndIntensity.w;\n  }\n  void CCSurfacesLightingCalculateEnvironmentTRT(out vec3 TRTLighting, in LightingIntermediateData lightingData, float lightIntensity)\n  {\n    vec3 unused;\n    TRTLighting = CalculateEnvironmentSpecular(lightingData, 1.0);\n    float brdf = length(TRTLighting);\n    vec3 Color = SurfacesLightingGetTRTSpecularColor(brdf, false);\n    TRTLighting *= Color * lightIntensity;\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  void CCSurfacesLightingCalculateDirectTT(inout LightingResult lightingResult, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n  {\n    lightingResult.diffuseColorWithLightingTT = lightingResult.diffuseColorWithLighting;\n    float w = lightingData.ttIntensity;\n    vec3 scatteredLighting = pow(saturate(lightingData.baseColorTT * w + lightingData.NoLSat) * lightingData.NoLSat, vec3(mix(0.5, 0.5 + lightingData.ttScatterCoef, w)));\n    vec3 ttLighting = scatteredLighting - lightingData.NoLSat;\n    lightingResult.directTT = ttLighting * DiffuseCoefficient_EnergyConservation * lightSourceColorAndIntensity.xyz* lightSourceColorAndIntensity.w;\n  }\n#endif\nstruct SurfacesMaterialData\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPos, worldPos_fract_part;\n  #else\n  vec3 worldPos;\n  #endif\n  vec4 baseColor;\n  vec3 worldNormal;\n  vec3 emissive;\n  float specularIntensity;\n  float roughness;\n  float metallic;\n  float ao;\n  vec3 worldTangent, worldBinormal;\n  float ior;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec3 inScatteringLightColor;\n  vec4 transmitParams;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_TRT\n  vec3 baseColorTRT;\n  float trtIntensity, roughnessTRT;\n  vec3 worldTangentTRT, worldBinormalTRT;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 baseColorTT;\n  float ttIntensity, ttScatterCoef;\n#endif\n};\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\nvec4 SurfacesFragmentModifyBaseColorAndTransparency()\n{\n    return FSInput_vertexColor;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\nvec3 SurfacesFragmentModifyWorldNormal()\n{\n    return normalize(FSInput_worldNormal);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_WORLD_TANGENT_AND_BINORMAL\nvoid SurfacesFragmentModifyWorldTangentAndBinormal(inout vec3 worldTangent, inout vec3 worldBinormal, vec3 worldNormal)\n{\n    vec3 tangent = FSInput_worldTangent;\n#if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 binormal = normalize(CalculateBinormal(worldNormal.xyz, tangent, FSInput_mirrorNormal));\n    tangent = normalize(cross(binormal, worldNormal));\n#else\n    vec3 binormal = vec3(0.0, 0.0, 0.0);\n#endif\n    worldTangent = tangent;\n    worldBinormal = binormal;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_IOR\nfloat SurfacesFragmentModifyIOR()\n{\n    return 1.0;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_ANISOTROPY_PARAMS\nvec4 SurfacesFragmentModifyAnisotropyParams(out float isRotation)\n{\n    isRotation = 1.0;\n    return vec4(1.0, 0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\nvec3 SurfacesFragmentModifyEmissive()\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\nvec4 SurfacesFragmentModifyPBRParams()\n{\n    return vec4(1.0, 0.5, 0.0, 0.5);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_PARAMS\nvoid SurfacesFragmentModifyTransmitParams(out vec4 transmitParams, out vec3 inScatteringLightColor)\n{\n    transmitParams = vec4(0.0, 0.0, 0.0, 0.0);\n    inScatteringLightColor = vec3(0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_DIFFUSE_PARAMS\nvec4 SurfacesFragmentModifyTransmitDiffuseParams()\n{\n    return vec4(1.0, 0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRT_PARAMS\nvec4 SurfacesFragmentModifyTRTParams()\n{\n    return vec4(0.2, 0.0, 0.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRT_COLOR\nvec3 SurfacesFragmentModifyTRTColor()\n{\n    return vec3(1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TT_PARAMS\nvec4 SurfacesFragmentModifyTTParams()\n{\n    return vec4(0.0, 0.0, 0.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TT_COLOR\nvec3 SurfacesFragmentModifyTTColor(in vec3 baseColor, in vec3 trtColor)\n{\n    return vec3(1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_SHARED_DATA\nvoid SurfacesFragmentModifySharedData(inout SurfacesMaterialData surfaceData)\n{\n}\n#endif\nvoid CCSurfacesFragmentGetMaterialData(inout SurfacesMaterialData surfaceData)\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part, FSInput_worldPos);\n  #else\n  surfaceData.worldPos = FSInput_worldPos;\n  #endif\n  surfaceData.baseColor = SurfacesFragmentModifyBaseColorAndTransparency();\n  surfaceData.worldNormal = SurfacesFragmentModifyWorldNormal();\n  SurfacesFragmentModifyWorldTangentAndBinormal(surfaceData.worldTangent, surfaceData.worldBinormal, surfaceData.worldNormal);\n  surfaceData.ior = SurfacesFragmentModifyIOR();\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float isRotation;\n  vec4 anisotropyParams = SurfacesFragmentModifyAnisotropyParams(isRotation);\n  surfaceData.anisotropyShape = anisotropyParams.x;\n  if (isRotation > 0.0) {\n    RotateTangentAndBinormal(surfaceData.worldTangent, surfaceData.worldBinormal, surfaceData.worldNormal, anisotropyParams.y);\n  } else {\n    vec3 anisoDirTS = anisotropyParams.yzw;\n    vec3 tangentWS = anisoDirTS.x * surfaceData.worldTangent + anisoDirTS.y * surfaceData.worldBinormal + anisoDirTS.z * surfaceData.worldNormal;\n    surfaceData.worldTangent = normalize(tangentWS);\n    surfaceData.worldBinormal = cross(surfaceData.worldNormal, tangentWS);\n  }\n#endif\n  surfaceData.emissive = SurfacesFragmentModifyEmissive();\n  vec4 pbr = SurfacesFragmentModifyPBRParams();\n  surfaceData.ao = pbr.x;\n  surfaceData.roughness = pbr.y;\n  surfaceData.metallic = pbr.z;\n  surfaceData.specularIntensity = pbr.w;\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  SurfacesFragmentModifyTransmitParams(surfaceData.transmitParams, surfaceData.inScatteringLightColor);\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  surfaceData.transmitDiffuseParams = SurfacesFragmentModifyTransmitDiffuseParams();\n#endif\n  vec3 baseColorTRT = vec3(0.0);\n#if CC_SURFACES_LIGHTING_TRT\n  vec4 trtParams = SurfacesFragmentModifyTRTParams();\n  surfaceData.roughnessTRT = saturate(surfaceData.roughness + trtParams.x);\n  surfaceData.trtIntensity = trtParams.w;\n  surfaceData.baseColorTRT = baseColorTRT = SurfacesFragmentModifyTRTColor();\n  surfaceData.worldTangentTRT = surfaceData.worldTangent;\n  surfaceData.worldBinormalTRT = surfaceData.worldBinormal;\n  RotateTangentAndBinormal(surfaceData.worldTangentTRT, surfaceData.worldBinormalTRT, surfaceData.worldNormal, trtParams.y * PI);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec4 ttParams = SurfacesFragmentModifyTTParams();\n  surfaceData.ttScatterCoef = ttParams.x;\n  surfaceData.ttIntensity = ttParams.w;\n  surfaceData.baseColorTT = SurfacesFragmentModifyTTColor(surfaceData.baseColor.rgb, baseColorTRT);\n#endif\n  SurfacesFragmentModifySharedData(surfaceData);\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP) {\n      surfaceData.worldNormal = FSInput_worldNormal;\n      surfaceData.worldTangent = FSInput_worldTangent;\n  }\n#endif\n#if CC_USE_DEBUG_VIEW\n  if (!IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO)\n  {\n      surfaceData.baseColor.rgb = vec3(1.0);\n      #if CC_SURFACES_LIGHTING_TRT\n        surfaceData.baseColorTRT.rgb = vec3(1.0);\n      #endif\n      #if CC_SURFACES_LIGHTING_TT\n        surfaceData.baseColorTT.rgb = vec3(1.0);\n      #endif\n  }\n#endif\n}\nvec3 CCSurfacesGetDiffuseColor(in SurfacesMaterialData surfaceData)\n{\n  return surfaceData.baseColor.rgb * (1.0 - surfaceData.metallic);\n}\nvec3 CCSurfacesGetSpecularColor(in SurfacesMaterialData surfaceData)\n{\n  float F0 = surfaceData.specularIntensity * 0.08;\n  return mix(vec3(F0), surfaceData.baseColor.rgb, surfaceData.metallic);\n}\nvoid CCSurfacesLightingInitializeColorWithLighting(inout vec3 diffuseColorWithLighting, inout vec3 specularColorWithLighting, in SurfacesMaterialData surfaceData, in LightingIntermediateData lightingData)\n{\n  diffuseColorWithLighting = CCSurfacesGetDiffuseColor(surfaceData);\n  specularColorWithLighting = IntegratedGFApprox(CCSurfacesGetSpecularColor(surfaceData).xyz, surfaceData.roughness, lightingData.NoVAbsSat);\n}\nvoid CCSurfacesLightingCalculateColorWithLighting(inout vec3 diffuseColorWithLighting, inout vec3 specularColorWithLighting, in SurfacesMaterialData surfaceData, in LightingIntermediateData lightingData)\n{\n}\nvoid CCSurfacesInitializeLightingIntermediateData(inout LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData)\n{\n  vec3 worldPos;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n  #else\n  worldPos = surfaceData.worldPos;\n  #endif\n  CCSurfacesLightingGetIntermediateData_PerPixel(lightingData, surfaceData.worldNormal, worldPos, surfaceData.worldTangent, surfaceData.worldBinormal\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n      , surfaceData.anisotropyShape\n#endif\n  );\n  lightingData.specularParam = surfaceData.roughness;\n  lightingData.ior = surfaceData.ior;\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  lightingData.transmitParams = surfaceData.transmitParams;\n  lightingData.inScatteringLightColor = surfaceData.inScatteringLightColor;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  lightingData.transmitDiffuseParams = surfaceData.transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  lightingData.baseColorTT = surfaceData.baseColorTT;\n  lightingData.ttIntensity = surfaceData.ttIntensity;\n  lightingData.ttScatterCoef = surfaceData.ttScatterCoef;\n#endif\n}\nvoid CCSurfacesLightingCalculateIntermediateData_PerLight(inout LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData, vec3 lightDirWithDist)\n{\n  CCSurfacesLightingGetIntermediateData_PerLight(lightingData, lightDirWithDist);\n}\n#if CC_SURFACES_LIGHTING_TRT\nvoid CCSurfacesGetLightingIntermediateDataTRT(inout LightingIntermediateData lightingDataTRT, in LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData)\n{\n  lightingDataTRT = lightingData;\n  lightingDataTRT.specularParam = surfaceData.roughnessTRT;\n  lightingDataTRT.T = surfaceData.worldTangentTRT;\n  lightingDataTRT.B = surfaceData.worldBinormalTRT;\n}\nvoid CCSurfacesGetSurfacesMaterialDataTRT(inout SurfacesMaterialData surfaceDataTRT, in SurfacesMaterialData surfaceData)\n{\n  surfaceDataTRT = surfaceData;\n  surfaceDataTRT.baseColor = vec4(surfaceData.baseColorTRT, 1.0);\n}\n#endif\nvoid CCSurfacesInitializeLightingResult(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData)\n{\n  lightingResult.ao = surfaceData.ao;\n  lightingResult.emissive = surfaceData.emissive;\n}\nvoid CCSurfacesInitializeLightingResult(inout LightingResult lightingResult)\n{\n  lightingResult.directDiffuse = lightingResult.directSpecular = vec3(0.0);\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  lightingResult.directTransmitSpecular = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  lightingResult.directTransmitDiffuse = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TRT\n  lightingResult.directTRT = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  lightingResult.directTT = vec3(0.0);\n#endif\n}\nvoid CCSurfacesAccumulateLightingResult(inout LightingResult lightingResultAccumulated, in LightingResult lightingResult)\n{\n  lightingResultAccumulated.directDiffuse += lightingResult.directDiffuse * lightingResult.shadow;\n  lightingResultAccumulated.directSpecular += lightingResult.directSpecular * lightingResult.shadow;\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    lightingResultAccumulated.directTransmitSpecular += lightingResult.directTransmitSpecular;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    lightingResultAccumulated.directTransmitDiffuse += lightingResult.directTransmitDiffuse;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRT\n    lightingResultAccumulated.directTRT += lightingResult.directTRT * lightingResult.shadow;\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    lightingResultAccumulated.directTT += lightingResult.directTT * lightingResult.shadow;\n    lightingResultAccumulated.diffuseColorWithLightingTT = lightingResult.diffuseColorWithLightingTT;\n  #endif\n}\n#if CC_PIPELINE_TYPE == 1\n  vec4 CCSurfacesDeferredOutput0(in SurfacesMaterialData surfaceData)\n  {\n    return surfaceData.baseColor;\n  }\n  vec4 CCSurfacesDeferredOutput1(in SurfacesMaterialData surfaceData)\n  {\n    return vec4(float32x3_to_oct(surfaceData.worldNormal), surfaceData.roughness, surfaceData.metallic);\n  }\n  vec4 CCSurfacesDeferredOutput2(in SurfacesMaterialData surfaceData)\n  {\n    return vec4(surfaceData.emissive, surfaceData.ao);\n  }\n#endif\nvec4 CCSurfacesShading(in SurfacesMaterialData surfaceData, in LightingResult lightingResult)\n{\n  vec4 color = vec4(0.0, 0.0, 0.0, surfaceData.baseColor.a);\n#if CC_FORWARD_ADD\n  color.xyz += lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.directSpecular * lightingResult.specularColorWithLighting;\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.directTransmitSpecular * lightingResult.specularColorWithLighting\n  #endif\n  ;\n#else\n  float fresnel = 1.0;\n  #if CC_SURFACES_LIGHTING_USE_FRESNEL\n    fresnel = lightingResult.fresnel;\n  #endif\n  float invFresnel = 1.0 - fresnel;\n  color.xyz +=\n    ( lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.directSpecular * lightingResult.specularColorWithLighting * fresnel\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.directTransmitSpecular * lightingResult.specularColorWithLighting * invFresnel\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    + lightingResult.directTransmitDiffuse\n  #endif\n  #if CC_SURFACES_LIGHTING_TRT\n    + lightingResult.directTRT * lightingResult.specularColorWithLightingTRT * surfaceData.trtIntensity * surfaceData.baseColorTRT\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    + lightingResult.directTT * lightingResult.diffuseColorWithLightingTT\n  #endif\n    )\n    * lightingResult.shadow;\n  #if CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_ALL_IN_ONE\n    color.xyz += lightingResult.lightmapColor * lightingResult.diffuseColorWithLighting * lightingResult.shadow;\n  #elif CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_INDIRECT_OCCLUSION\n    color.xyz += lightingResult.lightmapColor * lightingResult.diffuseColorWithLighting;\n  #endif\n  color.xyz +=\n    ( lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.environmentSpecular * lightingResult.specularColorWithLighting * fresnel\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.environmentTransmitSpecular * lightingResult.specularColorWithLighting * invFresnel\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    + lightingResult.environmentTransmitDiffuse\n  #endif\n  #if CC_SURFACES_LIGHTING_TRT\n    + lightingResult.environmentTRT * lightingResult.specularColorWithLightingTRT * surfaceData.trtIntensity * surfaceData.baseColorTRT\n  #endif\n    )\n    * lightingResult.ao;\n  color.xyz += lightingResult.emissive;\n#endif\n  return color;\n}\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE\nvoid CCSurfacesDebugViewSurfaceData(inout vec4 color, in SurfacesMaterialData surfaceData)\n{\n    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    float scalar;\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(surfaceData.worldNormal * 0.5 + vec3(0.5), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(surfaceData.worldTangent * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(surfaceData.worldBinormal * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSPARENCY)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.baseColor.a;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_BASE_COLOR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(surfaceData.baseColor.rgb), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(CCSurfacesGetDiffuseColor(surfaceData)), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(CCSurfacesGetSpecularColor(surfaceData)), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ROUGHNESS)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.roughness;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_METALLIC)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.metallic;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.specularIntensity;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_IOR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.ior - 1.0;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n}\n#endif\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD && !CC_ENABLE_CLUSTERED_LIGHT_CULLING\n    void CCSurfacesLighting(inout LightingResult lightingResultAccumulated, in SurfacesMaterialData surfaceData, in vec2 shadowBias)\n    {\n      vec3 worldPos;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n      #else\n      worldPos = surfaceData.worldPos;\n      #endif\n      CCSurfacesInitializeLightingResult(lightingResultAccumulated);\n      LightingIntermediateData lightingData;\n      CCSurfacesInitializeLightingIntermediateData(lightingData, surfaceData);\n      LightingResult lightingResult;\n      CCSurfacesLightingInitializeColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, surfaceData, lightingData);\n      lightingResultAccumulated.diffuseColorWithLighting = lightingResult.diffuseColorWithLighting;\n      lightingResultAccumulated.specularColorWithLighting = lightingResult.specularColorWithLighting;\n      #if CC_SURFACES_LIGHTING_TRT\n        vec3 diff;\n        SurfacesMaterialData surfaceDataTRT;\n        CCSurfacesGetSurfacesMaterialDataTRT(surfaceDataTRT, surfaceData);\n        CCSurfacesLightingInitializeColorWithLighting(diff, lightingResultAccumulated.specularColorWithLightingTRT, surfaceDataTRT, lightingData);\n      #endif\n      int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n      for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n        if (i >= numLights) break;\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData, surfaceData, cc_lightPos[i].xyz - worldPos);\n        CCSurfacesLightingCalculateColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, surfaceData, lightingData);\n        vec3 diffuseLighting, specularLighting;\n        CCSurfacesLightingCalculateDirect(diffuseLighting, specularLighting, lightingData, cc_lightColor[i]);\n        float fresnel = 1.0;\n      #if CC_SURFACES_LIGHTING_USE_FRESNEL\n        fresnel = lightingResult.fresnel = CCSurfaceLightingCalculateFresnel(lightingData);\n      #endif\n        float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          vec4 shadowPos = vec4(0.0), shadowNDCPosWithBias = vec4(0.0);\n          if (CCSurfacesLightingEnableShadow(lightingData.NoL)) {\n            shadowPos = cc_matLightViewProj * vec4(surfaceData.worldPos, 1.0);\n            shadow = CCSpotShadowFactorBase(shadowNDCPosWithBias, shadowPos, worldPos, shadowBias);\n          }\n          #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n            #if CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n              lightingData.shadowPosAndDepth.xy = shadowNDCPosWithBias.xy;\n              lightingData.shadowPosAndDepth.z = shadowPos.z;\n              lightingData.shadowPosAndDepth.w = GetViewSpaceDepthFromNDCDepth_Perspective(SampleShadowMap(shadowNDCPosWithBias.xyz, cc_spotShadowMap), shadowNDCPosWithBias.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n            #else\n              lightingData.transmitDiffuseParams.zw = vec2(0.0);\n            #endif\n          #endif\n        }\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW) {\n          shadow = 1.0;\n        }\n      #endif\n        lightingResult.shadow = shadow;\n        float distAtt = CCSurfacesLightingCalculateDistanceAttenuation(lightingData, cc_lightSizeRangeAngle[i]);\n        float angleAtt = 1.0;\n        if (cc_lightPos[i].w > 0.0) {\n          angleAtt = CCSurfacesLightingCalculateAngleAttenuation(lightingData, cc_lightSizeRangeAngle[i], -cc_lightDir[i].xyz);\n        }\n        float multiplier = distAtt * angleAtt;\n        lightingResult.directDiffuse = diffuseLighting * multiplier;\n        lightingResult.directSpecular = specularLighting * multiplier * fresnel;\n        #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n          vec3 transmitSpecularLighting;\n          CCSurfacesLightingCalculateDirectTransmitSpecular(transmitSpecularLighting, lightingData, cc_lightColor[i]);\n          lightingResult.directTransmitSpecular = transmitSpecularLighting * multiplier * (1.0 - fresnel);\n        #endif\n        #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n          lightingResult.directTransmitDiffuse = CCSurfacesLightingCalculateDirectTransmitDiffuse(lightingResult, lightingData, cc_lightColor[i]);\n        #endif\n        #if CC_SURFACES_LIGHTING_TRT\n          LightingIntermediateData lightingDataTRT;\n          CCSurfacesGetLightingIntermediateDataTRT(lightingDataTRT, lightingData, surfaceData);\n          CCSurfacesLightingCalculateDirectTRT(lightingResult.directTRT, lightingDataTRT, cc_lightColor[i]);\n          lightingResult.directTRT *= multiplier * fresnel;\n        #endif\n        #if CC_SURFACES_LIGHTING_TT\n          CCSurfacesLightingCalculateDirectTT(lightingResult, lightingData, cc_lightColor[i]);\n        #endif\n        #ifdef CC_SURFACES_LIGHTING_MODIFY_FINAL_RESULT\n          LightingMiscData miscData;\n          miscData.lightType = cc_lightPos[i].w;\n          miscData.lightPos = cc_lightPos[i].xyz;\n          miscData.lightDir = cc_lightDir[i].xyz;\n          miscData.lightColorAndIntensity = cc_lightColor[i];\n          miscData.lightSizeRangeAngle = cc_lightSizeRangeAngle[i];\n          SurfacesLightingModifyFinalResult(lightingResult, lightingData, surfaceData, miscData);\n        #endif\n        CCSurfacesAccumulateLightingResult(lightingResultAccumulated, lightingResult);\n      }\n    }\n  #else\n    void CCSurfacesLighting(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData, in vec2 shadowBias)\n    {\n      LightingIntermediateData lightingData;\n      CCSurfacesInitializeLightingIntermediateData(lightingData, surfaceData);\n      CCSurfacesInitializeLightingResult(lightingResult, surfaceData);\n      CCSurfacesLightingInitializeColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, surfaceData, lightingData);\n      CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData, surfaceData, -cc_mainLitDir.xyz);\n      lightingResult.shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (cc_mainLitDir.w > 0.0) {\n          vec4 shadowPos = vec4(0.0), shadowNDCPosWithBias = vec4(0.0);\n          if (CCSurfacesLightingEnableShadow(lightingData.NoL)) {\n            #if CC_DIR_LIGHT_SHADOW_TYPE == 2\n              lightingResult.shadow = CCCSMFactorBase(shadowPos, shadowNDCPosWithBias, surfaceData.worldPos, lightingData.N, shadowBias);\n            #endif\n            #if CC_DIR_LIGHT_SHADOW_TYPE == 1\n              shadowPos = cc_matLightViewProj * vec4(surfaceData.worldPos, 1.0);\n              lightingResult.shadow = CCShadowFactorBase(shadowPos, lightingData.N, shadowBias);\n            #endif\n          }\n          #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n            #if CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n              lightingData.shadowPosAndDepth.xy = shadowNDCPosWithBias.xy;\n              lightingData.shadowPosAndDepth.z = shadowPos.z;\n              lightingData.shadowPosAndDepth.w = GetViewSpaceDepthFromNDCDepth_Orthgraphic(SampleShadowMap(shadowNDCPosWithBias.xyz, cc_shadowMap), cc_shadowProjDepthInfo.x, cc_shadowProjDepthInfo.y);\n            #else\n              lightingData.transmitDiffuseParams.zw = vec2(0.0);\n            #endif\n          #endif\n        }\n      #endif\n      lightingResult.lightmapColor = vec3(0.0);\n      #if CC_SURFACES_USE_LIGHT_MAP && !CC_FORWARD_ADD\n\t\t    float lightmapShadow, lightmapAO;\n        GetLightMapColor(lightingResult.lightmapColor, lightmapShadow, lightmapAO, cc_lightingMap, FSInput_lightMapUV.xy, FSInput_lightMapUV.z, surfaceData.worldNormal);\n        #if CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_INDIRECT_OCCLUSION\n          lightingResult.shadow *= lightmapShadow;\n          lightingResult.ao *= lightmapAO;\n        #endif\n      #endif\n      lightingResult.directDiffuse = lightingResult.directSpecular = vec3(0.0);\n      #if !CC_DISABLE_DIRECTIONAL_LIGHT && !CC_FORWARD_ADD\n        CCSurfacesLightingCalculateColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, surfaceData, lightingData);\n        CCSurfacesLightingCalculateDirect(lightingResult.directDiffuse, lightingResult.directSpecular, lightingData, cc_mainLitColor);\n      #endif\n      CCSurfacesLightingCalculateEnvironment(lightingResult.environmentDiffuse, lightingResult.environmentSpecular, lightingData, cc_ambientSky.w);\n      #if CC_SURFACES_LIGHTING_USE_FRESNEL\n        lightingResult.fresnel = CCSurfaceLightingCalculateFresnel(lightingData);\n      #endif\n      #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n        CCSurfacesLightingCalculateDirectTransmitSpecular(lightingResult.directTransmitSpecular, lightingData, cc_mainLitColor);\n        CCSurfacesLightingCalculateEnvironmentTransmitSpecular(lightingResult.environmentTransmitSpecular, lightingData, cc_ambientSky.w);\n      #endif\n      #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n        CCSurfacesLightingCalculateDirectTransmitDiffuse(lightingResult.directTransmitDiffuse, lightingResult, lightingData, cc_mainLitColor);\n        CCSurfacesLightingCalculateEnvironmentTransmitDiffuse(lightingResult.environmentTransmitDiffuse, lightingResult, lightingData, cc_ambientSky.w);\n      #endif\n      #if CC_SURFACES_LIGHTING_TRT\n        LightingIntermediateData lightingDataTRT;\n        CCSurfacesGetLightingIntermediateDataTRT(lightingDataTRT, lightingData, surfaceData);\n        CCSurfacesLightingCalculateDirectTRT(lightingResult.directTRT, lightingDataTRT, cc_mainLitColor);\n        CCSurfacesLightingCalculateEnvironmentTRT(lightingResult.environmentTRT, lightingDataTRT, cc_ambientSky.w);\n        vec3 diff;\n        SurfacesMaterialData surfaceDataTRT;\n        CCSurfacesGetSurfacesMaterialDataTRT(surfaceDataTRT, surfaceData);\n        CCSurfacesLightingInitializeColorWithLighting(diff, lightingResult.specularColorWithLightingTRT, surfaceDataTRT, lightingDataTRT);\n      #endif\n      #if CC_SURFACES_LIGHTING_TT\n        CCSurfacesLightingCalculateDirectTT(lightingResult, lightingData, cc_mainLitColor);\n      #endif\n      #ifdef CC_SURFACES_LIGHTING_MODIFY_FINAL_RESULT\n        LightingMiscData miscData;\n        miscData.lightType = LIGHT_TYPE_DIRECTIONAL;\n        miscData.lightPos = vec3(0.0);\n        miscData.lightDir = cc_mainLitDir.xyz;\n        miscData.lightColorAndIntensity = cc_mainLitColor;\n        miscData.lightSizeRangeAngle = vec4(0.0, 0.0, 0.0, 0.0);\n        SurfacesLightingModifyFinalResult(lightingResult, lightingData, surfaceData, miscData);\n      #endif\n    }\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING\n    #endif\n  #endif\n#endif\nvec4 CCSurfacesDebugDisplayInvalidNumber(vec4 color)\n{\n  float index = mod(cc_time.x * 10.0, 2.0);\n  vec4 error = index < 1.0 ? vec4(1.0, 0.0, 0.2, 1.0) : vec4(0.0, 1.0, 0.2, 1.0);\n  return (isnans(color.rgb) || isinfs(color.rgb)) ? error : color;\n}\nvec4 CCSurfacesDebugDisplayInvalidInputData(vec4 color, vec3 data)\n{\n  float index = mod(cc_time.x * 10.0, 2.0);\n  vec4 error = index < 1.0 ? vec4(1.0, 0.0, 0.2, 1.0) : vec4(0.0, 1.0, 0.2, 1.0);\n  return (isnans(data) || isinfs(data)) ? error : color;\n}\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && !CC_FORWARD_ADD\n  void CCSurfacesDebugViewMeshData(inout vec4 color)\n  {\n    vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_VERTEX_COLOR\n        color = FSInput_vertexColor;\n      #else\n        color = white;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(FSInput_worldNormal * 0.5 + vec3(0.5), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(FSInput_worldTangent * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        float sign = FSInput_mirrorNormal * 0.5 + 0.5;\n        color = vec4(sign, sign, sign, 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FACE_SIDE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        float scalar = clamp(FSInput_faceSideSign, 0.0, 1.0);\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_UV0)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(FSInput_texcoord.xy, 0.0, 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_UV1)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n      color = vec4(FSInput_texcoord1.xy, 0.0, 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n        color = vec4(FSInput_lightMapUV.xy, 0.0, 1.0);\n      #else\n        color = vec4(0.0, 0.0, 0.0, 1.0);\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      vec4 clipPos = cc_matProj * cc_matView * vec4(FSInput_worldPos.xyz, 1.0);\n      float depth = clipPos.z / clipPos.w;\n      color = vec4(depth, depth, depth, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      vec4 viewPos = cc_matView * vec4(FSInput_worldPos.xyz, 1.0);\n      float depth = (-viewPos.z - cc_nearFar.x) / cc_nearFar.y;\n      color = vec4(depth, depth, depth, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_WORLD_POS)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n      color = vec4(FSInput_worldPos.xyz, 1.0);\n  }\n#endif\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE\n  bool CCSurfacesDebugViewLightingResult(inout vec4 color, in LightingResult lightingResult)\n  {\n    bool isSRGBColor = false;\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directSpecular * lightingResult.specularColorWithLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_ALL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting + lightingResult.directSpecular * lightingResult.specularColorWithLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentSpecular * lightingResult.specularColorWithLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ENV_ALL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting + lightingResult.environmentSpecular * lightingResult.specularColorWithLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_LIGHT_MAP)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.lightmapColor;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_EMISSIVE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.emissive;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_AO)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(lightingResult.ao);\n        isSRGBColor = false;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_SHADOW)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(lightingResult.shadow);\n        isSRGBColor = false;\n    }\n    float fresnel = 0.0;\n    vec3 directTransmitSpecular = vec3(0.0), environmentTransmitSpecular = vec3(0.0);\n    vec3 directTransmitDiffuse = vec3(0.0), environmentTransmitDiffuse = vec3(0.0);\n    vec3 diffuseColorWithLightingTT = vec3(0.0), specularColorWithLightingTRT = vec3(0.0);\n    vec3 directTRT = vec3(0.0), environmentTRT = vec3(0.0);\n  #if CC_SURFACES_LIGHTING_USE_FRESNEL\n    fresnel = lightingResult.fresnel;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    directTransmitSpecular = lightingResult.directTransmitSpecular;\n    environmentTransmitSpecular = lightingResult.environmentTransmitSpecular;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    directTransmitDiffuse = lightingResult.directTransmitDiffuse;\n    environmentTransmitDiffuse = lightingResult.environmentTransmitDiffuse;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRT\n    directTRT = lightingResult.directTRT;\n    environmentTRT = lightingResult.environmentTRT;\n    specularColorWithLightingTRT = lightingResult.specularColorWithLightingTRT;\n  #endif\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRESNEL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(fresnel);\n        isSRGBColor = false;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = directTransmitSpecular;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = environmentTransmitSpecular;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = directTransmitDiffuse;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = environmentTransmitDiffuse;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = directTransmitSpecular + environmentTransmitSpecular + directTransmitDiffuse + environmentTransmitDiffuse;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRT_DIRECT)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = directTRT * specularColorWithLightingTRT;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRT_ENVIRONMENT)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = environmentTRT * specularColorWithLightingTRT;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRT_ALL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = (directTRT + environmentTRT) * specularColorWithLightingTRT;\n        isSRGBColor = true;\n    }\n    return isSRGBColor;\n  }\n#endif\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  void CCSurfacesDebugViewCompositeLightingResult(inout LightingResult lightingResult)\n  {\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE)\n      lightingResult.directDiffuse = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR)\n      lightingResult.directSpecular = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE)\n      lightingResult.environmentDiffuse = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR)\n      lightingResult.environmentSpecular = vec3(0.0);\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE)\n      lightingResult.directTransmitDiffuse = lightingResult.environmentTransmitDiffuse = vec3(0.0);\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR)\n      lightingResult.directTransmitSpecular = lightingResult.environmentTransmitSpecular = vec3(0.0);\n  #endif\n  #if CC_SURFACES_LIGHTING_TRT\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRT)\n        lightingResult.directTRT = lightingResult.environmentTRT = vec3(0.0);\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT)\n        lightingResult.directTT = vec3(0.0);\n  #endif\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE)\n      lightingResult.emissive = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP)\n      lightingResult.lightmapColor = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW)\n      lightingResult.shadow = 1.0;\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO)\n      lightingResult.ao = 1.0;\n  #if CC_SURFACES_LIGHTING_USE_FRESNEL\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL)\n      lightingResult.fresnel = 1.0;\n  #endif\n  }\n#endif\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  void main()  {\n  #if CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER\n    float NoL = dot(-cc_mainLitDir.xyz, FSInput_worldNormal.xyz);\n    vec4 color = SurfacesFragmentModifyBaseColorAndTransparency();\n  #else\n    SurfacesMaterialData surfaceData;\n    CCSurfacesFragmentGetMaterialData(surfaceData);\n    vec2 shadowBias = vec2(0.0);\n    vec3 colDebugCSMLayer = vec3(1.0);\n    #if CC_RECEIVE_SHADOW\n      shadowBias = FSInput_shadowBias;\n      #if !CC_FORWARD_ADD\n        #if CC_USE_DEBUG_VIEW && CC_SURFACES_ENABLE_DEBUG_VIEW\n          if (IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION)\n          {\n              vec4 csmPos;\n              vec4 shadowProjDepthInfo, shadowProjInfo;\n              vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n              int csmLayer = -1;\n              csmLayer = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, surfaceData.worldPos);\n              bool OutOfRange = csmLayer < 0;\n              if (OutOfRange)\n                  colDebugCSMLayer = vec3(1.0);\n              else if (csmLayer == 0)\n                  colDebugCSMLayer = vec3(1.0, 0.0, 0.0);\n              else if (csmLayer == 1)\n                  colDebugCSMLayer = vec3(0.0, 1.0, 0.0);\n              else if (csmLayer == 2)\n                  colDebugCSMLayer = vec3(0.0, 0.0, 1.0);\n              else if (csmLayer == 3)\n                  colDebugCSMLayer = vec3(0.0, 1.0, 1.0);\n          }\n        #endif\n      #endif\n    #endif\n    #if !CC_FORWARD_ADD\n      float fogFactor = 1.0;\n      #if CC_USE_FOG != 4\n        #if !CC_USE_ACCURATE_FOG\n          fogFactor = FSInput_fogFactor;\n        #else\n          CC_TRANSFER_FOG_BASE(vec4(FSInput_worldPos, 1.0), fogFactor);\n        #endif\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG) {\n            fogFactor = 1.0;\n        }\n      #endif\n    #endif\n    LightingResult lightingResult;\n    CCSurfacesLighting(lightingResult, surfaceData, shadowBias);\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && CC_SURFACES_ENABLE_DEBUG_VIEW\n      vec4 debugColor = vec4(0.0, 0.0, 0.0, 1.0);\n      float materialTransparency = CCSurfacesShading(surfaceData, lightingResult).a;\n      #if !CC_FORWARD_ADD\n        CCSurfacesDebugViewMeshData(debugColor);\n        CCSurfacesDebugViewSurfaceData(debugColor, surfaceData);\n        if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FOG)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        {\n          debugColor.rgb = vec3(1.0 - fogFactor);\n        }\n      #endif\n      #if CC_FORWARD_ADD\n        if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)) || ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)) || ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_ALL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n      #endif\n        {\n            if (CCSurfacesDebugViewLightingResult(debugColor, lightingResult))\n            {\n              debugColor.a = materialTransparency;\n              #if CC_USE_HDR\n                if (IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING)\n                    debugColor.rgb = ACESToneMap(debugColor.rgb);\n              #endif\n              if (IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION)\n                  debugColor.rgb = LinearToSRGB(debugColor.rgb);\n            }\n        }\n      if (IS_DEBUG_VIEW_ENABLE_WITH_CAMERA) {\n        gl_FragData[0] = debugColor;\n        return;\n      }\n    #elif CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n      CCSurfacesDebugViewCompositeLightingResult(lightingResult);\n    #endif\n    vec4 color = CCSurfacesShading(surfaceData, lightingResult);\n    #if CC_USE_DEBUG_VIEW && CC_SURFACES_ENABLE_DEBUG_VIEW\n      if (IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION) {\n          color.rgb *= colDebugCSMLayer.rgb;\n      }\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = CCSurfacesDebugDisplayInvalidInputData(color, FSInput_worldTangent);\n      #endif\n    #endif\n  #endif\n    #if CC_USE_RGBE_OUTPUT\n      gl_FragData[0] = packRGBE(color.rgb);\n      return;\n    #endif\n    #if CC_USE_HDR\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n        if (IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING)\n      #endif\n        color.rgb = ACESToneMap(color.rgb);\n    #endif\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n      if (IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION)\n    #endif\n    color.rgb = LinearToSRGB(color.rgb);\n    #if !CC_FORWARD_ADD && CC_USE_FOG != 4\n      CC_APPLY_FOG_BASE(color, fogFactor);\n    #endif\n    gl_FragData[0] = CCSurfacesDebugDisplayInvalidNumber(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n    void main () {\n      SurfacesMaterialData surfaceData;\n      CCSurfacesFragmentGetMaterialData(surfaceData);\n      gl_FragData[0] = CCSurfacesDeferredOutput0(surfaceData);\n      gl_FragData[1] = CCSurfacesDeferredOutput1(surfaceData);\n      gl_FragData[2] = CCSurfacesDeferredOutput2(surfaceData);\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && CC_SURFACES_ENABLE_DEBUG_VIEW\n      vec4 debugColor = vec4(0.0, 0.0, 0.0, 1.0);\n      CCSurfacesDebugViewMeshData(debugColor);\n      CCSurfacesDebugViewSurfaceData(debugColor, surfaceData);\n      if (IS_DEBUG_VIEW_ENABLE_WITH_CAMERA) {\n        gl_FragData[0] = debugColor;\n      }\n    #endif\n    }\n#endif"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]},{"name":"CCCSM","defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_environment","defines":[]},{"name":"cc_diffuseMap","defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]},{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":["!USE_INSTANCING"]},{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CCSH","defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeDataMap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":99,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":129}},"defines":[{"name":"HAS_SECOND_UV","type":"boolean"},{"name":"USE_TWOSIDE","type":"boolean"},{"name":"USE_REFLECTION_DENOISE","type":"boolean"},{"name":"IS_ANISOTROPY","type":"boolean"},{"name":"USE_VERTEX_COLOR","type":"boolean"},{"name":"USE_COMPATIBLE_LIGHTING","type":"boolean"},{"name":"USE_INSTANCING","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"boolean"},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_LIGHT_PROBE","type":"boolean","default":0},{"name":"CC_USE_MORPH","type":"boolean"},{"name":"CC_FORWARD_ADD","type":"boolean"},{"name":"CC_USE_FOG","type":"number","range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean"},{"name":"CC_USE_REFLECTION_PROBE","type":"number","range":[0,3]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","range":[2,8]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean"},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean"},{"name":"CC_USE_REAL_TIME_JOINT_TEXTURE","type":"boolean"},{"name":"CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER","type":"number","range":[0,1]},{"name":"CC_PIPELINE_TYPE","type":"number","range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean"},{"name":"CC_SUPPORT_CASCADED_SHADOW_MAP","type":"boolean"},{"name":"CC_USE_IBL","type":"number","range":[0,2]},{"name":"CC_USE_DIFFUSEMAP","type":"number","range":[0,2]},{"name":"CC_USE_DEBUG_VIEW","type":"number","range":[0,3]},{"name":"CC_IBL_CONVOLUTED","type":"boolean"},{"name":"CC_SHADOWMAP_FORMAT","type":"number","range":[0,3]},{"name":"CC_SHADOWMAP_USE_LINEAR_DEPTH","type":"boolean"},{"name":"CC_DIR_SHADOW_PCF_TYPE","type":"number","range":[0,3]},{"name":"CC_CASCADED_LAYERS_TRANSITION","type":"boolean"},{"name":"CC_USE_HDR","type":"boolean"},{"name":"CC_LIGHT_MAP_VERSION","type":"number","range":[0,3]},{"name":"TEXTURE_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"USE_ALBEDO_MAP","type":"boolean"},{"name":"USE_WEIGHT_MAP","type":"boolean"},{"name":"USE_METALLIC_MAP","type":"boolean"},{"name":"METALLIC_CHANNEL","type":"string","options":["r","g","b","a"]},{"name":"USE_ROUGHNESS_MAP","type":"boolean"},{"name":"ROUGHNESS_CHANNEL","type":"string","options":["r","g","b","a"]},{"name":"USE_OCCLUSION_MAP","type":"boolean"},{"name":"OCCLUSION_CHANNEL","type":"string","options":["r","g","b","a"]},{"name":"USE_TRANSPARENCY_MAP","type":"boolean"},{"name":"USE_TRANSPARENCYCOLOR_MAP","type":"boolean"},{"name":"USE_EMISSIVE_MAP","type":"boolean"},{"name":"USE_EMISSIVESCALE_MAP","type":"boolean"},{"name":"USE_OPACITY_MAP","type":"boolean"},{"name":"ALPHA_SOURCE_CHANNEL","type":"string","options":["r","g","b","a"]},{"name":"USE_NORMAL_MAP","type":"boolean"},{"name":"NORMAL_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"ALPHA_SOURCE_IS_OPACITY","type":"boolean"},{"name":"USE_ALPHA_TEST","type":"boolean"},{"name":"USE_OCCLUSION_CHANNEL","type":"boolean"},{"name":"USE_ROUGHNESS_CHANNEL","type":"boolean"},{"name":"USE_METALLIC_CHANNEL","type":"boolean"},{"name":"CC_SHADOW_TYPE","type":"number","range":[0,3]},{"name":"CC_DIR_LIGHT_SHADOW_TYPE","type":"number","range":[0,3]},{"name":"CC_DISABLE_DIRECTIONAL_LIGHT","type":"boolean"},{"name":"CC_USE_RGBE_OUTPUT","type":"boolean"}]},{"hash":2655333790,"name":"util/dcc/imported-metallic-roughness|shadow-caster-vs|shadow-caster-fs","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScale","type":13,"count":1},{"name":"occlusion","type":13,"count":1},{"name":"roughness","type":13,"count":1},{"name":"metallic","type":13,"count":1},{"name":"normalStrength","type":13,"count":1},{"name":"alphaSource","type":13,"count":1},{"name":"albedoScale","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]},{"name":"baseWeightMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_WEIGHT_MAP"]},{"name":"metallicMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_METALLIC_MAP"]},{"name":"roughnessMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_ROUGHNESS_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_OCCLUSION_MAP"]},{"name":"transparencyMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_TRANSPARENCY_MAP"]},{"name":"transparencyColorMap","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["USE_TRANSPARENCYCOLOR_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":8,"defines":["USE_EMISSIVE_MAP"]},{"name":"emissiveScaleMap","type":28,"count":1,"stageFlags":16,"binding":9,"defines":["USE_EMISSIVESCALE_MAP"]},{"name":"alphaSourceMap","type":28,"count":1,"stageFlags":16,"binding":10,"defines":["USE_OPACITY_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":11,"defines":["USE_NORMAL_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_color","format":44,"location":6,"defines":[]},{"name":"a_texCoord1","format":21,"location":7,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":12,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBiasAndProbeId","format":44,"isInstanced":true,"location":13,"defines":["USE_INSTANCING"]},{"name":"a_sh_linear_const_r","format":44,"isInstanced":true,"location":14,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_g","format":44,"isInstanced":true,"location":15,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_b","format":44,"isInstanced":true,"location":16,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_vertexId","format":11,"location":17,"defines":["CC_USE_MORPH"]}],"fragColors":[{"name":"fragColorX","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"descriptors":[{"rate":0,"blocks":[{"name":"CCLocal","stageFlags":17,"tags":{"builtin":"local"},"members":[{"name":"cc_matWorld","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matWorldIT","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_lightingMapUVParam","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_localShadowBias","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData2","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["!USE_INSTANCING"]},{"name":"CCMorph","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_displacementWeights","typename":"vec4","type":16,"count":15,"isArray":true},{"name":"cc_displacementTextureInfo","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointTextureInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointAnimInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_joints","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true}],"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCForwardLight","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_lightPos","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true},{"name":"cc_lightColor","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightSizeRangeAngle","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightDir","typename":"vec4","type":16,"count":0,"isArray":true}],"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CCSH","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_sh_linear_const_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_a","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeDataMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":1,"blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScale","type":13,"count":1},{"name":"occlusion","type":13,"count":1},{"name":"roughness","type":13,"count":1},{"name":"metallic","type":13,"count":1},{"name":"normalStrength","type":13,"count":1},{"name":"alphaSource","type":13,"count":1},{"name":"albedoScale","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]},{"name":"baseWeightMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_WEIGHT_MAP"]},{"name":"metallicMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_METALLIC_MAP"]},{"name":"roughnessMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_ROUGHNESS_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_OCCLUSION_MAP"]},{"name":"transparencyMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_TRANSPARENCY_MAP"]},{"name":"transparencyColorMap","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["USE_TRANSPARENCYCOLOR_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":8,"defines":["USE_EMISSIVE_MAP"]},{"name":"emissiveScaleMap","type":28,"count":1,"stageFlags":16,"binding":9,"defines":["USE_EMISSIVESCALE_MAP"]},{"name":"alphaSourceMap","type":28,"count":1,"stageFlags":16,"binding":10,"defines":["USE_OPACITY_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":11,"defines":["USE_NORMAL_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":2,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":3,"blocks":[{"name":"CCGlobal","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_time","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_screenSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nativeSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_probeInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_mode","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCamera","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_cameraPos","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_surfaceTransform","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_screenScale","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_exposure","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitDir","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientSky","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientGround","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogBase","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogAdd","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nearFar","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_viewPort","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCShadow","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matLightView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matLightViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_shadowInvProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowNFLSInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowWHPBInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowLPNNInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowColor","typename":"vec4","type":16,"count":1,"precision":"lowp "},{"name":"cc_planarNDInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCSM","stageFlags":16,"tags":{"builtin":"global"},"members":[{"name":"cc_csmViewDir0","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir1","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir2","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmAtlas","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_matCSMViewProj","typename":"mat4","type":25,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjDepthInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmSplitsInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_environment","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"global"},"defines":[]},{"name":"cc_diffuseMap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]},{"name":"cc_shadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]}],"glsl1":{"vert":"\nprecision highp float;\n#define CC_SURFACES_USE_TANGENT_SPACE 0\n#define CC_SURFACES_USE_VERTEX_COLOR 0\n#define CC_SURFACES_USE_SECOND_UV 0\n#define CC_SURFACES_USE_LIGHT_MAP 0\n#define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#ifndef CC_SURFACES_LIGHTING_CALCULATE_DIFFUSE\n  #define CC_SURFACES_LIGHTING_CALCULATE_DIFFUSE 1\n#endif\n#ifndef CC_SURFACES_LIGHTING_CALCULATE_SPECULAR\n  #define CC_SURFACES_LIGHTING_CALCULATE_SPECULAR 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  attribute vec4 a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  attribute vec4 a_color;\n#endif\n#if CC_SURFACES_USE_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    attribute vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    attribute vec4 a_sh_linear_const_r;\n    attribute vec4 a_sh_linear_const_g;\n    attribute vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n#endif\nvarying highp vec3 v_worldPos;\nvarying mediump vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  varying mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  varying highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define VSOutput_worldPos v_worldPos\n#define VSOutput_worldNormal v_normal.xyz\n#define VSOutput_faceSideSign v_normal.w\n#define VSOutput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define VSOutput_vertexColor v_color\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define VSOutput_worldTangent v_tangent.xyz\n  #define VSOutput_mirrorNormal v_tangent.w\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define VSOutput_texcoord1 v_uv1\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define VSOutput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define VSOutput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define VSOutput_reflectionProbeId v_shadowBiasAndProbeId.z\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define VSOutput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define VSOutput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define VSOutput_clipPos v_clipPos\n#endif\nstruct SurfacesStandardVertexIntermediate\n{\n  highp vec4 position;\n  vec3 normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  vec4 color;\n#endif\n  vec2 texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  vec2 texCoord1;\n#endif\n  highp vec4 clipPos;\n  highp vec3 worldPos;\n  vec4 worldNormal;\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 worldTangent, worldBinormal;\n  #endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  vec4 shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  float fogFactor;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  vec3 lightmapUV;\n#endif\n};\n#if CC_USE_MORPH\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matLightViewProj;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_POINT 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_SPHERE 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if !USE_INSTANCING\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #if CC_USE_FOG != 4\n  #endif\n#endif\n    uniform vec4 tilingOffset;\n#define CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord * tilingOffset.xy + tilingOffset.zw;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = In.texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\n}\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_POS\nvec3 SurfacesVertexModifyLocalPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.position.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_NORMAL\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_TANGENT\n  #if CC_SURFACES_USE_TANGENT_SPACE\n  #endif\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_SHARED_DATA\nvoid SurfacesVertexModifyLocalSharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_POS\nvec3 SurfacesVertexModifyWorldPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.worldPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_CLIP_POS\nvec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.clipPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_NORMAL\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHARED_DATA\nvoid SurfacesVertexModifySharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\nvoid CCSurfacesVertexInput(out SurfacesStandardVertexIntermediate In)\n{\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  In.tangent = a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  In.color = a_color;\n#endif\n  In.texCoord = a_texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = a_texCoord1;\n#endif\n}\nvoid CCSurfacesVertexOutput(in SurfacesStandardVertexIntermediate In)\n{\n  gl_Position = In.clipPos;\n  VSOutput_worldNormal = In.worldNormal.xyz;\n  VSOutput_faceSideSign = In.worldNormal.w;\n  VSOutput_worldPos = In.worldPos;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  VSOutput_worldTangent = In.worldTangent.xyz;\n  VSOutput_mirrorNormal = In.tangent.w > 0.0 ? 1.0 : -1.0;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  VSOutput_vertexColor = In.color;\n#endif\n  VSOutput_texcoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  VSOutput_texcoord1 = In.texCoord1;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  VSOutput_fogFactor = In.fogFactor;\n#endif\n#if CC_RECEIVE_SHADOW\n  VSOutput_shadowBias = In.shadowBiasAndProbeId.xy;\n#endif\n#if CC_USE_REFLECTION_PROBE\n  VSOutput_reflectionProbeId = In.shadowBiasAndProbeId.z;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  VSOutput_lightMapUV = In.lightmapUV;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  VSOutput_localPos = In.position;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  VSOutput_clipPos = In.clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    v_sh_linear_const_r = a_sh_linear_const_r;\n    v_sh_linear_const_g = a_sh_linear_const_g;\n    v_sh_linear_const_b = a_sh_linear_const_b;\n  #endif\n#endif\n}\nvoid CCSurfacesVertexAnimation(inout SurfacesStandardVertexIntermediate In)\n{\nvec4 temp = vec4(0.0);\n#if CC_USE_MORPH\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    applyMorph(In.position, In.normal, In.tangent);\n  #else\n    applyMorph(In.position, In.normal, temp);\n  #endif\n#endif\n#if CC_USE_SKINNING\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    CCSkin(In.position, In.normal, In.tangent);\n  #else\n    CCSkin(In.position, In.normal, temp);\n  #endif\n#endif\n}\nvoid CCSurfacesVertexWorldTransform(inout SurfacesStandardVertexIntermediate In)\n{\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    In.worldPos = (matWorld * In.position).xyz;\n    In.worldNormal.xyz = normalize((matWorldIT * vec4(In.normal.xyz, 0.0)).xyz);\n    #if CC_SURFACES_USE_TANGENT_SPACE\n      In.worldTangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      In.worldBinormal = cross(In.worldNormal.xyz, In.worldTangent) * In.tangent.w;\n    #endif\n}\nvoid CCSurfacesVertexTransformUV(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_SURFACES_FLIP_UV\n    In.texCoord = cc_cameraPos.w > 1.0 ? vec2(In.texCoord.x, 1.0 - In.texCoord.y) : In.texCoord;\n    #if CC_SURFACES_USE_SECOND_UV\n      In.texCoord1 = cc_cameraPos.w > 1.0 ? vec2(In.texCoord1.x, 1.0 - In.texCoord1.y) : In.texCoord1;\n    #endif\n  #endif\n}\nvarying highp vec2 v_clip_depth;\nvoid main()\n{\n  SurfacesStandardVertexIntermediate In;\n  CCSurfacesVertexInput(In);\n  CCSurfacesVertexAnimation(In);\n  In.position.xyz = SurfacesVertexModifyLocalPos(In);\n  SurfacesVertexModifyLocalSharedData(In);\n  CCSurfacesVertexWorldTransform(In);\n  In.worldPos = SurfacesVertexModifyWorldPos(In);\n  In.clipPos = cc_matLightViewProj * vec4(In.worldPos, 1.0);\n  In.clipPos = SurfacesVertexModifyClipPos(In);\n  SurfacesVertexModifyUV(In);\n  SurfacesVertexModifySharedData(In);\n  CCSurfacesVertexTransformUV(In);\n  CCSurfacesVertexOutput(In);\n  v_clip_depth = In.clipPos.zw;\n}","frag":"\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\n#define CC_SURFACES_USE_TANGENT_SPACE 0\n#define CC_SURFACES_USE_VERTEX_COLOR 0\n#define CC_SURFACES_USE_SECOND_UV 0\n#define CC_SURFACES_USE_LIGHT_MAP 0\n#define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#ifndef CC_SURFACES_LIGHTING_CALCULATE_DIFFUSE\n  #define CC_SURFACES_LIGHTING_CALCULATE_DIFFUSE 1\n#endif\n#ifndef CC_SURFACES_LIGHTING_CALCULATE_SPECULAR\n  #define CC_SURFACES_LIGHTING_CALCULATE_SPECULAR 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nvarying highp vec3 v_worldPos;\nvarying mediump vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  varying mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  varying highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define FSInput_worldPos v_worldPos\n#define FSInput_worldNormal v_normal.xyz\n#define FSInput_faceSideSign v_normal.w\n#define FSInput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define FSInput_vertexColor v_color\n#else\n  #define FSInput_vertexColor vec4(1.0)\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define FSInput_worldTangent v_tangent.xyz\n  #define FSInput_mirrorNormal v_tangent.w\n#else\n  #define FSInput_worldTangent vec3(0.0, 0.0, 0.0)\n  #define FSInput_mirrorNormal 1.0\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define FSInput_texcoord1 v_uv1\n#else\n  #define FSInput_texcoord1 vec2(0.0, 0.0)\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define FSInput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define FSInput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define FSInput_reflectionProbeId v_shadowBiasAndProbeId.z\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define FSInput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define FSInput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define FSInput_clipPos v_clipPos\n#endif\nuniform mediump vec4 cc_debug_view_mode;\nuniform mediump vec4 cc_surfaceTransform;\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_IOR CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_IOR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FRESNEL CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_FRESNEL + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRT_DIRECT CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_TRT_ENVIRONMENT CC_SURFACES_DEBUG_VIEW_TRT_DIRECT + 1\n#define CC_SURFACES_DEBUG_VIEW_TRT_ALL CC_SURFACES_DEBUG_VIEW_TRT_ENVIRONMENT + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_TRT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#define IS_DEBUG_VIEW_ENABLE_WITH_CAMERA (cc_surfaceTransform.y != 3.0)\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (UnpackBitFromFloat(cc_debug_view_mode.w, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (UnpackBitFromFloat(cc_debug_view_mode.w, 7) && IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (UnpackBitFromFloat(cc_debug_view_mode.y, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (UnpackBitFromFloat(cc_debug_view_mode.y, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (UnpackBitFromFloat(cc_debug_view_mode.y, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (UnpackBitFromFloat(cc_debug_view_mode.y, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (UnpackBitFromFloat(cc_debug_view_mode.z, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (UnpackBitFromFloat(cc_debug_view_mode.z, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (UnpackBitFromFloat(cc_debug_view_mode.z, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (UnpackBitFromFloat(cc_debug_view_mode.z, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL (UnpackBitFromFloat(cc_debug_view_mode.z, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.z, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRT (UnpackBitFromFloat(cc_debug_view_mode.z, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT (UnpackBitFromFloat(cc_debug_view_mode.w, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    #if CC_PIPELINE_TYPE == 0\n      #define LIGHTS_PER_PASS 1\n    #else\n      #define LIGHTS_PER_PASS 10\n    #endif\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n    #endif\n  #endif\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if !USE_INSTANCING\n    #endif\n#endif\nuniform highp mat4 cc_matLightView;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #endif\nuniform samplerCube cc_environment;\n#if CC_USE_IBL\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform samplerCube cc_reflectionProbeCubemap;\n  uniform sampler2D cc_reflectionProbePlanarMap;\n  uniform sampler2D cc_reflectionProbeDataMap;\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_POINT 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_SPHERE 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n#endif\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\n#if CC_USE_FOG != 4\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if CC_USE_LIGHT_PROBE\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  uniform sampler2D cc_lightingMap;\n#endif\n    uniform vec4 albedo;\n    uniform vec4 albedoScaleAndCutoff;\n    uniform float alphaSource;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_WEIGHT_MAP\n  uniform sampler2D baseWeightMap;\n#endif\n#if USE_METALLIC_MAP\n  uniform sampler2D metallicMap;\n#endif\n#if USE_ROUGHNESS_MAP\n  uniform sampler2D roughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  uniform sampler2D transparencyMap;\n#endif\n#if USE_TRANSPARENCYCOLOR_MAP\n  uniform sampler2D transparencyColorMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_EMISSIVESCALE_MAP\n  uniform sampler2D emissiveScaleMap;\n#endif\n#if USE_OPACITY_MAP\n  uniform sampler2D alphaSourceMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#define CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\n#define CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\nvoid SurfacesFragmentAlphaClipOnly()\n{\n    #if USE_ALPHA_TEST\n      float alpha = albedo.a;\n      #if USE_ALBEDO_MAP\n        alpha = texture2D(albedoMap, TEXTURE_UV).a;\n      #endif\n      #if ALPHA_SOURCE_IS_OPACITY\n        #if USE_OPACITY_MAP\n          alpha = 1.0 - texture2D(alphaSourceMap, TEXTURE_UV).ALPHA_SOURCE_CHANNEL;\n        #else\n          alpha = 1.0 - alphaSource;\n        #endif\n      #else\n        #if USE_OPACITY_MAP\n          alpha = texture2D(alphaSourceMap, TEXTURE_UV).ALPHA_SOURCE_CHANNEL;\n        #else\n          alpha = alphaSource;\n        #endif\n      #endif\n      if (alpha < albedoScaleAndCutoff.w) discard;\n    #endif\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\n#define CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\n#define CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\nvarying highp vec2 v_clip_depth;\nvoid main () {\n  SurfacesFragmentAlphaClipOnly();\n  highp float clipDepth = v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5;\n  if(cc_shadowLPNNInfo.x > EPSILON && cc_shadowLPNNInfo.x < 1.999999) {\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      clipDepth = CCGetLinearDepth(FSInput_worldPos.xyz);\n    #endif\n  }\n  #if CC_SHADOWMAP_FORMAT == 1\n    gl_FragColor = packDepthToRGBA(clipDepth);\n  #else\n    gl_FragColor = vec4(clipDepth, 1.0, 1.0, 1.0);\n  #endif\n}"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]},{"name":"CCCSM","defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_environment","defines":[]},{"name":"cc_diffuseMap","defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]},{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":["!USE_INSTANCING"]},{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CCSH","defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeDataMap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":99,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":129}},"defines":[{"name":"USE_INSTANCING","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"boolean"},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_LIGHT_PROBE","type":"boolean","default":0},{"name":"CC_USE_MORPH","type":"boolean"},{"name":"CC_FORWARD_ADD","type":"boolean"},{"name":"CC_USE_FOG","type":"number","range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean"},{"name":"CC_USE_REFLECTION_PROBE","type":"boolean"},{"name":"CC_MORPH_TARGET_COUNT","type":"number","range":[2,8]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean"},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean"},{"name":"CC_USE_REAL_TIME_JOINT_TEXTURE","type":"boolean"},{"name":"CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER","type":"number","range":[0,1]},{"name":"CC_PIPELINE_TYPE","type":"number","range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean"},{"name":"CC_SUPPORT_CASCADED_SHADOW_MAP","type":"boolean"},{"name":"CC_USE_IBL","type":"number","range":[0,2]},{"name":"CC_USE_DIFFUSEMAP","type":"number","range":[0,2]},{"name":"TEXTURE_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"USE_ALBEDO_MAP","type":"boolean"},{"name":"USE_WEIGHT_MAP","type":"boolean"},{"name":"USE_METALLIC_MAP","type":"boolean"},{"name":"METALLIC_CHANNEL","type":"string","options":["r","g","b","a"]},{"name":"USE_ROUGHNESS_MAP","type":"boolean"},{"name":"ROUGHNESS_CHANNEL","type":"string","options":["r","g","b","a"]},{"name":"USE_OCCLUSION_MAP","type":"boolean"},{"name":"OCCLUSION_CHANNEL","type":"string","options":["r","g","b","a"]},{"name":"USE_TRANSPARENCY_MAP","type":"boolean"},{"name":"USE_TRANSPARENCYCOLOR_MAP","type":"boolean"},{"name":"USE_EMISSIVE_MAP","type":"boolean"},{"name":"USE_EMISSIVESCALE_MAP","type":"boolean"},{"name":"USE_OPACITY_MAP","type":"boolean"},{"name":"ALPHA_SOURCE_CHANNEL","type":"string","options":["r","g","b","a"]},{"name":"USE_NORMAL_MAP","type":"boolean"},{"name":"NORMAL_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"USE_ALPHA_TEST","type":"boolean"},{"name":"ALPHA_SOURCE_IS_OPACITY","type":"boolean"},{"name":"CC_SHADOWMAP_USE_LINEAR_DEPTH","type":"boolean"},{"name":"CC_SHADOWMAP_FORMAT","type":"number","range":[0,3]}]}],[{"name":"opaque","passes":[{"program":"util/dcc/imported-metallic-roughness|standard-vs|standard-fs","properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"handleInfo":["albedo",0,16]},"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"baseWeightMap":{"value":"grey","type":28},"albedoScale":{"type":13,"value":[1]},"roughness":{"type":13,"value":[1]},"roughnessMap":{"value":"grey","type":28},"metallic":{"type":13,"value":[1]},"metallicMap":{"value":"grey","type":28},"occlusion":{"type":13,"value":[0]},"occlusionMap":{"value":"white","type":28},"emissiveScale":{"type":13,"value":[1]},"emissiveScaleMap":{"value":"grey","type":28},"emissive":{"linear":true,"type":16,"value":[0,0,0,1]},"emissiveMap":{"value":"grey","type":28},"alphaSource":{"type":13,"value":[1]},"alphaSourceMap":{"value":"grey","type":28},"alphaThreshold":{"type":13,"value":[0.5],"handleInfo":["albedoScaleAndCutoff",3,13]},"normalStrength":{"type":13,"value":[1]},"normalMap":{"value":"normal","type":28},"albedo":{"type":16,"value":[1,1,1,1]},"albedoMap":{"type":28,"value":"grey"},"albedoScaleAndCutoff":{"type":16,"value":[0,0,0,0.5]}}},{"phase":"forward-add","propertyIndex":0,"program":"util/dcc/imported-metallic-roughness|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"util/dcc/imported-metallic-roughness|shadow-caster-vs|shadow-caster-fs","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"handleInfo":["albedoScaleAndCutoff",3,13]},"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"alphaSource":{"type":13,"value":[1]},"alphaSourceMap":{"value":"grey","type":28},"albedo":{"type":16,"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"value":[1,1,1,0.5]},"albedoMap":{"type":28,"value":"grey"}}}]},{"name":"transparent","passes":[{"program":"util/dcc/imported-metallic-roughness|standard-vs|standard-fs","embeddedMacros":{"CC_FORCE_FORWARD_SHADING":true},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"handleInfo":["albedo",0,16]},"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"baseWeightMap":{"value":"grey","type":28},"albedoScale":{"type":13,"value":[1]},"roughness":{"type":13,"value":[1]},"roughnessMap":{"value":"grey","type":28},"metallic":{"type":13,"value":[1]},"metallicMap":{"value":"grey","type":28},"occlusion":{"type":13,"value":[0]},"occlusionMap":{"value":"white","type":28},"emissiveScale":{"type":13,"value":[1]},"emissiveScaleMap":{"value":"grey","type":28},"emissive":{"linear":true,"type":16,"value":[0,0,0,1]},"emissiveMap":{"value":"grey","type":28},"alphaSource":{"type":13,"value":[1]},"alphaSourceMap":{"value":"grey","type":28},"alphaThreshold":{"type":13,"value":[0.5],"handleInfo":["albedoScaleAndCutoff",3,13]},"normalStrength":{"type":13,"value":[1]},"normalMap":{"value":"normal","type":28},"albedo":{"type":16,"value":[1,1,1,1]},"albedoMap":{"type":28,"value":"grey"},"albedoScaleAndCutoff":{"type":16,"value":[0,0,0,0.5]}}},{"phase":"forward-add","propertyIndex":0,"program":"util/dcc/imported-metallic-roughness|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"util/dcc/imported-metallic-roughness|shadow-caster-vs|shadow-caster-fs","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"handleInfo":["albedoScaleAndCutoff",3,13]},"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"alphaSource":{"type":13,"value":[1]},"alphaSourceMap":{"value":"grey","type":28},"albedo":{"type":16,"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"value":[1,1,1,0.5]},"albedoMap":{"type":28,"value":"grey"}}}]}]]],0,0,[],[],[]],[[[24,".bin",2110626103,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":8256,"length":576,"count":288,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":8256,"count":172,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.550000011920929,-0.5500001311302185,0.0050234985537827015],"maxPosition",8,[1,0.5500001311302185,0.550000011920929,1.10906982421875]]],-1],0,0,[],[],[]],[[[22,"grass",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{"USE_INSTANCING":true,"USE_BASE_COLOR_MAP":true,"USE_1ST_SHADE_MAP":true,"USE_2ND_SHADE_MAP":true,"SHADE_MAP_1_AS_SHADE_MAP_2":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{},{}],[[[{},"baseColor",8,[4,4280331533]],[{"baseStep":0.75,"baseFeather":1.5,"shadowCover":1},"mainColor",8,[4,4294967295],"shadeColor1",8,[4,4294967295],"shadeColor2",8,[4,4294967295],"specular",8,[4,16777215],"mainTexture",6,0,"shadeMap1",6,1,"shadeMap2",6,2],{},{}],11,11,0,0]]],0,0,[0,0,0,0],[7,8,9,6],[22,22,22,12]],[[[22,"busSign",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_OUTLINE_PASS":true},{"USE_BASE_COLOR_MAP":true,"USE_1ST_SHADE_MAP":true,"USE_2ND_SHADE_MAP":true,"SHADE_MAP_1_AS_SHADE_MAP_2":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{},{}],[[[{"lineWidth":30},"baseColor",8,[4,4281278609]],[{"baseFeather":1.5},"mainColor",8,[4,4294967295],"shadeColor1",8,[4,4294967295],"shadeColor2",8,[4,4294967295],"specular",8,[4,16777215],"mainTexture",6,0,"shadeMap1",6,1,"shadeMap2",6,2],{},{}],11,11,0,0]]],0,0,[0,0,0,0],[7,8,9,6],[23,23,23,12]],[[[22,"busSign",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.400000005960464,"roughness":0.70710676908493},"albedoScale",8,[1,0.588235318660736,0.588235318660736,0.588235318660736]]],11]]],0,0,[0],[6],[30]],[[[36],[27,"busSign",[-2],[23,"f8bVItO3RZWL0ob30d0xnq",null,null,null,-1,0]],[30,"RootNode",1,[-3],[23,"83hrtAt4VVCbDI/DimDSad",null,null,null,1,0]],[43,"busSign",2,[[18,-4,[2,"b4MNwXQ3dRqqRiRTeFNTKB"],[0],[0],1]],[23,"e4/8TWHrpZYaZqt8miUn07",null,null,null,1,0],[1,0.00000250447806548767,0,0]]],0,[0,2,1,0,-1,2,0,-1,3,0,0,3,0,10,1,4],[0,0],[-1,1],[46,47]],[[[24,".bin",663258779,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":14832,"length":1608,"count":804,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":14832,"count":309,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-3.4020795822143555,0.0833878293633461,-0.9611353874206543],"maxPosition",8,[1,2.280076742172241,9.677009582519531,0.961070716381073]]],-1],0,0,[],[],[]],[[[24,".bin",4248560689,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":16416,"length":1836,"count":918,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":16416,"count":342,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.2886581420898438,-0.0076827239245176315,-1.2881675958633423],"maxPosition",8,[1,1.288079023361206,5.999426364898682,1.2885689735412598]]],-1],0,0,[],[],[]],[[[24,".bin",1378164294,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":68592,"length":8892,"count":4446,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":68592,"count":1429,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-3.3064119815826416,-2.0980834847250662e-7,-3.279965400695801],"maxPosition",8,[1,3.2535183429718018,10.422589302062988,3.279965400695801]]],-1],0,0,[],[],[]],[[[29,"fishBox"],[56,"fishBox",[-2],[23,"f8/ovBRwtez4dn95UVWJl2",null,null,null,-1,0],[1,-39.855,6.782,-39.596],[3,0,0.7071067811865475,0,0.7071067811865476],[1,6,6,6],[1,0,90,0]],[30,"RootNode",1,[-3],[23,"41FCq42XBeqJeqxxfQi3XG",null,null,null,1,0]],[41,"fishBox",2,[[5,1,-4,[2,"f9IUNB1C9X5ZktPa2dkzM8"],[0],[0],1]],[23,"56BXaYDmhTWr6s8yAeD+Yf",null,null,null,1,0],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,0.0000025044782690431654,0,0]]],0,[0,2,1,0,-1,2,0,-1,3,0,0,3,0,10,1,4],[0,0],[-1,1],[48,49]],[[[22,"sea",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_ALBEDO_MAP":true},{},{},{}],[[[{"roughness":1,"metallic":0.5},"mainTexture",6,0],{},{},{}],11,0,0,0]]],0,0,[0,0],[7,6],[50,24]],[[[22,"hotAirBalloonRed",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_OUTLINE_PASS":true,"USE_INSTANCING":true},{"USE_INSTANCING":true,"USE_BASE_COLOR_MAP":true,"USE_1ST_SHADE_MAP":true,"USE_2ND_SHADE_MAP":true,"SHADE_MAP_1_AS_SHADE_MAP_2":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{},{}],[[[{"lineWidth":30},"baseColor",8,[4,4280236151]],[{"baseStep":0.6,"baseFeather":1.5},"mainColor",8,[4,4294967295],"shadeColor1",8,[4,4294967295],"shadeColor2",8,[4,4294967295],"specular",8,[4,16777215],"mainTexture",6,0,"shadeMap1",6,1,"shadeMap2",6,2],{},{}],11,11,0,0]]],0,0,[0,0,0,0],[7,8,9,6],[25,25,25,12]],[[[29,"busSignGroup"],[27,"busSignGroup",[-4,-5],[50,"40Omc9e0ZDk69G+gmoWuGO",null,null,-3,0,[-1,-2]]],[8,["f8bVItO3RZWL0ob30d0xnq"]],[8,["f8bVItO3RZWL0ob30d0xnq"]],[10,0,null,1,[11,"f8bVItO3RZWL0ob30d0xnq",null,null,-8,[28,"7aE3F20M5NE57e9d+pYSSJ",1,[[7,"busSign01",["_name"],2],[4,["_lpos"],2,[1,-34.56,0,-31.596]],[4,["_lrot"],2,[3,0,0.25881904510252074,0,0.9659258262890683]],[4,["_euler"],2,[1,0,30,0]],[26,["_materials","0"],-6,1],[4,["_lscale"],2,[1,1.2,1.2,1.2]],[7,1,["_shadowCastingMode"],-7]]],0]],[10,0,null,1,[11,"f8bVItO3RZWL0ob30d0xnq",null,null,-11,[28,"1ekCiRoXhDj5eSaKQtVgpC",1,[[7,"busSign02",["_name"],3],[4,["_lpos"],3,[1,32.426,0,-31.327]],[4,["_lrot"],3,[3,0,-0.25881904510252074,0,0.9659258262890683]],[4,["_euler"],3,[1,0,-30,0]],[26,["_materials","0"],-9,3],[4,["_lscale"],3,[1,1.2,1.2,1.2]],[7,1,["_shadowCastingMode"],-10]]],2]],[8,["b4MNwXQ3dRqqRiRTeFNTKB"]],[8,["b4MNwXQ3dRqqRiRTeFNTKB"]]],0,[0,-1,4,0,-2,5,0,2,1,0,-1,4,0,-2,5,0,4,6,0,4,6,0,2,4,0,4,7,0,4,7,0,2,5,0,10,1,11],[0,0,0,0],[3,11,3,11],[31,32,31,32]],[[[22,"boxAndStone-001",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_OUTLINE_PASS":true,"USE_INSTANCING":true},{"USE_INSTANCING":true,"USE_BASE_COLOR_MAP":true,"USE_1ST_SHADE_MAP":true,"USE_2ND_SHADE_MAP":true,"SHADE_MAP_1_AS_SHADE_MAP_2":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{},{}],[[[{"lineWidth":12},"baseColor",8,[4,4285010710]],[{"baseStep":0.6,"baseFeather":0.8,"shadowCover":1},"mainColor",8,[4,4294967295],"shadeColor1",8,[4,4294967295],"shadeColor2",8,[4,4294967295],"specular",8,[4,16777215],"mainTexture",6,0,"shadeMap1",6,1,"shadeMap2",6,2],{},{}],11,11,0,0]]],0,0,[0,0,0,0],[7,8,9,6],[13,13,13,12]],[[[29,"grass"],[57,"grass",[-2],[23,"8cfqruozpbl42VHWNYSqGv",null,null,null,-1,0],[1,11.335,0,-2.575]],[30,"RootNode",1,[-3],[23,"b8S7FZZCJawIrCo8wtFxHH",null,null,null,1,0]],[43,"grass",2,[[5,1,-4,[2,"8bJYC0oFRQfJMV1pl96Z4B"],[0],[0],1]],[23,"85K9DJmMpbApGj/vSzVHyH",null,null,null,1,0],[1,0.00000250447806548767,0,0]]],0,[0,2,1,0,-1,2,0,-1,3,0,0,3,0,10,1,4],[0,0],[-1,1],[8,9]],[[[22,"flowers_1",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{"USE_INSTANCING":true,"USE_BASE_COLOR_MAP":true,"USE_1ST_SHADE_MAP":true,"USE_2ND_SHADE_MAP":true},{},{}],[[[{},"baseColor",8,[4,4283708506]],[{},"mainColor",8,[4,4294967295],"shadeColor1",8,[4,4294967295],"shadeColor2",8,[4,4294967295],"specular",8,[4,1275068416],"mainTexture",6,0,"shadeMap1",6,1,"shadeMap2",6,2],{},{}],11,11,0,0]]],0,0,[0,0,0,0],[7,8,9,6],[26,26,26,51]],[[[51,"builtin-toon",[{"hash":1600085135,"name":"builtin-toon|silhouette-edge-vs|silhouette-edge-fs","blocks":[{"name":"OutlineVert","stageFlags":1,"binding":0,"members":[{"name":"outlineParams","type":16,"count":1}],"defines":[]},{"name":"OutlineFrag","stageFlags":16,"binding":1,"members":[{"name":"baseColor","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"baseColorMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_BASE_COLOR_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_color","format":44,"location":6,"defines":[]},{"name":"a_texCoord1","format":21,"location":7,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":12,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBiasAndProbeId","format":44,"isInstanced":true,"location":13,"defines":["USE_INSTANCING"]},{"name":"a_sh_linear_const_r","format":44,"isInstanced":true,"location":14,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_g","format":44,"isInstanced":true,"location":15,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_b","format":44,"isInstanced":true,"location":16,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_vertexId","format":11,"location":17,"defines":["CC_USE_MORPH"]}],"fragColors":[{"name":"fragColorX","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"descriptors":[{"rate":0,"blocks":[{"name":"CCLocal","stageFlags":17,"tags":{"builtin":"local"},"members":[{"name":"cc_matWorld","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matWorldIT","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_lightingMapUVParam","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_localShadowBias","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData2","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["!USE_INSTANCING"]},{"name":"CCMorph","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_displacementWeights","typename":"vec4","type":16,"count":15,"isArray":true},{"name":"cc_displacementTextureInfo","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointTextureInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointAnimInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_joints","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true}],"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCForwardLight","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_lightPos","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true},{"name":"cc_lightColor","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightSizeRangeAngle","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightDir","typename":"vec4","type":16,"count":0,"isArray":true}],"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CCSH","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_sh_linear_const_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_a","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeDataMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":1,"blocks":[{"name":"OutlineVert","stageFlags":1,"binding":0,"members":[{"name":"outlineParams","type":16,"count":1}],"defines":[]},{"name":"OutlineFrag","stageFlags":16,"binding":1,"members":[{"name":"baseColor","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"baseColorMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_BASE_COLOR_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":2,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":3,"blocks":[{"name":"CCGlobal","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_time","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_screenSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nativeSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_probeInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_mode","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCamera","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_cameraPos","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_surfaceTransform","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_screenScale","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_exposure","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitDir","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientSky","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientGround","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogBase","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogAdd","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nearFar","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_viewPort","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCShadow","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matLightView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matLightViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_shadowInvProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowNFLSInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowWHPBInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowLPNNInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowColor","typename":"vec4","type":16,"count":1,"precision":"lowp "},{"name":"cc_planarNDInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCSM","stageFlags":16,"tags":{"builtin":"global"},"members":[{"name":"cc_csmViewDir0","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir1","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir2","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmAtlas","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_matCSMViewProj","typename":"mat4","type":25,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjDepthInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmSplitsInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_environment","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"global"},"defines":[]},{"name":"cc_diffuseMap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]},{"name":"cc_shadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]}],"glsl1":{"vert":"\nprecision highp float;\n#define CC_SURFACES_USE_TANGENT_SPACE 0\n#define CC_SURFACES_USE_VERTEX_COLOR 0\n#define CC_SURFACES_USE_SECOND_UV 0\n#define CC_SURFACES_USE_LIGHT_MAP 0\n#define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#ifndef CC_SURFACES_LIGHTING_CALCULATE_DIFFUSE\n  #define CC_SURFACES_LIGHTING_CALCULATE_DIFFUSE 1\n#endif\n#ifndef CC_SURFACES_LIGHTING_CALCULATE_SPECULAR\n  #define CC_SURFACES_LIGHTING_CALCULATE_SPECULAR 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  attribute vec4 a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  attribute vec4 a_color;\n#endif\n#if CC_SURFACES_USE_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    attribute vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    attribute vec4 a_sh_linear_const_r;\n    attribute vec4 a_sh_linear_const_g;\n    attribute vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n#endif\nvarying highp vec3 v_worldPos;\nvarying mediump vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  varying mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  varying highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define VSOutput_worldPos v_worldPos\n#define VSOutput_worldNormal v_normal.xyz\n#define VSOutput_faceSideSign v_normal.w\n#define VSOutput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define VSOutput_vertexColor v_color\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define VSOutput_worldTangent v_tangent.xyz\n  #define VSOutput_mirrorNormal v_tangent.w\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define VSOutput_texcoord1 v_uv1\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define VSOutput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define VSOutput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define VSOutput_reflectionProbeId v_shadowBiasAndProbeId.z\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define VSOutput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define VSOutput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define VSOutput_clipPos v_clipPos\n#endif\nstruct SurfacesStandardVertexIntermediate\n{\n  highp vec4 position;\n  vec3 normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  vec4 color;\n#endif\n  vec2 texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  vec2 texCoord1;\n#endif\n  highp vec4 clipPos;\n  highp vec3 worldPos;\n  vec4 worldNormal;\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 worldTangent, worldBinormal;\n  #endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  vec4 shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  float fogFactor;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  vec3 lightmapUV;\n#endif\n};\n#if CC_USE_MORPH\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\nuniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_POINT 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_SPHERE 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if !USE_INSTANCING\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  uniform highp vec4 cc_lightingMapUVParam;\n  uniform highp vec4 cc_localShadowBias;\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #if CC_USE_FOG != 4\n    float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n        vec4 wPos = pos;\n        float cam_dis = distance(cameraPos, wPos.xyz);\n        return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n    }\n    float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n        vec4 wPos = pos;\n        float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n        float f = exp(-cam_dis * fogDensity);\n        return f;\n    }\n    float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n        vec4 wPos = pos;\n        float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n        float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n        return f;\n    }\n    float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n        vec4 wPos = pos;\n        vec3 camWorldProj = cameraPos.xyz;\n        camWorldProj.y = 0.;\n        vec3 worldPosProj = wPos.xyz;\n        worldPosProj.y = 0.;\n        float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n        float fDeltaY, fDensityIntegral;\n        if (cameraPos.y > fogTop) {\n            if (wPos.y < fogTop) {\n                fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n                fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n            }\n            else {\n                fDeltaY = 0.;\n                fDensityIntegral = 0.;\n            }\n        }\n        else {\n            if (wPos.y < fogTop) {\n                float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n                float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n                fDeltaY = abs(fDeltaA - fDeltaB);\n                fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n            }\n            else {\n                fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n                fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n            }\n        }\n        float fDensity;\n        if (fDeltaY != 0.) {\n            fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n        }\n        else {\n            fDensity = 0.;\n        }\n        float f = exp(-fDensity);\n        return f;\n    }\n  #endif\n  void CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n  {\n  #if CC_USE_FOG == 0\n  \tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n  #elif CC_USE_FOG == 1\n  \tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n  #elif CC_USE_FOG == 2\n  \tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n  #elif CC_USE_FOG == 3\n  \tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n  #else\n  \tfactor = 1.0;\n  #endif\n  }\n#endif\n        uniform vec4 outlineParams;\n  #define CC_SURFACES_VERTEX_MODIFY_LOCAL_POS\n  vec3 SurfacesVertexModifyLocalPos(in SurfacesStandardVertexIntermediate In)\n  {\n    float width = outlineParams.x * 0.001;\n    vec3 localPos = In.position.xyz;\n  #if USE_POSITION_SCALING\n    vec3 dir = normalize(localPos);\n    float flip = dot(dir, normalize(In.normal)) < 0.0 ? -1.0 : 1.0;\n    localPos += flip * dir * width * 2.0;\n  #else\n    localPos += normalize(In.normal) * width;\n  #endif\n    return localPos;\n  }\n  #define CC_SURFACES_VERTEX_MODIFY_CLIP_POS\n  vec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)\n  {\n    vec4 clipPos = In.clipPos;\n    clipPos.z -= outlineParams.y * 0.002;\n    return clipPos;\n  }\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_POS\nvec3 SurfacesVertexModifyLocalPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.position.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_NORMAL\nvec3 SurfacesVertexModifyLocalNormal(in SurfacesStandardVertexIntermediate In)\n{\n  return In.normal.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_TANGENT\n  #if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 SurfacesVertexModifyLocalTangent(in SurfacesStandardVertexIntermediate In)\n    {\n      return In.tangent;\n    }\n  #endif\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_SHARED_DATA\nvoid SurfacesVertexModifyLocalSharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_POS\nvec3 SurfacesVertexModifyWorldPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.worldPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_CLIP_POS\nvec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.clipPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_NORMAL\nvec3 SurfacesVertexModifyWorldNormal(in SurfacesStandardVertexIntermediate In)\n{\n    vec3 worldNormal = In.worldNormal.xyz;\n  #if CC_SURFACES_USE_TWO_SIDED\n      worldNormal.xyz *= In.worldNormal.w;\n  #endif\n  return worldNormal;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHARED_DATA\nvoid SurfacesVertexModifySharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\nvoid CCSurfacesVertexInput(out SurfacesStandardVertexIntermediate In)\n{\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  In.tangent = a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  In.color = a_color;\n#endif\n  In.texCoord = a_texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = a_texCoord1;\n#endif\n}\nvoid CCSurfacesVertexOutput(in SurfacesStandardVertexIntermediate In)\n{\n  gl_Position = In.clipPos;\n  VSOutput_worldNormal = In.worldNormal.xyz;\n  VSOutput_faceSideSign = In.worldNormal.w;\n  VSOutput_worldPos = In.worldPos;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  VSOutput_worldTangent = In.worldTangent.xyz;\n  VSOutput_mirrorNormal = In.tangent.w > 0.0 ? 1.0 : -1.0;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  VSOutput_vertexColor = In.color;\n#endif\n  VSOutput_texcoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  VSOutput_texcoord1 = In.texCoord1;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  VSOutput_fogFactor = In.fogFactor;\n#endif\n#if CC_RECEIVE_SHADOW\n  VSOutput_shadowBias = In.shadowBiasAndProbeId.xy;\n#endif\n#if CC_USE_REFLECTION_PROBE\n  VSOutput_reflectionProbeId = In.shadowBiasAndProbeId.z;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  VSOutput_lightMapUV = In.lightmapUV;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  VSOutput_localPos = In.position;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  VSOutput_clipPos = In.clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    v_sh_linear_const_r = a_sh_linear_const_r;\n    v_sh_linear_const_g = a_sh_linear_const_g;\n    v_sh_linear_const_b = a_sh_linear_const_b;\n  #endif\n#endif\n}\nvoid CCSurfacesVertexAnimation(inout SurfacesStandardVertexIntermediate In)\n{\nvec4 temp = vec4(0.0);\n#if CC_USE_MORPH\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    applyMorph(In.position, In.normal, In.tangent);\n  #else\n    applyMorph(In.position, In.normal, temp);\n  #endif\n#endif\n#if CC_USE_SKINNING\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    CCSkin(In.position, In.normal, In.tangent);\n  #else\n    CCSkin(In.position, In.normal, temp);\n  #endif\n#endif\n}\nvoid CCSurfacesVertexWorldTransform(inout SurfacesStandardVertexIntermediate In)\n{\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    In.worldPos = (matWorld * In.position).xyz;\n    In.worldNormal.xyz = normalize((matWorldIT * vec4(In.normal.xyz, 0.0)).xyz);\n    #if CC_SURFACES_USE_TANGENT_SPACE\n      In.worldTangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      In.worldBinormal = cross(In.worldNormal.xyz, In.worldTangent) * In.tangent.w;\n    #endif\n}\nvoid CCSurfacesVertexTransformUV(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_SURFACES_FLIP_UV\n    In.texCoord = cc_cameraPos.w > 1.0 ? vec2(In.texCoord.x, 1.0 - In.texCoord.y) : In.texCoord;\n    #if CC_SURFACES_USE_SECOND_UV\n      In.texCoord1 = cc_cameraPos.w > 1.0 ? vec2(In.texCoord1.x, 1.0 - In.texCoord1.y) : In.texCoord1;\n    #endif\n  #endif\n}\nvoid CCSurfacesVertexTransferFog(inout SurfacesStandardVertexIntermediate In)\n{\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(vec4(In.worldPos, 1.0), In.fogFactor);\n#endif\n}\nvoid CCSurfacesVertexTransferShadow(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    In.shadowBiasAndProbeId = vec4(0.0);\n  #endif\n  #if CC_RECEIVE_SHADOW\n    In.shadowBiasAndProbeId.xy = vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n    #if USE_INSTANCING\n      In.shadowBiasAndProbeId.xy += a_localShadowBiasAndProbeId.xy;\n    #else\n      In.shadowBiasAndProbeId.xy += cc_localShadowBias.xy;\n    #endif\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    #if USE_INSTANCING\n      In.shadowBiasAndProbeId.zw = a_localShadowBiasAndProbeId.zw;\n    #else\n      In.shadowBiasAndProbeId.zw = cc_localShadowBias.zw;\n    #endif\n  #endif\n}\nvoid CCSurfacesVertexTransferLightMapUV(inout SurfacesStandardVertexIntermediate In)\n{\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #if USE_INSTANCING\n    In.lightmapUV.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    In.lightmapUV.z = a_lightingMapUVParam.w;\n  #else\n    In.lightmapUV.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    In.lightmapUV.z = cc_lightingMapUVParam.w;\n  #endif\n#endif\n}\nvoid main()\n{\n  SurfacesStandardVertexIntermediate In;\n  CCSurfacesVertexInput(In);\n  CCSurfacesVertexAnimation(In);\n  In.position.xyz = SurfacesVertexModifyLocalPos(In);\n  In.normal.xyz = SurfacesVertexModifyLocalNormal(In);\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    In.tangent = SurfacesVertexModifyLocalTangent(In);\n  #endif\n  SurfacesVertexModifyLocalSharedData(In);\n  CCSurfacesVertexWorldTransform(In);\n  In.worldPos = SurfacesVertexModifyWorldPos(In);\n  In.clipPos = cc_matProj * cc_matView * vec4(In.worldPos, 1.0);\n  In.clipPos = SurfacesVertexModifyClipPos(In);\n  vec3 viewDirect = normalize(cc_cameraPos.xyz - In.worldPos);\n  In.worldNormal.w = dot(In.worldNormal.xyz, viewDirect) < 0.0 ? -1.0 : 1.0;\n  In.worldNormal.xyz = SurfacesVertexModifyWorldNormal(In);\n  SurfacesVertexModifyUV(In);\n  SurfacesVertexModifySharedData(In);\n  CCSurfacesVertexTransformUV(In);\n  CCSurfacesVertexTransferFog(In);\n  CCSurfacesVertexTransferShadow(In);\n  CCSurfacesVertexTransferLightMapUV(In);\n  CCSurfacesVertexOutput(In);\n}","frag":"\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\n#define CC_SURFACES_USE_TANGENT_SPACE 0\n#define CC_SURFACES_USE_VERTEX_COLOR 0\n#define CC_SURFACES_USE_SECOND_UV 0\n#define CC_SURFACES_USE_LIGHT_MAP 0\n#define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#ifndef CC_SURFACES_LIGHTING_CALCULATE_DIFFUSE\n  #define CC_SURFACES_LIGHTING_CALCULATE_DIFFUSE 1\n#endif\n#ifndef CC_SURFACES_LIGHTING_CALCULATE_SPECULAR\n  #define CC_SURFACES_LIGHTING_CALCULATE_SPECULAR 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nvarying highp vec3 v_worldPos;\nvarying mediump vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  varying mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  varying highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define FSInput_worldPos v_worldPos\n#define FSInput_worldNormal v_normal.xyz\n#define FSInput_faceSideSign v_normal.w\n#define FSInput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define FSInput_vertexColor v_color\n#else\n  #define FSInput_vertexColor vec4(1.0)\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define FSInput_worldTangent v_tangent.xyz\n  #define FSInput_mirrorNormal v_tangent.w\n#else\n  #define FSInput_worldTangent vec3(0.0, 0.0, 0.0)\n  #define FSInput_mirrorNormal 1.0\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define FSInput_texcoord1 v_uv1\n#else\n  #define FSInput_texcoord1 vec2(0.0, 0.0)\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define FSInput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define FSInput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define FSInput_reflectionProbeId v_shadowBiasAndProbeId.z\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define FSInput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define FSInput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define FSInput_clipPos v_clipPos\n#endif\nuniform mediump vec4 cc_debug_view_mode;\nuniform mediump vec4 cc_surfaceTransform;\n  uniform mediump vec4 cc_mainLitColor;\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_IOR CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_IOR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FRESNEL CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_FRESNEL + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRT_DIRECT CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_TRT_ENVIRONMENT CC_SURFACES_DEBUG_VIEW_TRT_DIRECT + 1\n#define CC_SURFACES_DEBUG_VIEW_TRT_ALL CC_SURFACES_DEBUG_VIEW_TRT_ENVIRONMENT + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_TRT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#define IS_DEBUG_VIEW_ENABLE_WITH_CAMERA (cc_surfaceTransform.y != 3.0)\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (UnpackBitFromFloat(cc_debug_view_mode.w, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (UnpackBitFromFloat(cc_debug_view_mode.w, 7) && IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (UnpackBitFromFloat(cc_debug_view_mode.y, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (UnpackBitFromFloat(cc_debug_view_mode.y, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (UnpackBitFromFloat(cc_debug_view_mode.y, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (UnpackBitFromFloat(cc_debug_view_mode.y, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (UnpackBitFromFloat(cc_debug_view_mode.z, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (UnpackBitFromFloat(cc_debug_view_mode.z, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (UnpackBitFromFloat(cc_debug_view_mode.z, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (UnpackBitFromFloat(cc_debug_view_mode.z, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL (UnpackBitFromFloat(cc_debug_view_mode.z, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.z, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRT (UnpackBitFromFloat(cc_debug_view_mode.z, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT (UnpackBitFromFloat(cc_debug_view_mode.w, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    #if CC_PIPELINE_TYPE == 0\n      #define LIGHTS_PER_PASS 1\n    #else\n      #define LIGHTS_PER_PASS 10\n    #endif\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n    #endif\n  #endif\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if !USE_INSTANCING\n    #endif\n#endif\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #endif\nuniform samplerCube cc_environment;\n#if CC_USE_IBL\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform samplerCube cc_reflectionProbeCubemap;\n  uniform sampler2D cc_reflectionProbePlanarMap;\n  uniform sampler2D cc_reflectionProbeDataMap;\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_POINT 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_SPHERE 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return gamma;\n    }\n  #endif\n#endif\n  return gamma * gamma;\n}\nvec3 LinearToSRGB(vec3 linear) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return linear;\n    }\n  #endif\n#endif\n  return sqrt(linear);\n}\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n#endif\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\n#if CC_USE_FOG != 4\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if CC_USE_LIGHT_PROBE\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  uniform sampler2D cc_lightingMap;\n#endif\n    uniform vec4 baseColor;\n#if USE_BASE_COLOR_MAP\n  uniform sampler2D baseColorMap;\n#endif\n#define CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\nvec4 SurfacesFragmentModifyBaseColorAndTransparency()\n{\n  vec4 color = vec4(cc_mainLitColor.rgb, 1.0);\n  color.rgb = SRGBToLinear(baseColor.rgb);\n  #if USE_BASE_COLOR_MAP\n    vec4 texColor = texture2D(baseColorMap, FSInput_texcoord);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    color *= texColor;\n  #endif\n  return color;\n}\nvoid main () {\n  vec4 color = SurfacesFragmentModifyBaseColorAndTransparency();\n#if CC_USE_HDR\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n    if (IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING)\n  #endif\n  color.rgb = ACESToneMap(color.rgb);\n#endif\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  if (IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION)\n#endif\n  color.rgb = LinearToSRGB(color.rgb);\n  gl_FragColor = color;\n}"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]},{"name":"CCCSM","defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_environment","defines":[]},{"name":"cc_diffuseMap","defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]},{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":["!USE_INSTANCING"]},{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CCSH","defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeDataMap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":89,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":119}},"defines":[{"name":"USE_INSTANCING","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"boolean"},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_LIGHT_PROBE","type":"boolean","default":0},{"name":"CC_USE_MORPH","type":"boolean"},{"name":"CC_FORWARD_ADD","type":"boolean"},{"name":"CC_USE_FOG","type":"number","range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean"},{"name":"CC_USE_REFLECTION_PROBE","type":"boolean"},{"name":"CC_MORPH_TARGET_COUNT","type":"number","range":[2,8]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean"},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean"},{"name":"CC_USE_REAL_TIME_JOINT_TEXTURE","type":"boolean"},{"name":"USE_POSITION_SCALING","type":"boolean"},{"name":"CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER","type":"number","range":[0,1]},{"name":"CC_PIPELINE_TYPE","type":"number","range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean"},{"name":"CC_SUPPORT_CASCADED_SHADOW_MAP","type":"boolean"},{"name":"CC_USE_IBL","type":"number","range":[0,2]},{"name":"CC_USE_DIFFUSEMAP","type":"number","range":[0,2]},{"name":"CC_USE_DEBUG_VIEW","type":"number","range":[0,3]},{"name":"USE_BASE_COLOR_MAP","type":"boolean"},{"name":"CC_USE_HDR","type":"boolean"}]},{"hash":2343048929,"name":"builtin-toon|toon-vs|toon-fs","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"baseColor","type":16,"count":1},{"name":"colorScaleAndCutoff","type":16,"count":1},{"name":"shadeColor1","type":16,"count":1},{"name":"shadeColor2","type":16,"count":1},{"name":"specular","type":16,"count":1},{"name":"shadeParams","type":16,"count":1},{"name":"miscParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleAndStrenth","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"baseColorMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_BASE_COLOR_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_NORMAL_MAP"]},{"name":"shadeMap1","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_1ST_SHADE_MAP"]},{"name":"shadeMap2","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_2ND_SHADE_MAP"]},{"name":"specularMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_SPECULAR_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_EMISSIVE_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":["USE_NORMAL_MAP"]},{"name":"a_color","format":44,"location":6,"defines":[]},{"name":"a_texCoord1","format":21,"location":7,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":12,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBiasAndProbeId","format":44,"isInstanced":true,"location":13,"defines":["USE_INSTANCING"]},{"name":"a_sh_linear_const_r","format":44,"isInstanced":true,"location":14,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_g","format":44,"isInstanced":true,"location":15,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_b","format":44,"isInstanced":true,"location":16,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_vertexId","format":11,"location":17,"defines":["CC_USE_MORPH"]}],"fragColors":[{"name":"fragColorX","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"tags":[],"defines":[]},{"name":"fragColor0","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":1,"tags":["CC_PIPELINE_TYPE"],"defines":["CC_PIPELINE_TYPE"]},{"name":"fragColor1","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":2,"defines":["CC_PIPELINE_TYPE"]},{"name":"fragColor2","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":3,"defines":["CC_PIPELINE_TYPE"]}],"descriptors":[{"rate":0,"blocks":[{"name":"CCLocal","stageFlags":17,"tags":{"builtin":"local"},"members":[{"name":"cc_matWorld","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matWorldIT","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_lightingMapUVParam","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_localShadowBias","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData2","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["!USE_INSTANCING"]},{"name":"CCMorph","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_displacementWeights","typename":"vec4","type":16,"count":15,"isArray":true},{"name":"cc_displacementTextureInfo","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointTextureInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointAnimInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_joints","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true}],"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCForwardLight","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_lightPos","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true},{"name":"cc_lightColor","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightSizeRangeAngle","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightDir","typename":"vec4","type":16,"count":0,"isArray":true}],"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CCSH","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_sh_linear_const_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_a","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeDataMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":1,"blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"baseColor","type":16,"count":1},{"name":"colorScaleAndCutoff","type":16,"count":1},{"name":"shadeColor1","type":16,"count":1},{"name":"shadeColor2","type":16,"count":1},{"name":"specular","type":16,"count":1},{"name":"shadeParams","type":16,"count":1},{"name":"miscParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleAndStrenth","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"baseColorMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_BASE_COLOR_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_NORMAL_MAP"]},{"name":"shadeMap1","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_1ST_SHADE_MAP"]},{"name":"shadeMap2","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_2ND_SHADE_MAP"]},{"name":"specularMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_SPECULAR_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_EMISSIVE_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":2,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":3,"blocks":[{"name":"CCGlobal","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_time","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_screenSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nativeSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_probeInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_mode","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCamera","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_cameraPos","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_surfaceTransform","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_screenScale","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_exposure","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitDir","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientSky","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientGround","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogBase","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogAdd","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nearFar","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_viewPort","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCShadow","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matLightView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matLightViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_shadowInvProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowNFLSInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowWHPBInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowLPNNInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowColor","typename":"vec4","type":16,"count":1,"precision":"lowp "},{"name":"cc_planarNDInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCSM","stageFlags":16,"tags":{"builtin":"global"},"members":[{"name":"cc_csmViewDir0","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir1","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir2","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmAtlas","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_matCSMViewProj","typename":"mat4","type":25,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjDepthInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmSplitsInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_environment","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"global"},"defines":[]},{"name":"cc_diffuseMap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]},{"name":"cc_shadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]}],"glsl1":{"vert":"\nprecision highp float;\n#define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING USE_COMPATIBLE_LIGHTING\n#define CC_SURFACES_USE_TANGENT_SPACE USE_NORMAL_MAP\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#ifndef CC_SURFACES_LIGHTING_CALCULATE_DIFFUSE\n  #define CC_SURFACES_LIGHTING_CALCULATE_DIFFUSE 1\n#endif\n#ifndef CC_SURFACES_LIGHTING_CALCULATE_SPECULAR\n  #define CC_SURFACES_LIGHTING_CALCULATE_SPECULAR 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  attribute vec4 a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  attribute vec4 a_color;\n#endif\n#if CC_SURFACES_USE_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    attribute vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    attribute vec4 a_sh_linear_const_r;\n    attribute vec4 a_sh_linear_const_g;\n    attribute vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n#endif\nvarying highp vec3 v_worldPos;\nvarying mediump vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  varying mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  varying highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define VSOutput_worldPos v_worldPos\n#define VSOutput_worldNormal v_normal.xyz\n#define VSOutput_faceSideSign v_normal.w\n#define VSOutput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define VSOutput_vertexColor v_color\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define VSOutput_worldTangent v_tangent.xyz\n  #define VSOutput_mirrorNormal v_tangent.w\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define VSOutput_texcoord1 v_uv1\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define VSOutput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define VSOutput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define VSOutput_reflectionProbeId v_shadowBiasAndProbeId.z\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define VSOutput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define VSOutput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define VSOutput_clipPos v_clipPos\n#endif\nstruct SurfacesStandardVertexIntermediate\n{\n  highp vec4 position;\n  vec3 normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  vec4 color;\n#endif\n  vec2 texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  vec2 texCoord1;\n#endif\n  highp vec4 clipPos;\n  highp vec3 worldPos;\n  vec4 worldNormal;\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 worldTangent, worldBinormal;\n  #endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  vec4 shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  float fogFactor;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  vec3 lightmapUV;\n#endif\n};\n#if CC_USE_MORPH\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\nuniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_POINT 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_SPHERE 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if !USE_INSTANCING\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  uniform highp vec4 cc_lightingMapUVParam;\n  uniform highp vec4 cc_localShadowBias;\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #if CC_USE_FOG != 4\n    float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n        vec4 wPos = pos;\n        float cam_dis = distance(cameraPos, wPos.xyz);\n        return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n    }\n    float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n        vec4 wPos = pos;\n        float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n        float f = exp(-cam_dis * fogDensity);\n        return f;\n    }\n    float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n        vec4 wPos = pos;\n        float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n        float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n        return f;\n    }\n    float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n        vec4 wPos = pos;\n        vec3 camWorldProj = cameraPos.xyz;\n        camWorldProj.y = 0.;\n        vec3 worldPosProj = wPos.xyz;\n        worldPosProj.y = 0.;\n        float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n        float fDeltaY, fDensityIntegral;\n        if (cameraPos.y > fogTop) {\n            if (wPos.y < fogTop) {\n                fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n                fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n            }\n            else {\n                fDeltaY = 0.;\n                fDensityIntegral = 0.;\n            }\n        }\n        else {\n            if (wPos.y < fogTop) {\n                float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n                float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n                fDeltaY = abs(fDeltaA - fDeltaB);\n                fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n            }\n            else {\n                fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n                fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n            }\n        }\n        float fDensity;\n        if (fDeltaY != 0.) {\n            fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n        }\n        else {\n            fDensity = 0.;\n        }\n        float f = exp(-fDensity);\n        return f;\n    }\n  #endif\n  void CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n  {\n  #if CC_USE_FOG == 0\n  \tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n  #elif CC_USE_FOG == 1\n  \tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n  #elif CC_USE_FOG == 2\n  \tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n  #elif CC_USE_FOG == 3\n  \tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n  #else\n  \tfactor = 1.0;\n  #endif\n  }\n#endif\n    uniform vec4 tilingOffset;\n#define CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord * tilingOffset.xy + tilingOffset.zw;\n}\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_POS\nvec3 SurfacesVertexModifyLocalPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.position.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_NORMAL\nvec3 SurfacesVertexModifyLocalNormal(in SurfacesStandardVertexIntermediate In)\n{\n  return In.normal.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_TANGENT\n  #if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 SurfacesVertexModifyLocalTangent(in SurfacesStandardVertexIntermediate In)\n    {\n      return In.tangent;\n    }\n  #endif\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_SHARED_DATA\nvoid SurfacesVertexModifyLocalSharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_POS\nvec3 SurfacesVertexModifyWorldPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.worldPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_CLIP_POS\nvec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.clipPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_NORMAL\nvec3 SurfacesVertexModifyWorldNormal(in SurfacesStandardVertexIntermediate In)\n{\n    vec3 worldNormal = In.worldNormal.xyz;\n  #if CC_SURFACES_USE_TWO_SIDED\n      worldNormal.xyz *= In.worldNormal.w;\n  #endif\n  return worldNormal;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHARED_DATA\nvoid SurfacesVertexModifySharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\nvoid CCSurfacesVertexInput(out SurfacesStandardVertexIntermediate In)\n{\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  In.tangent = a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  In.color = a_color;\n#endif\n  In.texCoord = a_texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = a_texCoord1;\n#endif\n}\nvoid CCSurfacesVertexOutput(in SurfacesStandardVertexIntermediate In)\n{\n  gl_Position = In.clipPos;\n  VSOutput_worldNormal = In.worldNormal.xyz;\n  VSOutput_faceSideSign = In.worldNormal.w;\n  VSOutput_worldPos = In.worldPos;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  VSOutput_worldTangent = In.worldTangent.xyz;\n  VSOutput_mirrorNormal = In.tangent.w > 0.0 ? 1.0 : -1.0;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  VSOutput_vertexColor = In.color;\n#endif\n  VSOutput_texcoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  VSOutput_texcoord1 = In.texCoord1;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  VSOutput_fogFactor = In.fogFactor;\n#endif\n#if CC_RECEIVE_SHADOW\n  VSOutput_shadowBias = In.shadowBiasAndProbeId.xy;\n#endif\n#if CC_USE_REFLECTION_PROBE\n  VSOutput_reflectionProbeId = In.shadowBiasAndProbeId.z;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  VSOutput_lightMapUV = In.lightmapUV;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  VSOutput_localPos = In.position;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  VSOutput_clipPos = In.clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    v_sh_linear_const_r = a_sh_linear_const_r;\n    v_sh_linear_const_g = a_sh_linear_const_g;\n    v_sh_linear_const_b = a_sh_linear_const_b;\n  #endif\n#endif\n}\nvoid CCSurfacesVertexAnimation(inout SurfacesStandardVertexIntermediate In)\n{\nvec4 temp = vec4(0.0);\n#if CC_USE_MORPH\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    applyMorph(In.position, In.normal, In.tangent);\n  #else\n    applyMorph(In.position, In.normal, temp);\n  #endif\n#endif\n#if CC_USE_SKINNING\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    CCSkin(In.position, In.normal, In.tangent);\n  #else\n    CCSkin(In.position, In.normal, temp);\n  #endif\n#endif\n}\nvoid CCSurfacesVertexWorldTransform(inout SurfacesStandardVertexIntermediate In)\n{\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    In.worldPos = (matWorld * In.position).xyz;\n    In.worldNormal.xyz = normalize((matWorldIT * vec4(In.normal.xyz, 0.0)).xyz);\n    #if CC_SURFACES_USE_TANGENT_SPACE\n      In.worldTangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      In.worldBinormal = cross(In.worldNormal.xyz, In.worldTangent) * In.tangent.w;\n    #endif\n}\nvoid CCSurfacesVertexTransformUV(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_SURFACES_FLIP_UV\n    In.texCoord = cc_cameraPos.w > 1.0 ? vec2(In.texCoord.x, 1.0 - In.texCoord.y) : In.texCoord;\n    #if CC_SURFACES_USE_SECOND_UV\n      In.texCoord1 = cc_cameraPos.w > 1.0 ? vec2(In.texCoord1.x, 1.0 - In.texCoord1.y) : In.texCoord1;\n    #endif\n  #endif\n}\nvoid CCSurfacesVertexTransferFog(inout SurfacesStandardVertexIntermediate In)\n{\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(vec4(In.worldPos, 1.0), In.fogFactor);\n#endif\n}\nvoid CCSurfacesVertexTransferShadow(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    In.shadowBiasAndProbeId = vec4(0.0);\n  #endif\n  #if CC_RECEIVE_SHADOW\n    In.shadowBiasAndProbeId.xy = vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n    #if USE_INSTANCING\n      In.shadowBiasAndProbeId.xy += a_localShadowBiasAndProbeId.xy;\n    #else\n      In.shadowBiasAndProbeId.xy += cc_localShadowBias.xy;\n    #endif\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    #if USE_INSTANCING\n      In.shadowBiasAndProbeId.zw = a_localShadowBiasAndProbeId.zw;\n    #else\n      In.shadowBiasAndProbeId.zw = cc_localShadowBias.zw;\n    #endif\n  #endif\n}\nvoid CCSurfacesVertexTransferLightMapUV(inout SurfacesStandardVertexIntermediate In)\n{\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #if USE_INSTANCING\n    In.lightmapUV.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    In.lightmapUV.z = a_lightingMapUVParam.w;\n  #else\n    In.lightmapUV.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    In.lightmapUV.z = cc_lightingMapUVParam.w;\n  #endif\n#endif\n}\nvoid main()\n{\n  SurfacesStandardVertexIntermediate In;\n  CCSurfacesVertexInput(In);\n  CCSurfacesVertexAnimation(In);\n  In.position.xyz = SurfacesVertexModifyLocalPos(In);\n  In.normal.xyz = SurfacesVertexModifyLocalNormal(In);\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    In.tangent = SurfacesVertexModifyLocalTangent(In);\n  #endif\n  SurfacesVertexModifyLocalSharedData(In);\n  CCSurfacesVertexWorldTransform(In);\n  In.worldPos = SurfacesVertexModifyWorldPos(In);\n  In.clipPos = cc_matProj * cc_matView * vec4(In.worldPos, 1.0);\n  In.clipPos = SurfacesVertexModifyClipPos(In);\n  vec3 viewDirect = normalize(cc_cameraPos.xyz - In.worldPos);\n  In.worldNormal.w = dot(In.worldNormal.xyz, viewDirect) < 0.0 ? -1.0 : 1.0;\n  In.worldNormal.xyz = SurfacesVertexModifyWorldNormal(In);\n  SurfacesVertexModifyUV(In);\n  SurfacesVertexModifySharedData(In);\n  CCSurfacesVertexTransformUV(In);\n  CCSurfacesVertexTransferFog(In);\n  CCSurfacesVertexTransferShadow(In);\n  CCSurfacesVertexTransferLightMapUV(In);\n  CCSurfacesVertexOutput(In);\n}","frag":"\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\n#define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING USE_COMPATIBLE_LIGHTING\n#define CC_SURFACES_USE_TANGENT_SPACE USE_NORMAL_MAP\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#ifndef CC_SURFACES_LIGHTING_CALCULATE_DIFFUSE\n  #define CC_SURFACES_LIGHTING_CALCULATE_DIFFUSE 1\n#endif\n#ifndef CC_SURFACES_LIGHTING_CALCULATE_SPECULAR\n  #define CC_SURFACES_LIGHTING_CALCULATE_SPECULAR 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nvarying highp vec3 v_worldPos;\nvarying mediump vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  varying mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  varying highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define FSInput_worldPos v_worldPos\n#define FSInput_worldNormal v_normal.xyz\n#define FSInput_faceSideSign v_normal.w\n#define FSInput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define FSInput_vertexColor v_color\n#else\n  #define FSInput_vertexColor vec4(1.0)\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define FSInput_worldTangent v_tangent.xyz\n  #define FSInput_mirrorNormal v_tangent.w\n#else\n  #define FSInput_worldTangent vec3(0.0, 0.0, 0.0)\n  #define FSInput_mirrorNormal 1.0\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define FSInput_texcoord1 v_uv1\n#else\n  #define FSInput_texcoord1 vec2(0.0, 0.0)\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define FSInput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define FSInput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define FSInput_reflectionProbeId v_shadowBiasAndProbeId.z\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define FSInput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define FSInput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define FSInput_clipPos v_clipPos\n#endif\nuniform highp vec4 cc_time;\n  uniform mediump vec4 cc_debug_view_mode;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_surfaceTransform;\n  uniform mediump vec4 cc_exposure;\n  uniform mediump vec4 cc_mainLitDir;\n  uniform mediump vec4 cc_mainLitColor;\n  uniform mediump vec4 cc_ambientSky;\n  uniform mediump vec4 cc_fogColor;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n  uniform mediump vec4 cc_nearFar;\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_IOR CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_IOR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FRESNEL CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_FRESNEL + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRT_DIRECT CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_TRT_ENVIRONMENT CC_SURFACES_DEBUG_VIEW_TRT_DIRECT + 1\n#define CC_SURFACES_DEBUG_VIEW_TRT_ALL CC_SURFACES_DEBUG_VIEW_TRT_ENVIRONMENT + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_TRT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#define IS_DEBUG_VIEW_ENABLE_WITH_CAMERA (cc_surfaceTransform.y != 3.0)\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (UnpackBitFromFloat(cc_debug_view_mode.w, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (UnpackBitFromFloat(cc_debug_view_mode.w, 7) && IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (UnpackBitFromFloat(cc_debug_view_mode.y, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (UnpackBitFromFloat(cc_debug_view_mode.y, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (UnpackBitFromFloat(cc_debug_view_mode.y, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (UnpackBitFromFloat(cc_debug_view_mode.y, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (UnpackBitFromFloat(cc_debug_view_mode.z, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (UnpackBitFromFloat(cc_debug_view_mode.z, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (UnpackBitFromFloat(cc_debug_view_mode.z, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (UnpackBitFromFloat(cc_debug_view_mode.z, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL (UnpackBitFromFloat(cc_debug_view_mode.z, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.z, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRT (UnpackBitFromFloat(cc_debug_view_mode.z, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT (UnpackBitFromFloat(cc_debug_view_mode.w, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    #if CC_PIPELINE_TYPE == 0\n      #define LIGHTS_PER_PASS 1\n    #else\n      #define LIGHTS_PER_PASS 10\n    #endif\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n    uniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightColor[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n    #endif\n  #endif\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if !USE_INSTANCING\n    #endif\n#endif\nuniform highp mat4 cc_matLightView;\n  uniform highp mat4 cc_matLightViewProj;\n  uniform highp vec4 cc_shadowInvProjDepthInfo;\n  uniform highp vec4 cc_shadowProjDepthInfo;\n  uniform highp vec4 cc_shadowProjInfo;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  uniform highp vec4 cc_csmViewDir0[4];\n  uniform highp vec4 cc_csmViewDir1[4];\n  uniform highp vec4 cc_csmViewDir2[4];\n  uniform highp vec4 cc_csmAtlas[4];\n  uniform highp mat4 cc_matCSMViewProj[4];\n  uniform highp vec4 cc_csmProjDepthInfo[4];\n  uniform highp vec4 cc_csmProjInfo[4];\n  uniform highp vec4 cc_csmSplitsInfo;\n#endif\nuniform samplerCube cc_environment;\n#if CC_USE_IBL\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform samplerCube cc_reflectionProbeCubemap;\n  uniform sampler2D cc_reflectionProbePlanarMap;\n  uniform sampler2D cc_reflectionProbeDataMap;\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_POINT 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_SPHERE 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nvec4 packRGBE (vec3 rgb) {\n  highp float maxComp = max(max(rgb.r, rgb.g), rgb.b);\n  highp float e = 128.0;\n  if (maxComp > 0.0001) {\n    e = log(maxComp) / log(1.1);\n    e = ceil(e);\n    e = clamp(e + 128.0, 0.0, 255.0);\n  }\n  highp float sc = 1.0 / pow(1.1, e - 128.0);\n  vec3 encode = clamp(rgb * sc, vec3(0.0), vec3(1.0)) * 255.0;\n  vec3 encode_rounded = floor(encode) + step(encode - floor(encode), vec3(0.5));\n  return vec4(encode_rounded, e) / 255.0;\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return gamma;\n    }\n  #endif\n#endif\n  return gamma * gamma;\n}\nvec3 LinearToSRGB(vec3 linear) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return linear;\n    }\n  #endif\n#endif\n  return sqrt(linear);\n}\nbool isnan(float val) {\n  return (val < 0.0 || 0.0 < val || val == 0.0) ? false : true;\n}\nbool isinf(float x) {\n  return x == x * 2.0 && x != 0.0;\n}\nbool isnans(vec2 val) {\n    return isnan(val.x) || isnan(val.y);\n}\nbool isnans(vec3 val) {\n    return isnan(val.x) || isnan(val.y) || isnan(val.z);\n}\nbool isnans(vec4 val) {\n    return isnan(val.x) || isnan(val.y) || isnan(val.z) || isnan(val.w);\n}\nbool isinfs(vec2 val) {\n    return isinf(val.x) || isinf(val.y);\n}\nbool isinfs(vec3 val) {\n    return isinf(val.x) || isinf(val.y) || isinf(val.z);\n}\nbool isinfs(vec4 val) {\n    return isinf(val.x) || isinf(val.y) || isinf(val.z) || isinf(val.w);\n}\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\nvec3 CalculateBinormal(vec3 normal, vec3 tangent, float mirrorNormal)\n{\n    return cross(normal.xyz, tangent) * mirrorNormal;\n}\nvec3 CalculateNormalFromTangentSpace(vec3 normalFromTangentSpace, float normalStrength, vec3 normal, vec3 tangent, float mirrorNormal)\n{\n    vec3 binormal = CalculateBinormal(normal, tangent, mirrorNormal);\n    return (normalFromTangentSpace.x * normalStrength) * normalize(tangent) +\n           (normalFromTangentSpace.y * normalStrength) * normalize(binormal) +\n            normalFromTangentSpace.z * normalize(normal);\n}\nvec2 signNotZero(vec2 v) {\n  return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n}\nvec2 float32x3_to_oct(in vec3 v) {\n  vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n  return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n}\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n#endif\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  float SampleShadowMap (vec3 shadowNDCPos, highp sampler2D shadowMap)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return dot(texture2D(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    #else\n      return texture2D(shadowMap, shadowNDCPos.xy).x;\n    #endif\n  }\n  float NativePCFShadowFactorHard (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return step(shadowNDCPos.z, dot(texture2D(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      return step(shadowNDCPos.z, texture2D(shadowMap, shadowNDCPos.xy).x);\n    #endif\n  }\n  float NativePCFShadowFactorSoft (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block1 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)).x);\n      block2 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)).x);\n      block3 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)).x);\n    #endif\n    float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float NativePCFShadowFactorSoft3X (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    float shadowNDCPos_offset_L = shadowNDCPos.x - oneTap.x;\n    float shadowNDCPos_offset_R = shadowNDCPos.x + oneTap.x;\n    float shadowNDCPos_offset_U = shadowNDCPos.y - oneTap.y;\n    float shadowNDCPos_offset_D = shadowNDCPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)).x);\n      block1 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)).x);\n      block2 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)).x);\n      block3 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)).x);\n      block4 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block5 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)).x);\n      block6 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)).x);\n      block7 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)).x);\n      block8 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)).x);\n    #endif\n    float coefX = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float coefY = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float NativePCFShadowFactorSoft5X (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 twoTap = oneTap * 2.0;\n    vec2 offset1 = shadowNDCPos.xy + vec2(-twoTap.x, -twoTap.y);\n    vec2 offset2 = shadowNDCPos.xy + vec2(-oneTap.x, -twoTap.y);\n    vec2 offset3 = shadowNDCPos.xy + vec2(0.0, -twoTap.y);\n    vec2 offset4 = shadowNDCPos.xy + vec2(oneTap.x, -twoTap.y);\n    vec2 offset5 = shadowNDCPos.xy + vec2(twoTap.x, -twoTap.y);\n    vec2 offset6 = shadowNDCPos.xy + vec2(-twoTap.x, -oneTap.y);\n    vec2 offset7 = shadowNDCPos.xy + vec2(-oneTap.x, -oneTap.y);\n    vec2 offset8 = shadowNDCPos.xy + vec2(0.0, -oneTap.y);\n    vec2 offset9 = shadowNDCPos.xy + vec2(oneTap.x, -oneTap.y);\n    vec2 offset10 = shadowNDCPos.xy + vec2(twoTap.x, -oneTap.y);\n    vec2 offset11 = shadowNDCPos.xy + vec2(-twoTap.x, 0.0);\n    vec2 offset12 = shadowNDCPos.xy + vec2(-oneTap.x, 0.0);\n    vec2 offset13 = shadowNDCPos.xy + vec2(0.0, 0.0);\n    vec2 offset14 = shadowNDCPos.xy + vec2(oneTap.x, 0.0);\n    vec2 offset15 = shadowNDCPos.xy + vec2(twoTap.x, 0.0);\n    vec2 offset16 = shadowNDCPos.xy + vec2(-twoTap.x, oneTap.y);\n    vec2 offset17 = shadowNDCPos.xy + vec2(-oneTap.x, oneTap.y);\n    vec2 offset18 = shadowNDCPos.xy + vec2(0.0, oneTap.y);\n    vec2 offset19 = shadowNDCPos.xy + vec2(oneTap.x, oneTap.y);\n    vec2 offset20 = shadowNDCPos.xy + vec2(twoTap.x, oneTap.y);\n    vec2 offset21 = shadowNDCPos.xy + vec2(-twoTap.x, twoTap.y);\n    vec2 offset22 = shadowNDCPos.xy + vec2(-oneTap.x, twoTap.y);\n    vec2 offset23 = shadowNDCPos.xy + vec2(0.0, twoTap.y);\n    vec2 offset24 = shadowNDCPos.xy + vec2(oneTap.x, twoTap.y);\n    vec2 offset25 = shadowNDCPos.xy + vec2(twoTap.x, twoTap.y);\n    float block1, block2, block3, block4, block5, block6, block7, block8, block9, block10, block11, block12, block13, block14, block15, block16, block17, block18, block19, block20, block21, block22, block23, block24, block25;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block1 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset1), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset2), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset3), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset4), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset5), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset6), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset7), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset8), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block9 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset9), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block10 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset10), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block11 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset11), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block12 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset12), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block13 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset13), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block14 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset14), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block15 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset15), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block16 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset16), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block17 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset17), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block18 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset18), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block19 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset19), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block20 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset20), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block21 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset21), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block22 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset22), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block23 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset23), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block24 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset24), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block25 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset25), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block1 = step(shadowNDCPos.z, texture2D(shadowMap, offset1).x);\n      block2 = step(shadowNDCPos.z, texture2D(shadowMap, offset2).x);\n      block3 = step(shadowNDCPos.z, texture2D(shadowMap, offset3).x);\n      block4 = step(shadowNDCPos.z, texture2D(shadowMap, offset4).x);\n      block5 = step(shadowNDCPos.z, texture2D(shadowMap, offset5).x);\n      block6 = step(shadowNDCPos.z, texture2D(shadowMap, offset6).x);\n      block7 = step(shadowNDCPos.z, texture2D(shadowMap, offset7).x);\n      block8 = step(shadowNDCPos.z, texture2D(shadowMap, offset8).x);\n      block9 = step(shadowNDCPos.z, texture2D(shadowMap, offset9).x);\n      block10 = step(shadowNDCPos.z, texture2D(shadowMap, offset10).x);\n      block11 = step(shadowNDCPos.z, texture2D(shadowMap, offset11).x);\n      block12 = step(shadowNDCPos.z, texture2D(shadowMap, offset12).x);\n      block13 = step(shadowNDCPos.z, texture2D(shadowMap, offset13).x);\n      block14 = step(shadowNDCPos.z, texture2D(shadowMap, offset14).x);\n      block15 = step(shadowNDCPos.z, texture2D(shadowMap, offset15).x);\n      block16 = step(shadowNDCPos.z, texture2D(shadowMap, offset16).x);\n      block17 = step(shadowNDCPos.z, texture2D(shadowMap, offset17).x);\n      block18 = step(shadowNDCPos.z, texture2D(shadowMap, offset18).x);\n      block19 = step(shadowNDCPos.z, texture2D(shadowMap, offset19).x);\n      block20 = step(shadowNDCPos.z, texture2D(shadowMap, offset20).x);\n      block21 = step(shadowNDCPos.z, texture2D(shadowMap, offset21).x);\n      block22 = step(shadowNDCPos.z, texture2D(shadowMap, offset22).x);\n      block23 = step(shadowNDCPos.z, texture2D(shadowMap, offset23).x);\n      block24 = step(shadowNDCPos.z, texture2D(shadowMap, offset24).x);\n      block25 = step(shadowNDCPos.z, texture2D(shadowMap, offset25).x);\n    #endif\n    vec2 coef = fract(shadowNDCPos.xy * shadowMapResolution);\n    vec2 v1X1 = mix(vec2(block1, block6), vec2(block2, block7), coef.xx);\n    vec2 v1X2 = mix(vec2(block2, block7), vec2(block3, block8), coef.xx);\n    vec2 v1X3 = mix(vec2(block3, block8), vec2(block4, block9), coef.xx);\n    vec2 v1X4 = mix(vec2(block4, block9), vec2(block5, block10), coef.xx);\n    float v1 = mix(v1X1.x, v1X1.y, coef.y) + mix(v1X2.x, v1X2.y, coef.y) + mix(v1X3.x, v1X3.y, coef.y) + mix(v1X4.x, v1X4.y, coef.y);\n    vec2 v2X1 = mix(vec2(block6, block11), vec2(block7, block12), coef.xx);\n    vec2 v2X2 = mix(vec2(block7, block12), vec2(block8, block13), coef.xx);\n    vec2 v2X3 = mix(vec2(block8, block13), vec2(block9, block14), coef.xx);\n    vec2 v2X4 = mix(vec2(block9, block14), vec2(block10, block15), coef.xx);\n    float v2 = mix(v2X1.x, v2X1.y, coef.y) + mix(v2X2.x, v2X2.y, coef.y) + mix(v2X3.x, v2X3.y, coef.y) + mix(v2X4.x, v2X4.y, coef.y);\n    vec2 v3X1 = mix(vec2(block11, block16), vec2(block12, block17), coef.xx);\n    vec2 v3X2 = mix(vec2(block12, block17), vec2(block13, block18), coef.xx);\n    vec2 v3X3 = mix(vec2(block13, block18), vec2(block14, block19), coef.xx);\n    vec2 v3X4 = mix(vec2(block14, block19), vec2(block15, block20), coef.xx);\n    float v3 = mix(v3X1.x, v3X1.y, coef.y) + mix(v3X2.x, v3X2.y, coef.y) + mix(v3X3.x, v3X3.y, coef.y) + mix(v3X4.x, v3X4.y, coef.y);\n    vec2 v4X1 = mix(vec2(block16, block21), vec2(block17, block22), coef.xx);\n    vec2 v4X2 = mix(vec2(block17, block22), vec2(block18, block23), coef.xx);\n    vec2 v4X3 = mix(vec2(block18, block23), vec2(block19, block24), coef.xx);\n    vec2 v4X4 = mix(vec2(block19, block24), vec2(block20, block25), coef.xx);\n    float v4 = mix(v4X1.x, v4X1.y, coef.y) + mix(v4X2.x, v4X2.y, coef.y) + mix(v4X3.x, v4X3.y, coef.y) + mix(v4X4.x, v4X4.y, coef.y);\n    float fAvg = (v1 + v2 + v3 + v4) * 0.0625;\n    return fAvg;\n  }\n  bool GetShadowNDCPos(out vec3 shadowNDCPos, vec4 shadowPosWithDepthBias)\n  {\n  \tshadowNDCPos = shadowPosWithDepthBias.xyz / shadowPosWithDepthBias.w * 0.5 + 0.5;\n  \tif (shadowNDCPos.x < 0.0 || shadowNDCPos.x > 1.0 ||\n  \t\tshadowNDCPos.y < 0.0 || shadowNDCPos.y > 1.0 ||\n  \t\tshadowNDCPos.z < 0.0 || shadowNDCPos.z > 1.0) {\n  \t\treturn false;\n  \t}\n  \tshadowNDCPos.xy = cc_cameraPos.w == 1.0 ? vec2(shadowNDCPos.xy.x, 1.0 - shadowNDCPos.xy.y) : shadowNDCPos.xy;\n  \treturn true;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, vec3 matViewDir0, vec3 matViewDir1, vec3 matViewDir2, vec2 projScaleXY)\n  {\n    vec4 newShadowPos = shadowPos;\n    if (normalBias > EPSILON_LOWP)\n    {\n      vec3 viewNormal = vec3(dot(matViewDir0, worldNormal), dot(matViewDir1, worldNormal), dot(matViewDir2, worldNormal));\n      if (viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, mat4 matLightView, vec2 projScaleXY)\n  {\n  \tvec4 newShadowPos = shadowPos;\n  \tif (normalBias > EPSILON_LOWP)\n  \t{\n  \t\tvec4 viewNormal = matLightView * vec4(worldNormal, 0.0);\n  \t\tif (viewNormal.z < 0.1)\n  \t\t\tnewShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n  \t}\n  \treturn newShadowPos;\n  }\n  float GetViewSpaceDepthFromNDCDepth_Orthgraphic(float NDCDepth, float projScaleZ, float projBiasZ)\n  {\n  \treturn (NDCDepth - projBiasZ) / projScaleZ;\n  }\n  float GetViewSpaceDepthFromNDCDepth_Perspective(float NDCDepth, float homogenousDividW, float invProjScaleZ, float invProjBiasZ)\n  {\n  \treturn NDCDepth * invProjScaleZ + homogenousDividW * invProjBiasZ;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n  \tvec3 viewSpacePos;\n  \tviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n  \tviewSpacePos.z = GetViewSpaceDepthFromNDCDepth_Perspective(shadowPos.z, shadowPos.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n  \tviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n  \tvec4 clipSpacePos;\n  \tclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n  \tclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n  \t#if CC_SHADOWMAP_USE_LINEAR_DEPTH\n  \t\tclipSpacePos.z = GetLinearDepthFromViewSpace(viewSpacePos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n  \t\tclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n  \t#endif\n  \treturn clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias, float projScaleZ, float projBiasZ)\n  {\n  \tfloat coeffA = projScaleZ;\n  \tfloat coeffB = projBiasZ;\n  \tfloat viewSpacePos_z = GetViewSpaceDepthFromNDCDepth_Orthgraphic(shadowPos.z, projScaleZ, projBiasZ);\n  \tviewSpacePos_z += viewspaceDepthBias;\n  \tvec4 result = shadowPos;\n  \tresult.z = viewSpacePos_z * coeffA + coeffB;\n  \treturn result;\n  }\n  vec4 ApplyShadowDepthBias_PerspectiveLinearDepth(vec4 shadowPos, float viewspaceDepthBias, vec3 worldPos)\n  {\n    shadowPos.z = CCGetLinearDepth(worldPos, viewspaceDepthBias) * 2.0 - 1.0;\n    shadowPos.z *= shadowPos.w;\n    return shadowPos;\n  }\n  float CCGetDirLightShadowFactorHard (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCSpotShadowFactorBase(out vec4 shadowNDCPosWithBias, vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    float pcf = cc_shadowWHPBInfo.z;\n    vec4 pos = vec4(1.0);\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      pos = ApplyShadowDepthBias_PerspectiveLinearDepth(shadowPos, shadowBias.x, worldPos);\n    #else\n      pos = ApplyShadowDepthBias_Perspective(shadowPos, shadowBias.x);\n    #endif\n    float realtimeShadow = 1.0;\n    if (pcf > 2.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft5X(pos, worldPos);\n    }else if (pcf > 1.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft3X(pos, worldPos);\n    }else if (pcf > 0.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft(pos, worldPos);\n    }else {\n      realtimeShadow = CCGetSpotLightShadowFactorHard(pos, worldPos);\n    }\n    shadowNDCPosWithBias = pos;\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  float CCShadowFactorBase(out vec4 shadowNDCPosWithBias, vec4 shadowPos, vec3 N, vec2 shadowBias)\n  {\n    vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y, cc_matLightView, cc_shadowProjInfo.xy);\n    pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, cc_shadowProjDepthInfo.x, cc_shadowProjDepthInfo.y);\n    float realtimeShadow = 1.0;\n    #if CC_DIR_SHADOW_PCF_TYPE == 3\n      realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 2\n      realtimeShadow =  CCGetDirLightShadowFactorSoft3X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 1\n      realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 0\n      realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n    #endif\n    shadowNDCPosWithBias = pos;\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n    bool CCGetCSMLevelWithTransition(out highp float ratio, vec3 clipPos) {\n      highp float maxRange = 1.0 - cc_csmSplitsInfo.x;\n      highp float minRange = cc_csmSplitsInfo.x;\n      highp float thresholdInvert = 1.0 / cc_csmSplitsInfo.x;\n      ratio = 0.0;\n      if (clipPos.x <= minRange) {\n        ratio = clipPos.x * thresholdInvert;\n        return true;\n      }\n      if (clipPos.x >= maxRange) {\n        ratio = 1.0 - (clipPos.x - maxRange) * thresholdInvert;\n        return true;\n      }\n      if (clipPos.y <= minRange) {\n        ratio = clipPos.y  * thresholdInvert;\n        return true;\n      }\n      if (clipPos.y >= maxRange) {\n        ratio = 1.0 - (clipPos.y - maxRange) * thresholdInvert;\n        return true;\n      }\n      return false;\n    }\n    bool CCHasCSMLevel(int level, vec3 worldPos) {\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      bool hasLevel = false;\n      for (int i = 0; i < 4; i++) {\n        if (i == level) {\n          vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n          if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n              clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n              clipPos.z >= 0.0 && clipPos.z <= 1.0) {\n            hasLevel = true;\n          }\n        }\n      }\n      return hasLevel;\n    }\n    void CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos, int level) {\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && i == level) {\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n        }\n      }\n    }\n    int CCGetCSMLevel(out bool isTransitionArea, out highp float transitionRatio, out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n    {\n      int level = -1;\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && level < 0) {\n          #if CC_CASCADED_LAYERS_TRANSITION\n            isTransitionArea = CCGetCSMLevelWithTransition(transitionRatio, clipPos);\n          #endif\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n          level = i;\n        }\n      }\n      return level;\n    }\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n    {\n      bool isTransitionArea = false;\n      highp float transitionRatio = 0.0;\n      return CCGetCSMLevel(isTransitionArea, transitionRatio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n    }\n    float CCCSMFactorBase(out vec4 csmPos, out vec4 csmNDCPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias)\n    {\n      bool isTransitionArea = false;\n      highp float ratio = 0.0;\n      csmPos = vec4(1.0);\n      vec4 shadowProjDepthInfo, shadowProjInfo;\n      vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n      int level = -1;\n      #if CC_CASCADED_LAYERS_TRANSITION\n        level = CCGetCSMLevel(isTransitionArea, ratio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      #else\n        level = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      #endif\n      if (level < 0) { return 1.0; }\n      vec4 pos = ApplyShadowDepthBias_FaceNormal(csmPos, N, shadowBias.y, shadowViewDir0, shadowViewDir1, shadowViewDir2, shadowProjInfo.xy);\n      pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n      csmNDCPosWithBias = pos;\n      float realtimeShadow = 1.0;\n      #if CC_DIR_SHADOW_PCF_TYPE == 3\n        realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 2\n        realtimeShadow = CCGetDirLightShadowFactorSoft3X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 1\n        realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 0\n        realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n      #endif\n      #if CC_CASCADED_LAYERS_TRANSITION\n        vec4 nextCSMPos = vec4(1.0);\n        vec4 nextShadowProjDepthInfo, nextShadowProjInfo;\n        vec3 nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2;\n        float nextRealtimeShadow = 1.0;\n        CCGetCSMLevel(nextCSMPos, nextShadowProjDepthInfo, nextShadowProjInfo, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, worldPos, level + 1);\n        bool hasNextLevel = CCHasCSMLevel(level + 1, worldPos);\n        if (hasNextLevel && isTransitionArea) {\n          vec4 nexPos = ApplyShadowDepthBias_FaceNormal(nextCSMPos, N, shadowBias.y, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, nextShadowProjInfo.xy);\n          nexPos = ApplyShadowDepthBias_Orthographic(nexPos, shadowBias.x, nextShadowProjDepthInfo.x, nextShadowProjDepthInfo.y);\n          #if CC_DIR_SHADOW_PCF_TYPE == 3\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft5X(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 2\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft3X(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 1\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 0\n            nextRealtimeShadow = CCGetDirLightShadowFactorHard(nexPos);\n          #endif\n          return mix(mix(nextRealtimeShadow, realtimeShadow, ratio), 1.0, cc_shadowNFLSInfo.w);\n        }\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      #else\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      #endif\n    }\n  #else\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos) {\n      return -1;\n    }\n    float CCCSMFactorBase(out vec4 csmPos, out vec4 csmNDCPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias) {\n      csmPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n      return CCShadowFactorBase(csmNDCPosWithBias, csmPos, N, shadowBias);\n    }\n  #endif\n  float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias) {\n    vec4 shadowNDCPosWithBias;\n    return CCShadowFactorBase(shadowNDCPosWithBias, shadowPos, N, shadowBias);\n  }\n  float CCCSMFactorBase(vec3 worldPos, vec3 N, vec2 shadowBias) {\n    vec4 csmPos, csmNDCPosWithBias;\n    return CCCSMFactorBase(csmPos, csmNDCPosWithBias, worldPos, N, shadowBias);\n  }\n  float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    vec4 shadowNDCPosWithBias;\n    return CCSpotShadowFactorBase(shadowNDCPosWithBias, shadowPos, worldPos, shadowBias);\n  }\n#endif\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n\tcolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if CC_USE_LIGHT_PROBE\n  #if CC_USE_LIGHT_PROBE\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  uniform sampler2D cc_lightingMap;\n  void SampleAndDecodeLightMapColor(out vec3 lightmapColor, out float dirShadow, out float ao, sampler2D lightingMap, vec2 luv, float lum, vec3 worldNormal)\n  {\n  #if CC_LIGHT_MAP_VERSION > 2\n  #elif CC_LIGHT_MAP_VERSION > 1\n  \tvec4 dataLow = texture2D(lightingMap, luv);\n  \tvec4 dataHigh = texture2D(lightingMap, luv + vec2(0.5, 0.0));\n  \tlightmapColor.xyz = dataLow.xyz + dataHigh.xyz * 0.00392156862745098;\n      lightmapColor.rgb *= lum;\n  \tdirShadow = dataLow.a;\n  \tao = dataHigh.a;\n  #else\n      vec4 lightmap = texture2D(lightingMap, luv);\n      lightmapColor = lightmap.rgb * lum;\n  \tdirShadow = lightmap.a;\n  \tao = 1.0;\n  #endif\n  }\n  void GetLightMapColor(out vec3 lightmapColor, out float dirShadow, out float ao, sampler2D lightingMap, vec2 luv, float lum, vec3 worldNormal)\n  {\n  \tvec4 lightmap;\n  \tvec2 occlusion;\n  \tSampleAndDecodeLightMapColor(lightmapColor, dirShadow, ao, lightingMap, luv, lum, worldNormal);\n  #if CC_USE_HDR\n      lightmapColor.rgb *= cc_exposure.w * cc_exposure.x;\n  #endif\n  }\n#endif\n    uniform vec4 baseColor;\n    uniform vec4 colorScaleAndCutoff;\n    uniform vec4 shadeColor1;\n    uniform vec4 shadeColor2;\n    uniform vec4 specular;\n    uniform vec4 shadeParams;\n    uniform vec4 miscParams;\n    uniform vec4 emissive;\n    uniform vec4 emissiveScaleAndStrenth;\n#if USE_BASE_COLOR_MAP\n  uniform sampler2D baseColorMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#if USE_1ST_SHADE_MAP\n  uniform sampler2D shadeMap1;\n#endif\n#if USE_2ND_SHADE_MAP\n  uniform sampler2D shadeMap2;\n#endif\n#if USE_SPECULAR_MAP\n  uniform sampler2D specularMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\n#define CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TOONSHADE\nvoid SurfacesFragmentModifyBaseColorAndToonShade(out vec4 baseColorAndTransparency, out vec3 shade1, out vec3 shade2)\n{\n  shade2 = shadeColor2.rgb * colorScaleAndCutoff.rgb;\n  #if USE_2ND_SHADE_MAP\n    shade2 *= SRGBToLinear(texture2D(shadeMap2, FSInput_texcoord).rgb);\n  #endif\n  shade1 = shadeColor1.rgb * colorScaleAndCutoff.rgb;\n  #if USE_1ST_SHADE_MAP\n    shade1 *= SRGBToLinear(texture2D(shadeMap1, FSInput_texcoord).rgb);\n    #if SHADE_MAP_1_AS_SHADE_MAP_2\n      shade2 *= shade1.rgb;\n    #endif\n  #endif\n  vec4 color = baseColor;\n  #if USE_BASE_COLOR_MAP\n    vec4 texColor = texture2D(baseColorMap, FSInput_texcoord);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    color *= texColor;\n    #if BASE_COLOR_MAP_AS_SHADE_MAP_1\n      shade1 *= texColor.rgb;\n    #endif\n    #if BASE_COLOR_MAP_AS_SHADE_MAP_2\n      shade2 *= texColor.rgb;\n    #endif\n  #endif\n  baseColorAndTransparency = color;\n  baseColorAndTransparency.rgb *= colorScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (baseColorAndTransparency.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n}\n#define CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n#define CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\nvec3 SurfacesFragmentModifyWorldNormal()\n{\n  vec3 normal = FSInput_worldNormal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, FSInput_texcoord).xyz - vec3(0.5);\n    normal = CalculateNormalFromTangentSpace(nmmp, emissiveScaleAndStrenth.w, normal.xyz, FSInput_worldTangent, FSInput_mirrorNormal);\n  #endif\n  return normalize(normal);\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\nvec3 SurfacesFragmentModifyEmissive()\n{\n  vec3 emissive = emissive.rgb * emissiveScaleAndStrenth.xyz;\n  #if USE_EMISSIVE_MAP\n    emissive *= SRGBToLinear(texture2D(emissiveMap, FSInput_texcoord).rgb);\n  #endif\n  return emissive;\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_TOON_STEP_AND_FEATHER\nvec4 SurfacesFragmentModifyToonStepAndFeather()\n{\n  return shadeParams;\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_TOON_SHADOW_COVER\nfloat SurfacesFragmentModifyToonShadowCover()\n{\n    return miscParams.x;\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_TOON_SPECULAR\nvec4 SurfacesFragmentModifyToonSpecular()\n{\n  vec4 specularParam = specular;\n  #if USE_SPECULAR_MAP\n    specularParam.rgb *= SRGBToLinear(texture2D(specularMap, FSInput_texcoord).rgb);\n  #endif\n  return specularParam;\n}\nstruct LightingIntermediateData\n{\n  vec3 N, H, L, V;\n  float distToLight, distToLightSqr;\n  float distToCamera, distToCameraSqr;\n  float NoL, NoV, NoH;\n  float NoLSat, NoVSat, NoHSat;\n  float NoVAbsSat;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPosition, worldPosition_fract_part;\n  #else\n  vec3 worldPosition;\n  #endif\n  vec3 T, B;\n  float specularParam;\n  float ior;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 shadowPosAndDepth;\n  vec4 transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 transmitParams;\n  vec3 inScatteringLightColor;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 baseColorTT;\n  float ttIntensity, ttScatterCoef;\n#endif\n};\nvoid CCSurfacesLightingGetIntermediateData_PerPixel(inout LightingIntermediateData data, vec3 worldNormal, vec3 worldPos, vec3 worldTangent, vec3 worldBinormal\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n    , float anisotropyShape\n#endif\n)\n{\n  data.N = worldNormal;\n  data.V = cc_cameraPos.xyz - worldPos;\n  data.distToCameraSqr = dot(data.V, data.V);\n  data.distToCamera = sqrt(data.distToCameraSqr);\n  data.V /= data.distToCamera;\n  data.NoV = dot(data.N, data.V);\n  data.NoVSat = max(data.NoV, 0.0);\n  data.NoVAbsSat = max(abs(data.NoV), 0.0);\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(data.worldPosition, data.worldPosition_fract_part, worldPos);\n  #else\n  data.worldPosition = worldPos;\n  #endif\n  data.T = worldTangent;\n  data.B = worldBinormal;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  data.anisotropyShape = anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  data.inScatteringLightColor = vec3(0.0);\n  data.transmitParams = vec4(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  data.shadowPosAndDepth = vec4(0.0, 0.0, 999999.0, 999999.0);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  data.baseColorTT = vec3(0.0);\n  data.ttIntensity = data.ttScatterCoef = 0.0;\n#endif\n}\nvoid CCSurfacesLightingGetIntermediateData_PerLight(inout LightingIntermediateData data, vec3 lightDirWithDist)\n{\n  data.L = lightDirWithDist;\n  data.distToLightSqr = dot(data.L, data.L);\n  data.distToLight = sqrt(data.distToLightSqr);\n  data.L /= data.distToLight;\n  data.H = normalize(data.L + data.V);\n  data.NoL = dot(data.N, data.L);\n  data.NoH = dot(data.N, data.H);\n  data.NoLSat = max(data.NoL, 0.0);\n  data.NoHSat = max(data.NoH, 0.0);\n}\nstruct LightingResult\n{\n  vec3 diffuseColorWithLighting, specularColorWithLighting;\n  vec3 directDiffuse, directSpecular;\n  vec3 environmentDiffuse, environmentSpecular;\n  float shadow, ao;\n  vec3 lightmapColor;\n  vec3 emissive;\n#if CC_SURFACES_LIGHTING_USE_FRESNEL\n  float fresnel;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  vec3 directTransmitSpecular, environmentTransmitSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec3 directTransmitDiffuse, environmentTransmitDiffuse;\n#endif\n#if CC_SURFACES_LIGHTING_TRT\n  vec3 directTRT, environmentTRT;\n  vec3 specularColorWithLightingTRT;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 directTT;\n  vec3 diffuseColorWithLightingTT;\n#endif\n};\nstruct LightingMiscData\n{\n  float lightType;\n  vec3 lightPos, lightDir;\n  vec4 lightColorAndIntensity;\n  vec4 lightSizeRangeAngle;\n};\n#define DiffuseCoefficient_EnergyConservation INV_PI\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\nfloat CalculateDistanceAttenuation(float distToLightSqr, float lightRadius, float lightRange)\n{\n  float litRadiusSqr = lightRadius * lightRadius;\n  float attRadiusSqrInv = 1.0 / max(lightRange, 0.01);\n  attRadiusSqrInv *= attRadiusSqrInv;\n  float edgeAttenuation = litRadiusSqr / max(litRadiusSqr, distToLightSqr);\n  return GetDistAtt(distToLightSqr, attRadiusSqrInv) * edgeAttenuation;\n}\nfloat CalculateAngleAttenuation(vec3 spotLightDir, vec3 L, float cosAngleOuter)\n{\n  float cosInner = max(dot(spotLightDir, L), 0.01);\n  float litAngleScale = 1.0 / max(0.001, cosInner - cosAngleOuter);\n  float litAngleOffset = -cosAngleOuter * litAngleScale;\n  return GetAngleAtt(L, spotLightDir, litAngleScale, litAngleOffset);\n}\nbool CCSurfacesLightingEnableShadow(in float NoL)\n{\n  return NoL > 0.0;\n}\nfloat CCSurfacesLightingCalculateDistanceAttenuation(in LightingIntermediateData lightingData, in vec4 lightSizeRangeAngle)\n{\n  return CalculateDistanceAttenuation(lightingData.distToLightSqr, lightSizeRangeAngle.x, lightSizeRangeAngle.y);\n}\nfloat CCSurfacesLightingCalculateAngleAttenuation(in LightingIntermediateData lightingData, in vec4 lightSizeRangeAngle, in vec3 spotLightDir)\n{\n  return CalculateAngleAttenuation(spotLightDir, lightingData.L, lightSizeRangeAngle.z);\n}\nvoid CCSurfacesLightingCalculateDirect(out vec3 lightingDiffuse, out vec3 lightingSpecular, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n    vec3 irradiance = lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    lightingDiffuse = irradiance;\n#if CC_FORWARD_ADD || CC_ENABLE_CLUSTERED_LIGHT_CULLING\n    float NL = 0.5 * lightingData.NoL + 0.5;\n    lightingDiffuse *= NL;\n#endif\n    float NH = 0.5 * lightingData.NoH + 0.5;\n    float specularWeight = 1.0 - pow(lightingData.specularParam, 5.0);\n    float specularMask = step(specularWeight + EPSILON_LOWP, NH);\n    lightingSpecular = irradiance * specularMask;\n}\nvoid CCSurfacesLightingCalculateEnvironment(out vec3 lightingDiffuse, out vec3 lightingSpecular, in LightingIntermediateData lightingData, float lightIntensity)\n{\n  lightingDiffuse = vec3(0.0);\n  lightingSpecular = vec3(0.0);\n}\nstruct SurfacesMaterialData\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPos, worldPos_fract_part;\n  #else\n  vec3 worldPos;\n  #endif\n  vec4 baseColor;\n  vec4 specular;\n  vec3 worldNormal;\n  vec3 emissive;\n  vec3 shade1;\n  vec3 shade2;\n  float baseStep;\n  float baseFeather;\n  float shadeStep;\n  float shadeFeather;\n  float shadowCover;\n};\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\nvec4 SurfacesFragmentModifyBaseColorAndTransparency()\n{\n    return FSInput_vertexColor;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\nvec3 SurfacesFragmentModifyWorldNormal()\n{\n    return normalize(FSInput_worldNormal);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_WORLD_TANGENT_AND_BINORMAL\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_IOR\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_ANISOTROPY_PARAMS\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\nvec3 SurfacesFragmentModifyEmissive()\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_PARAMS\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_DIFFUSE_PARAMS\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRT_PARAMS\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRT_COLOR\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TT_PARAMS\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TT_COLOR\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_SHARED_DATA\nvoid SurfacesFragmentModifySharedData(inout SurfacesMaterialData surfaceData)\n{\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TOONSHADE\nvoid SurfacesFragmentModifyBaseColorAndToonShade(out vec4 baseColorAndTransparency, out vec3 shade1, out vec3 shade2, in vec3 baseColor)\n{\n    baseColorAndTransparency = FSInput_vertexColor;\n    shade1 = shade2 = vec3(0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TOON_STEP_AND_FEATHER\nvec4 SurfacesFragmentModifyToonStepAndFeather()\n{\n    return vec3(0.8, 0.001, 0.5, 0.001);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TOON_SHADOW_COVER\nfloat SurfacesFragmentModifyToonShadowCover()\n{\n    return 0.5;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TOON_SPECULAR\nvec4 SurfacesFragmentModifyToonSpecular()\n{\n    return vec4(1.0, 1.0, 1.0, 0.3);\n}\n#endif\nvoid CCSurfacesFragmentGetMaterialData(inout SurfacesMaterialData surfaceData)\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part, FSInput_worldPos);\n  #else\n  surfaceData.worldPos = FSInput_worldPos;\n  #endif\n  surfaceData.worldNormal = SurfacesFragmentModifyWorldNormal();\n  surfaceData.emissive = SurfacesFragmentModifyEmissive();\n  SurfacesFragmentModifyBaseColorAndToonShade(surfaceData.baseColor, surfaceData.shade1, surfaceData.shade2);\n  surfaceData.specular = SurfacesFragmentModifyToonSpecular();\n  surfaceData.shadowCover = SurfacesFragmentModifyToonShadowCover();\n  vec4 shaderParams = SurfacesFragmentModifyToonStepAndFeather();\n  surfaceData.baseStep = shadeParams.x;\n  surfaceData.baseFeather = shadeParams.y;\n  surfaceData.shadeStep = shadeParams.z;\n  surfaceData.shadeFeather = shadeParams.w;\n  SurfacesFragmentModifySharedData(surfaceData);\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP)\n    surfaceData.worldNormal = FSInput_worldNormal;\n#endif\n#if CC_USE_DEBUG_VIEW\n  if (!IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO) {\n      float brightBase = dot(GRAY_VECTOR, surfaceData.baseColor.rgb);\n      float brightShade1 = dot(GRAY_VECTOR, surfaceData.shade1.rgb);\n      float brightShade2 = dot(GRAY_VECTOR, surfaceData.shade2.rgb);\n      surfaceData.baseColor.rgb = vec3(1.0);\n      surfaceData.shade1.rgb = vec3(brightShade1 / brightBase);\n      surfaceData.shade2.rgb = vec3(brightShade2 / brightBase);\n      surfaceData.specular.rgb = vec3(1.0);\n  }\n#endif\n}\nvec3 CCSurfacesGetDiffuseColor(in SurfacesMaterialData surfaceData)\n{\n  return surfaceData.shade1;\n}\nvec3 CCSurfacesGetSpecularColor(in SurfacesMaterialData surfaceData)\n{\n  return surfaceData.specular.xyz;\n}\nvoid CCSurfacesLightingInitializeColorWithLighting(inout vec3 diffuseColorWithLighting, inout vec3 specularColorWithLighting, in SurfacesMaterialData surfaceData, in LightingIntermediateData lightingData)\n{\n  specularColorWithLighting = surfaceData.specular.xyz * surfaceData.baseStep;\n}\nvoid CCSurfacesLightingCalculateColorWithLighting(inout vec3 diffuseColorWithLighting, inout vec3 specularColorWithLighting, in SurfacesMaterialData surfaceData, in LightingIntermediateData lightingData)\n{\n  float NL = 0.5 * lightingData.NoL + 0.5;\n  vec3 diffuse = mix(surfaceData.shade1, surfaceData.shade2,\n    clamp(1.0 + (surfaceData.shadeStep - surfaceData.shadeFeather - NL) / surfaceData.shadeFeather, 0.0, 1.0));\n  diffuse = mix(surfaceData.baseColor.rgb, diffuse,\n    clamp(1.0 + (surfaceData.baseStep - surfaceData.baseFeather - NL) / surfaceData.baseFeather, 0.0, 1.0));\n  diffuseColorWithLighting = diffuse * surfaceData.baseStep;\n}\nvoid CCSurfacesInitializeLightingIntermediateData(inout LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData)\n{\n  vec3 worldPos;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n  #else\n  worldPos = surfaceData.worldPos;\n  #endif\n  CCSurfacesLightingGetIntermediateData_PerPixel(lightingData, surfaceData.worldNormal, worldPos, vec3(0.0), vec3(0.0));\n  lightingData.specularParam = surfaceData.specular.a;\n  lightingData.ior = 1.0;\n}\nvoid CCSurfacesLightingCalculateIntermediateData_PerLight(inout LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData, vec3 lightDirWithDist)\n{\n  CCSurfacesLightingGetIntermediateData_PerLight(lightingData, lightDirWithDist);\n}\nvoid CCSurfacesInitializeLightingResult(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData)\n{\n  lightingResult.emissive = surfaceData.emissive;\n}\nvoid CCSurfacesInitializeLightingResult(inout LightingResult lightingResult)\n{\n  lightingResult.directDiffuse = lightingResult.directSpecular = vec3(0.0);\n}\nvoid CCSurfacesAccumulateLightingResult(inout LightingResult lightingResultAccumulated, in LightingResult lightingResult)\n{\n  lightingResultAccumulated.directDiffuse += lightingResult.directDiffuse * lightingResult.shadow;\n  lightingResultAccumulated.directSpecular += lightingResult.directSpecular * lightingResult.shadow;\n}\n#if CC_PIPELINE_TYPE == 1\n  vec4 CCSurfacesDeferredOutput0(in SurfacesMaterialData surfaceData)\n  {\n    return surfaceData.baseColor;\n  }\n  vec4 CCSurfacesDeferredOutput1(in SurfacesMaterialData surfaceData)\n  {\n    return vec4(float32x3_to_oct(surfaceData.worldNormal), 0.5, 0.0);\n  }\n  vec4 CCSurfacesDeferredOutput2(in SurfacesMaterialData surfaceData)\n  {\n    return vec4(surfaceData.emissive, 1.0);\n  }\n#endif\nvec4 CCSurfacesShading(in SurfacesMaterialData surfaceData, in LightingResult lightingResult)\n{\n  vec4 color = vec4(0.0, 0.0, 0.0, surfaceData.baseColor.a);\n#if CC_FORWARD_ADD\n  color.xyz += lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting;\n  color.xyz += lightingResult.directSpecular * lightingResult.specularColorWithLighting;\n#else\n  float lightmapCoef = 0.0;\n#if CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  color.xyz += (\n    mix(lightingResult.directDiffuse, lightingResult.lightmapColor, lightmapCoef) * lightingResult.diffuseColorWithLighting\n    + lightingResult.directSpecular * lightingResult.specularColorWithLighting)\n    * lightingResult.shadow\n    ;\n#else\n  LightingIntermediateData lightingData;\n  lightingData.NoL = -1.0;\n  vec3 backLightingDiffuse, backLightingSpecular;\n  CCSurfacesLightingCalculateColorWithLighting(backLightingDiffuse, backLightingSpecular, surfaceData, lightingData);\n  color.xyz +=\n    mix(lightingResult.directDiffuse, lightingResult.lightmapColor, lightmapCoef) * mix(backLightingDiffuse, lightingResult.diffuseColorWithLighting, lightingResult.shadow)\n    + lightingResult.directSpecular * lightingResult.specularColorWithLighting * lightingResult.shadow\n    ;\n#endif\n  color.xyz += lightingResult.emissive;\n#endif\n  return color;\n}\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE\nvoid CCSurfacesDebugViewSurfaceData(inout vec4 color, in SurfacesMaterialData surfaceData)\n{\n    float scalar;\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(surfaceData.worldNormal * 0.5 + vec3(0.5), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(0.0, 0.0, 0.0, 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(0.0, 0.0, 0.0, 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSPARENCY)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        scalar = surfaceData.baseColor.a;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_BASE_COLOR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(surfaceData.baseColor.rgb), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(CCSurfacesGetDiffuseColor(surfaceData)), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(CCSurfacesGetSpecularColor(surfaceData)), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        scalar = surfaceData.specular.a;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n}\n#endif\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD && !CC_ENABLE_CLUSTERED_LIGHT_CULLING\n    void CCSurfacesLighting(inout LightingResult lightingResultAccumulated, in SurfacesMaterialData surfaceData, in vec2 shadowBias)\n    {\n      vec3 worldPos;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n      #else\n      worldPos = surfaceData.worldPos;\n      #endif\n      CCSurfacesInitializeLightingResult(lightingResultAccumulated);\n      LightingIntermediateData lightingData;\n      CCSurfacesInitializeLightingIntermediateData(lightingData, surfaceData);\n      LightingResult lightingResult;\n      CCSurfacesLightingInitializeColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, surfaceData, lightingData);\n      lightingResultAccumulated.diffuseColorWithLighting = lightingResult.diffuseColorWithLighting;\n      lightingResultAccumulated.specularColorWithLighting = lightingResult.specularColorWithLighting;\n      #if CC_SURFACES_LIGHTING_TRT\n        vec3 diff;\n        SurfacesMaterialData surfaceDataTRT;\n        CCSurfacesGetSurfacesMaterialDataTRT(surfaceDataTRT, surfaceData);\n        CCSurfacesLightingInitializeColorWithLighting(diff, lightingResultAccumulated.specularColorWithLightingTRT, surfaceDataTRT, lightingData);\n      #endif\n      int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n      for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n        if (i >= numLights) break;\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData, surfaceData, cc_lightPos[i].xyz - worldPos);\n        CCSurfacesLightingCalculateColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, surfaceData, lightingData);\n        vec3 diffuseLighting, specularLighting;\n        CCSurfacesLightingCalculateDirect(diffuseLighting, specularLighting, lightingData, cc_lightColor[i]);\n        float fresnel = 1.0;\n      #if CC_SURFACES_LIGHTING_USE_FRESNEL\n        fresnel = lightingResult.fresnel = CCSurfaceLightingCalculateFresnel(lightingData);\n      #endif\n        float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          vec4 shadowPos = vec4(0.0), shadowNDCPosWithBias = vec4(0.0);\n          if (CCSurfacesLightingEnableShadow(lightingData.NoL)) {\n            shadowPos = cc_matLightViewProj * vec4(surfaceData.worldPos, 1.0);\n            shadow = CCSpotShadowFactorBase(shadowNDCPosWithBias, shadowPos, worldPos, shadowBias);\n          }\n          #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n            #if CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n              lightingData.shadowPosAndDepth.xy = shadowNDCPosWithBias.xy;\n              lightingData.shadowPosAndDepth.z = shadowPos.z;\n              lightingData.shadowPosAndDepth.w = GetViewSpaceDepthFromNDCDepth_Perspective(SampleShadowMap(shadowNDCPosWithBias.xyz, cc_spotShadowMap), shadowNDCPosWithBias.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n            #else\n              lightingData.transmitDiffuseParams.zw = vec2(0.0);\n            #endif\n          #endif\n        }\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW) {\n          shadow = 1.0;\n        }\n      #endif\n        lightingResult.shadow = shadow;\n        float distAtt = CCSurfacesLightingCalculateDistanceAttenuation(lightingData, cc_lightSizeRangeAngle[i]);\n        float angleAtt = 1.0;\n        if (cc_lightPos[i].w > 0.0) {\n          angleAtt = CCSurfacesLightingCalculateAngleAttenuation(lightingData, cc_lightSizeRangeAngle[i], -cc_lightDir[i].xyz);\n        }\n        float multiplier = distAtt * angleAtt;\n        lightingResult.directDiffuse = diffuseLighting * multiplier;\n        lightingResult.directSpecular = specularLighting * multiplier * fresnel;\n        #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n          vec3 transmitSpecularLighting;\n          CCSurfacesLightingCalculateDirectTransmitSpecular(transmitSpecularLighting, lightingData, cc_lightColor[i]);\n          lightingResult.directTransmitSpecular = transmitSpecularLighting * multiplier * (1.0 - fresnel);\n        #endif\n        #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n          lightingResult.directTransmitDiffuse = CCSurfacesLightingCalculateDirectTransmitDiffuse(lightingResult, lightingData, cc_lightColor[i]);\n        #endif\n        #if CC_SURFACES_LIGHTING_TRT\n          LightingIntermediateData lightingDataTRT;\n          CCSurfacesGetLightingIntermediateDataTRT(lightingDataTRT, lightingData, surfaceData);\n          CCSurfacesLightingCalculateDirectTRT(lightingResult.directTRT, lightingDataTRT, cc_lightColor[i]);\n          lightingResult.directTRT *= multiplier * fresnel;\n        #endif\n        #if CC_SURFACES_LIGHTING_TT\n          CCSurfacesLightingCalculateDirectTT(lightingResult, lightingData, cc_lightColor[i]);\n        #endif\n        #ifdef CC_SURFACES_LIGHTING_MODIFY_FINAL_RESULT\n          LightingMiscData miscData;\n          miscData.lightType = cc_lightPos[i].w;\n          miscData.lightPos = cc_lightPos[i].xyz;\n          miscData.lightDir = cc_lightDir[i].xyz;\n          miscData.lightColorAndIntensity = cc_lightColor[i];\n          miscData.lightSizeRangeAngle = cc_lightSizeRangeAngle[i];\n          SurfacesLightingModifyFinalResult(lightingResult, lightingData, surfaceData, miscData);\n        #endif\n        CCSurfacesAccumulateLightingResult(lightingResultAccumulated, lightingResult);\n      }\n    }\n  #else\n    void CCSurfacesLighting(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData, in vec2 shadowBias)\n    {\n      LightingIntermediateData lightingData;\n      CCSurfacesInitializeLightingIntermediateData(lightingData, surfaceData);\n      CCSurfacesInitializeLightingResult(lightingResult, surfaceData);\n      CCSurfacesLightingInitializeColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, surfaceData, lightingData);\n      CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData, surfaceData, -cc_mainLitDir.xyz);\n      lightingResult.shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (cc_mainLitDir.w > 0.0) {\n          vec4 shadowPos = vec4(0.0), shadowNDCPosWithBias = vec4(0.0);\n          if (CCSurfacesLightingEnableShadow(lightingData.NoL)) {\n            #if CC_DIR_LIGHT_SHADOW_TYPE == 2\n              lightingResult.shadow = CCCSMFactorBase(shadowPos, shadowNDCPosWithBias, surfaceData.worldPos, lightingData.N, shadowBias);\n            #endif\n            #if CC_DIR_LIGHT_SHADOW_TYPE == 1\n              shadowPos = cc_matLightViewProj * vec4(surfaceData.worldPos, 1.0);\n              lightingResult.shadow = CCShadowFactorBase(shadowPos, lightingData.N, shadowBias);\n            #endif\n          }\n          #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n            #if CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n              lightingData.shadowPosAndDepth.xy = shadowNDCPosWithBias.xy;\n              lightingData.shadowPosAndDepth.z = shadowPos.z;\n              lightingData.shadowPosAndDepth.w = GetViewSpaceDepthFromNDCDepth_Orthgraphic(SampleShadowMap(shadowNDCPosWithBias.xyz, cc_shadowMap), cc_shadowProjDepthInfo.x, cc_shadowProjDepthInfo.y);\n            #else\n              lightingData.transmitDiffuseParams.zw = vec2(0.0);\n            #endif\n          #endif\n        }\n      #endif\n      lightingResult.lightmapColor = vec3(0.0);\n      #if CC_SURFACES_USE_LIGHT_MAP && !CC_FORWARD_ADD\n\t\t    float lightmapShadow, lightmapAO;\n        GetLightMapColor(lightingResult.lightmapColor, lightmapShadow, lightmapAO, cc_lightingMap, FSInput_lightMapUV.xy, FSInput_lightMapUV.z, surfaceData.worldNormal);\n        #if CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_INDIRECT_OCCLUSION\n          lightingResult.shadow *= lightmapShadow;\n          lightingResult.ao *= lightmapAO;\n        #endif\n      #endif\n      lightingResult.directDiffuse = lightingResult.directSpecular = vec3(0.0);\n      #if !CC_DISABLE_DIRECTIONAL_LIGHT && !CC_FORWARD_ADD\n        CCSurfacesLightingCalculateColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, surfaceData, lightingData);\n        CCSurfacesLightingCalculateDirect(lightingResult.directDiffuse, lightingResult.directSpecular, lightingData, cc_mainLitColor);\n      #endif\n      CCSurfacesLightingCalculateEnvironment(lightingResult.environmentDiffuse, lightingResult.environmentSpecular, lightingData, cc_ambientSky.w);\n      #if CC_SURFACES_LIGHTING_USE_FRESNEL\n        lightingResult.fresnel = CCSurfaceLightingCalculateFresnel(lightingData);\n      #endif\n      #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n        CCSurfacesLightingCalculateDirectTransmitSpecular(lightingResult.directTransmitSpecular, lightingData, cc_mainLitColor);\n        CCSurfacesLightingCalculateEnvironmentTransmitSpecular(lightingResult.environmentTransmitSpecular, lightingData, cc_ambientSky.w);\n      #endif\n      #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n        CCSurfacesLightingCalculateDirectTransmitDiffuse(lightingResult.directTransmitDiffuse, lightingResult, lightingData, cc_mainLitColor);\n        CCSurfacesLightingCalculateEnvironmentTransmitDiffuse(lightingResult.environmentTransmitDiffuse, lightingResult, lightingData, cc_ambientSky.w);\n      #endif\n      #if CC_SURFACES_LIGHTING_TRT\n        LightingIntermediateData lightingDataTRT;\n        CCSurfacesGetLightingIntermediateDataTRT(lightingDataTRT, lightingData, surfaceData);\n        CCSurfacesLightingCalculateDirectTRT(lightingResult.directTRT, lightingDataTRT, cc_mainLitColor);\n        CCSurfacesLightingCalculateEnvironmentTRT(lightingResult.environmentTRT, lightingDataTRT, cc_ambientSky.w);\n        vec3 diff;\n        SurfacesMaterialData surfaceDataTRT;\n        CCSurfacesGetSurfacesMaterialDataTRT(surfaceDataTRT, surfaceData);\n        CCSurfacesLightingInitializeColorWithLighting(diff, lightingResult.specularColorWithLightingTRT, surfaceDataTRT, lightingDataTRT);\n      #endif\n      #if CC_SURFACES_LIGHTING_TT\n        CCSurfacesLightingCalculateDirectTT(lightingResult, lightingData, cc_mainLitColor);\n      #endif\n      #ifdef CC_SURFACES_LIGHTING_MODIFY_FINAL_RESULT\n        LightingMiscData miscData;\n        miscData.lightType = LIGHT_TYPE_DIRECTIONAL;\n        miscData.lightPos = vec3(0.0);\n        miscData.lightDir = cc_mainLitDir.xyz;\n        miscData.lightColorAndIntensity = cc_mainLitColor;\n        miscData.lightSizeRangeAngle = vec4(0.0, 0.0, 0.0, 0.0);\n        SurfacesLightingModifyFinalResult(lightingResult, lightingData, surfaceData, miscData);\n      #endif\n    }\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING\n    #endif\n  #endif\n#endif\nvec4 CCSurfacesDebugDisplayInvalidNumber(vec4 color)\n{\n  float index = mod(cc_time.x * 10.0, 2.0);\n  vec4 error = index < 1.0 ? vec4(1.0, 0.0, 0.2, 1.0) : vec4(0.0, 1.0, 0.2, 1.0);\n  return (isnans(color.rgb) || isinfs(color.rgb)) ? error : color;\n}\nvec4 CCSurfacesDebugDisplayInvalidInputData(vec4 color, vec3 data)\n{\n  float index = mod(cc_time.x * 10.0, 2.0);\n  vec4 error = index < 1.0 ? vec4(1.0, 0.0, 0.2, 1.0) : vec4(0.0, 1.0, 0.2, 1.0);\n  return (isnans(data) || isinfs(data)) ? error : color;\n}\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && !CC_FORWARD_ADD\n  void CCSurfacesDebugViewMeshData(inout vec4 color)\n  {\n    vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_VERTEX_COLOR\n        color = FSInput_vertexColor;\n      #else\n        color = white;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(FSInput_worldNormal * 0.5 + vec3(0.5), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(FSInput_worldTangent * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        float sign = FSInput_mirrorNormal * 0.5 + 0.5;\n        color = vec4(sign, sign, sign, 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FACE_SIDE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        float scalar = clamp(FSInput_faceSideSign, 0.0, 1.0);\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_UV0)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(FSInput_texcoord.xy, 0.0, 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_UV1)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n      color = vec4(FSInput_texcoord1.xy, 0.0, 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n        color = vec4(FSInput_lightMapUV.xy, 0.0, 1.0);\n      #else\n        color = vec4(0.0, 0.0, 0.0, 1.0);\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      vec4 clipPos = cc_matProj * cc_matView * vec4(FSInput_worldPos.xyz, 1.0);\n      float depth = clipPos.z / clipPos.w;\n      color = vec4(depth, depth, depth, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      vec4 viewPos = cc_matView * vec4(FSInput_worldPos.xyz, 1.0);\n      float depth = (-viewPos.z - cc_nearFar.x) / cc_nearFar.y;\n      color = vec4(depth, depth, depth, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_WORLD_POS)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n      color = vec4(FSInput_worldPos.xyz, 1.0);\n  }\n#endif\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE\n  bool CCSurfacesDebugViewLightingResult(inout vec4 color, in LightingResult lightingResult)\n  {\n    bool isSRGBColor = false;\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directSpecular * lightingResult.specularColorWithLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_ALL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting + lightingResult.directSpecular * lightingResult.specularColorWithLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentSpecular * lightingResult.specularColorWithLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ENV_ALL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting + lightingResult.environmentSpecular * lightingResult.specularColorWithLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_LIGHT_MAP)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.lightmapColor;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_EMISSIVE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.emissive;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_AO)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(lightingResult.ao);\n        isSRGBColor = false;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_SHADOW)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(lightingResult.shadow);\n        isSRGBColor = false;\n    }\n    float fresnel = 0.0;\n    vec3 directTransmitSpecular = vec3(0.0), environmentTransmitSpecular = vec3(0.0);\n    vec3 directTransmitDiffuse = vec3(0.0), environmentTransmitDiffuse = vec3(0.0);\n    vec3 diffuseColorWithLightingTT = vec3(0.0), specularColorWithLightingTRT = vec3(0.0);\n    vec3 directTRT = vec3(0.0), environmentTRT = vec3(0.0);\n  #if CC_SURFACES_LIGHTING_USE_FRESNEL\n    fresnel = lightingResult.fresnel;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    directTransmitSpecular = lightingResult.directTransmitSpecular;\n    environmentTransmitSpecular = lightingResult.environmentTransmitSpecular;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    directTransmitDiffuse = lightingResult.directTransmitDiffuse;\n    environmentTransmitDiffuse = lightingResult.environmentTransmitDiffuse;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRT\n    directTRT = lightingResult.directTRT;\n    environmentTRT = lightingResult.environmentTRT;\n    specularColorWithLightingTRT = lightingResult.specularColorWithLightingTRT;\n  #endif\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRESNEL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(fresnel);\n        isSRGBColor = false;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = directTransmitSpecular;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = environmentTransmitSpecular;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = directTransmitDiffuse;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = environmentTransmitDiffuse;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = directTransmitSpecular + environmentTransmitSpecular + directTransmitDiffuse + environmentTransmitDiffuse;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRT_DIRECT)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = directTRT * specularColorWithLightingTRT;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRT_ENVIRONMENT)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = environmentTRT * specularColorWithLightingTRT;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRT_ALL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = (directTRT + environmentTRT) * specularColorWithLightingTRT;\n        isSRGBColor = true;\n    }\n    return isSRGBColor;\n  }\n#endif\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  void CCSurfacesDebugViewCompositeLightingResult(inout LightingResult lightingResult)\n  {\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE)\n      lightingResult.directDiffuse = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR)\n      lightingResult.directSpecular = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE)\n      lightingResult.environmentDiffuse = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR)\n      lightingResult.environmentSpecular = vec3(0.0);\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE)\n      lightingResult.directTransmitDiffuse = lightingResult.environmentTransmitDiffuse = vec3(0.0);\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR)\n      lightingResult.directTransmitSpecular = lightingResult.environmentTransmitSpecular = vec3(0.0);\n  #endif\n  #if CC_SURFACES_LIGHTING_TRT\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRT)\n        lightingResult.directTRT = lightingResult.environmentTRT = vec3(0.0);\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT)\n        lightingResult.directTT = vec3(0.0);\n  #endif\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE)\n      lightingResult.emissive = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP)\n      lightingResult.lightmapColor = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW)\n      lightingResult.shadow = 1.0;\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO)\n      lightingResult.ao = 1.0;\n  #if CC_SURFACES_LIGHTING_USE_FRESNEL\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL)\n      lightingResult.fresnel = 1.0;\n  #endif\n  }\n#endif\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  void main()  {\n  #if CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER\n    float NoL = dot(-cc_mainLitDir.xyz, FSInput_worldNormal.xyz);\n    vec4 color = SurfacesFragmentModifyBaseColorAndTransparency();\n  #else\n    SurfacesMaterialData surfaceData;\n    CCSurfacesFragmentGetMaterialData(surfaceData);\n    vec2 shadowBias = vec2(0.0);\n    vec3 colDebugCSMLayer = vec3(1.0);\n    #if CC_RECEIVE_SHADOW\n      shadowBias = FSInput_shadowBias;\n      #if !CC_FORWARD_ADD\n        #if CC_USE_DEBUG_VIEW && CC_SURFACES_ENABLE_DEBUG_VIEW\n          if (IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION)\n          {\n              vec4 csmPos;\n              vec4 shadowProjDepthInfo, shadowProjInfo;\n              vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n              int csmLayer = -1;\n              csmLayer = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, surfaceData.worldPos);\n              bool OutOfRange = csmLayer < 0;\n              if (OutOfRange)\n                  colDebugCSMLayer = vec3(1.0);\n              else if (csmLayer == 0)\n                  colDebugCSMLayer = vec3(1.0, 0.0, 0.0);\n              else if (csmLayer == 1)\n                  colDebugCSMLayer = vec3(0.0, 1.0, 0.0);\n              else if (csmLayer == 2)\n                  colDebugCSMLayer = vec3(0.0, 0.0, 1.0);\n              else if (csmLayer == 3)\n                  colDebugCSMLayer = vec3(0.0, 1.0, 1.0);\n          }\n        #endif\n      #endif\n    #endif\n    #if !CC_FORWARD_ADD\n      float fogFactor = 1.0;\n      #if CC_USE_FOG != 4\n        #if !CC_USE_ACCURATE_FOG\n          fogFactor = FSInput_fogFactor;\n        #else\n          CC_TRANSFER_FOG_BASE(vec4(FSInput_worldPos, 1.0), fogFactor);\n        #endif\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG) {\n            fogFactor = 1.0;\n        }\n      #endif\n    #endif\n    LightingResult lightingResult;\n    CCSurfacesLighting(lightingResult, surfaceData, shadowBias);\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && CC_SURFACES_ENABLE_DEBUG_VIEW\n      vec4 debugColor = vec4(0.0, 0.0, 0.0, 1.0);\n      float materialTransparency = CCSurfacesShading(surfaceData, lightingResult).a;\n      #if !CC_FORWARD_ADD\n        CCSurfacesDebugViewMeshData(debugColor);\n        CCSurfacesDebugViewSurfaceData(debugColor, surfaceData);\n        if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FOG)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        {\n          debugColor.rgb = vec3(1.0 - fogFactor);\n        }\n      #endif\n      #if CC_FORWARD_ADD\n        if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)) || ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)) || ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_ALL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n      #endif\n        {\n            if (CCSurfacesDebugViewLightingResult(debugColor, lightingResult))\n            {\n              debugColor.a = materialTransparency;\n              #if CC_USE_HDR\n                if (IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING)\n                    debugColor.rgb = ACESToneMap(debugColor.rgb);\n              #endif\n              if (IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION)\n                  debugColor.rgb = LinearToSRGB(debugColor.rgb);\n            }\n        }\n      if (IS_DEBUG_VIEW_ENABLE_WITH_CAMERA) {\n        gl_FragData[0] = debugColor;\n        return;\n      }\n    #elif CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n      CCSurfacesDebugViewCompositeLightingResult(lightingResult);\n    #endif\n    vec4 color = CCSurfacesShading(surfaceData, lightingResult);\n    #if CC_USE_DEBUG_VIEW && CC_SURFACES_ENABLE_DEBUG_VIEW\n      if (IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION) {\n          color.rgb *= colDebugCSMLayer.rgb;\n      }\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = CCSurfacesDebugDisplayInvalidInputData(color, FSInput_worldTangent);\n      #endif\n    #endif\n  #endif\n    #if CC_USE_RGBE_OUTPUT\n      gl_FragData[0] = packRGBE(color.rgb);\n      return;\n    #endif\n    #if CC_USE_HDR\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n        if (IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING)\n      #endif\n        color.rgb = ACESToneMap(color.rgb);\n    #endif\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n      if (IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION)\n    #endif\n    color.rgb = LinearToSRGB(color.rgb);\n    #if !CC_FORWARD_ADD && CC_USE_FOG != 4\n      CC_APPLY_FOG_BASE(color, fogFactor);\n    #endif\n    gl_FragData[0] = CCSurfacesDebugDisplayInvalidNumber(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n    void main () {\n      SurfacesMaterialData surfaceData;\n      CCSurfacesFragmentGetMaterialData(surfaceData);\n      gl_FragData[0] = CCSurfacesDeferredOutput0(surfaceData);\n      gl_FragData[1] = CCSurfacesDeferredOutput1(surfaceData);\n      gl_FragData[2] = CCSurfacesDeferredOutput2(surfaceData);\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && CC_SURFACES_ENABLE_DEBUG_VIEW\n      vec4 debugColor = vec4(0.0, 0.0, 0.0, 1.0);\n      CCSurfacesDebugViewMeshData(debugColor);\n      CCSurfacesDebugViewSurfaceData(debugColor, surfaceData);\n      if (IS_DEBUG_VIEW_ENABLE_WITH_CAMERA) {\n        gl_FragData[0] = debugColor;\n      }\n    #endif\n    }\n#endif"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]},{"name":"CCCSM","defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_environment","defines":[]},{"name":"cc_diffuseMap","defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]},{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":["!USE_INSTANCING"]},{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CCSH","defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeDataMap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":98,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":128}},"defines":[{"name":"USE_COMPATIBLE_LIGHTING","type":"boolean"},{"name":"USE_NORMAL_MAP","type":"boolean"},{"name":"USE_INSTANCING","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"boolean"},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_LIGHT_PROBE","type":"boolean","default":0},{"name":"CC_USE_MORPH","type":"boolean"},{"name":"CC_FORWARD_ADD","type":"boolean"},{"name":"CC_USE_FOG","type":"number","range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean"},{"name":"CC_USE_REFLECTION_PROBE","type":"boolean"},{"name":"CC_MORPH_TARGET_COUNT","type":"number","range":[2,8]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean"},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean"},{"name":"CC_USE_REAL_TIME_JOINT_TEXTURE","type":"boolean"},{"name":"CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER","type":"number","range":[0,1]},{"name":"CC_PIPELINE_TYPE","type":"number","range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean"},{"name":"CC_SUPPORT_CASCADED_SHADOW_MAP","type":"boolean"},{"name":"CC_USE_IBL","type":"number","range":[0,2]},{"name":"CC_USE_DIFFUSEMAP","type":"number","range":[0,2]},{"name":"CC_USE_DEBUG_VIEW","type":"number","range":[0,3]},{"name":"CC_SHADOWMAP_FORMAT","type":"number","range":[0,3]},{"name":"CC_SHADOWMAP_USE_LINEAR_DEPTH","type":"boolean"},{"name":"CC_DIR_SHADOW_PCF_TYPE","type":"number","range":[0,3]},{"name":"CC_CASCADED_LAYERS_TRANSITION","type":"boolean"},{"name":"CC_LIGHT_MAP_VERSION","type":"number","range":[0,3]},{"name":"CC_USE_HDR","type":"boolean"},{"name":"USE_BASE_COLOR_MAP","type":"boolean"},{"name":"USE_1ST_SHADE_MAP","type":"boolean"},{"name":"USE_2ND_SHADE_MAP","type":"boolean"},{"name":"USE_SPECULAR_MAP","type":"boolean"},{"name":"USE_EMISSIVE_MAP","type":"boolean"},{"name":"USE_ALPHA_TEST","type":"boolean"},{"name":"ALPHA_TEST_CHANNEL","type":"string","options":["a","r","g","b"]},{"name":"SHADE_MAP_1_AS_SHADE_MAP_2","type":"boolean"},{"name":"BASE_COLOR_MAP_AS_SHADE_MAP_1","type":"boolean"},{"name":"BASE_COLOR_MAP_AS_SHADE_MAP_2","type":"boolean"},{"name":"CC_SHADOW_TYPE","type":"number","range":[0,3]},{"name":"CC_DIR_LIGHT_SHADOW_TYPE","type":"number","range":[0,3]},{"name":"CC_DISABLE_DIRECTIONAL_LIGHT","type":"boolean"},{"name":"CC_USE_RGBE_OUTPUT","type":"boolean"}]},{"hash":401379729,"name":"builtin-toon|shadow-caster-vs|shadow-caster-fs","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"baseColor","type":16,"count":1},{"name":"colorScaleAndCutoff","type":16,"count":1},{"name":"shadeColor1","type":16,"count":1},{"name":"shadeColor2","type":16,"count":1},{"name":"specular","type":16,"count":1},{"name":"shadeParams","type":16,"count":1},{"name":"miscParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleAndStrenth","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"baseColorMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_BASE_COLOR_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_NORMAL_MAP"]},{"name":"shadeMap1","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_1ST_SHADE_MAP"]},{"name":"shadeMap2","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_2ND_SHADE_MAP"]},{"name":"specularMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_SPECULAR_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_EMISSIVE_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_color","format":44,"location":6,"defines":[]},{"name":"a_texCoord1","format":21,"location":7,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":12,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBiasAndProbeId","format":44,"isInstanced":true,"location":13,"defines":["USE_INSTANCING"]},{"name":"a_sh_linear_const_r","format":44,"isInstanced":true,"location":14,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_g","format":44,"isInstanced":true,"location":15,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_b","format":44,"isInstanced":true,"location":16,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_vertexId","format":11,"location":17,"defines":["CC_USE_MORPH"]}],"fragColors":[{"name":"fragColorX","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"descriptors":[{"rate":0,"blocks":[{"name":"CCLocal","stageFlags":17,"tags":{"builtin":"local"},"members":[{"name":"cc_matWorld","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matWorldIT","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_lightingMapUVParam","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_localShadowBias","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData2","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["!USE_INSTANCING"]},{"name":"CCMorph","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_displacementWeights","typename":"vec4","type":16,"count":15,"isArray":true},{"name":"cc_displacementTextureInfo","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointTextureInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointAnimInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_joints","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true}],"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCForwardLight","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_lightPos","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true},{"name":"cc_lightColor","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightSizeRangeAngle","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightDir","typename":"vec4","type":16,"count":0,"isArray":true}],"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CCSH","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_sh_linear_const_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_a","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeDataMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":1,"blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"baseColor","type":16,"count":1},{"name":"colorScaleAndCutoff","type":16,"count":1},{"name":"shadeColor1","type":16,"count":1},{"name":"shadeColor2","type":16,"count":1},{"name":"specular","type":16,"count":1},{"name":"shadeParams","type":16,"count":1},{"name":"miscParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleAndStrenth","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"baseColorMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_BASE_COLOR_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_NORMAL_MAP"]},{"name":"shadeMap1","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_1ST_SHADE_MAP"]},{"name":"shadeMap2","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_2ND_SHADE_MAP"]},{"name":"specularMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_SPECULAR_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_EMISSIVE_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":2,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":3,"blocks":[{"name":"CCGlobal","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_time","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_screenSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nativeSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_probeInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_mode","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCamera","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_cameraPos","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_surfaceTransform","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_screenScale","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_exposure","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitDir","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientSky","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientGround","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogBase","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogAdd","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nearFar","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_viewPort","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCShadow","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matLightView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matLightViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_shadowInvProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowNFLSInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowWHPBInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowLPNNInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowColor","typename":"vec4","type":16,"count":1,"precision":"lowp "},{"name":"cc_planarNDInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCSM","stageFlags":16,"tags":{"builtin":"global"},"members":[{"name":"cc_csmViewDir0","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir1","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir2","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmAtlas","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_matCSMViewProj","typename":"mat4","type":25,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjDepthInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmSplitsInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_environment","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"global"},"defines":[]},{"name":"cc_diffuseMap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]},{"name":"cc_shadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]}],"glsl1":{"vert":"\nprecision highp float;\n#define CC_SURFACES_USE_TANGENT_SPACE 0\n#define CC_SURFACES_USE_VERTEX_COLOR 0\n#define CC_SURFACES_USE_SECOND_UV 0\n#define CC_SURFACES_USE_LIGHT_MAP 0\n#define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#ifndef CC_SURFACES_LIGHTING_CALCULATE_DIFFUSE\n  #define CC_SURFACES_LIGHTING_CALCULATE_DIFFUSE 1\n#endif\n#ifndef CC_SURFACES_LIGHTING_CALCULATE_SPECULAR\n  #define CC_SURFACES_LIGHTING_CALCULATE_SPECULAR 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  attribute vec4 a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  attribute vec4 a_color;\n#endif\n#if CC_SURFACES_USE_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    attribute vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    attribute vec4 a_sh_linear_const_r;\n    attribute vec4 a_sh_linear_const_g;\n    attribute vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n#endif\nvarying highp vec3 v_worldPos;\nvarying mediump vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  varying mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  varying highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define VSOutput_worldPos v_worldPos\n#define VSOutput_worldNormal v_normal.xyz\n#define VSOutput_faceSideSign v_normal.w\n#define VSOutput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define VSOutput_vertexColor v_color\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define VSOutput_worldTangent v_tangent.xyz\n  #define VSOutput_mirrorNormal v_tangent.w\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define VSOutput_texcoord1 v_uv1\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define VSOutput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define VSOutput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define VSOutput_reflectionProbeId v_shadowBiasAndProbeId.z\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define VSOutput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define VSOutput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define VSOutput_clipPos v_clipPos\n#endif\nstruct SurfacesStandardVertexIntermediate\n{\n  highp vec4 position;\n  vec3 normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  vec4 color;\n#endif\n  vec2 texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  vec2 texCoord1;\n#endif\n  highp vec4 clipPos;\n  highp vec3 worldPos;\n  vec4 worldNormal;\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 worldTangent, worldBinormal;\n  #endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  vec4 shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  float fogFactor;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  vec3 lightmapUV;\n#endif\n};\n#if CC_USE_MORPH\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matLightViewProj;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_POINT 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_SPHERE 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if !USE_INSTANCING\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #if CC_USE_FOG != 4\n  #endif\n#endif\n    uniform vec4 tilingOffset;\n#define CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord * tilingOffset.xy + tilingOffset.zw;\n}\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_POS\nvec3 SurfacesVertexModifyLocalPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.position.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_NORMAL\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_TANGENT\n  #if CC_SURFACES_USE_TANGENT_SPACE\n  #endif\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_SHARED_DATA\nvoid SurfacesVertexModifyLocalSharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_POS\nvec3 SurfacesVertexModifyWorldPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.worldPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_CLIP_POS\nvec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.clipPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_NORMAL\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHARED_DATA\nvoid SurfacesVertexModifySharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\nvoid CCSurfacesVertexInput(out SurfacesStandardVertexIntermediate In)\n{\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  In.tangent = a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  In.color = a_color;\n#endif\n  In.texCoord = a_texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = a_texCoord1;\n#endif\n}\nvoid CCSurfacesVertexOutput(in SurfacesStandardVertexIntermediate In)\n{\n  gl_Position = In.clipPos;\n  VSOutput_worldNormal = In.worldNormal.xyz;\n  VSOutput_faceSideSign = In.worldNormal.w;\n  VSOutput_worldPos = In.worldPos;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  VSOutput_worldTangent = In.worldTangent.xyz;\n  VSOutput_mirrorNormal = In.tangent.w > 0.0 ? 1.0 : -1.0;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  VSOutput_vertexColor = In.color;\n#endif\n  VSOutput_texcoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  VSOutput_texcoord1 = In.texCoord1;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  VSOutput_fogFactor = In.fogFactor;\n#endif\n#if CC_RECEIVE_SHADOW\n  VSOutput_shadowBias = In.shadowBiasAndProbeId.xy;\n#endif\n#if CC_USE_REFLECTION_PROBE\n  VSOutput_reflectionProbeId = In.shadowBiasAndProbeId.z;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  VSOutput_lightMapUV = In.lightmapUV;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  VSOutput_localPos = In.position;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  VSOutput_clipPos = In.clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    v_sh_linear_const_r = a_sh_linear_const_r;\n    v_sh_linear_const_g = a_sh_linear_const_g;\n    v_sh_linear_const_b = a_sh_linear_const_b;\n  #endif\n#endif\n}\nvoid CCSurfacesVertexAnimation(inout SurfacesStandardVertexIntermediate In)\n{\nvec4 temp = vec4(0.0);\n#if CC_USE_MORPH\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    applyMorph(In.position, In.normal, In.tangent);\n  #else\n    applyMorph(In.position, In.normal, temp);\n  #endif\n#endif\n#if CC_USE_SKINNING\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    CCSkin(In.position, In.normal, In.tangent);\n  #else\n    CCSkin(In.position, In.normal, temp);\n  #endif\n#endif\n}\nvoid CCSurfacesVertexWorldTransform(inout SurfacesStandardVertexIntermediate In)\n{\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    In.worldPos = (matWorld * In.position).xyz;\n    In.worldNormal.xyz = normalize((matWorldIT * vec4(In.normal.xyz, 0.0)).xyz);\n    #if CC_SURFACES_USE_TANGENT_SPACE\n      In.worldTangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      In.worldBinormal = cross(In.worldNormal.xyz, In.worldTangent) * In.tangent.w;\n    #endif\n}\nvoid CCSurfacesVertexTransformUV(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_SURFACES_FLIP_UV\n    In.texCoord = cc_cameraPos.w > 1.0 ? vec2(In.texCoord.x, 1.0 - In.texCoord.y) : In.texCoord;\n    #if CC_SURFACES_USE_SECOND_UV\n      In.texCoord1 = cc_cameraPos.w > 1.0 ? vec2(In.texCoord1.x, 1.0 - In.texCoord1.y) : In.texCoord1;\n    #endif\n  #endif\n}\nvarying highp vec2 v_clip_depth;\nvoid main()\n{\n  SurfacesStandardVertexIntermediate In;\n  CCSurfacesVertexInput(In);\n  CCSurfacesVertexAnimation(In);\n  In.position.xyz = SurfacesVertexModifyLocalPos(In);\n  SurfacesVertexModifyLocalSharedData(In);\n  CCSurfacesVertexWorldTransform(In);\n  In.worldPos = SurfacesVertexModifyWorldPos(In);\n  In.clipPos = cc_matLightViewProj * vec4(In.worldPos, 1.0);\n  In.clipPos = SurfacesVertexModifyClipPos(In);\n  SurfacesVertexModifyUV(In);\n  SurfacesVertexModifySharedData(In);\n  CCSurfacesVertexTransformUV(In);\n  CCSurfacesVertexOutput(In);\n  v_clip_depth = In.clipPos.zw;\n}","frag":"\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\n#define CC_SURFACES_USE_TANGENT_SPACE 0\n#define CC_SURFACES_USE_VERTEX_COLOR 0\n#define CC_SURFACES_USE_SECOND_UV 0\n#define CC_SURFACES_USE_LIGHT_MAP 0\n#define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#ifndef CC_SURFACES_LIGHTING_CALCULATE_DIFFUSE\n  #define CC_SURFACES_LIGHTING_CALCULATE_DIFFUSE 1\n#endif\n#ifndef CC_SURFACES_LIGHTING_CALCULATE_SPECULAR\n  #define CC_SURFACES_LIGHTING_CALCULATE_SPECULAR 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nvarying highp vec3 v_worldPos;\nvarying mediump vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  varying mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  varying highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define FSInput_worldPos v_worldPos\n#define FSInput_worldNormal v_normal.xyz\n#define FSInput_faceSideSign v_normal.w\n#define FSInput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define FSInput_vertexColor v_color\n#else\n  #define FSInput_vertexColor vec4(1.0)\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define FSInput_worldTangent v_tangent.xyz\n  #define FSInput_mirrorNormal v_tangent.w\n#else\n  #define FSInput_worldTangent vec3(0.0, 0.0, 0.0)\n  #define FSInput_mirrorNormal 1.0\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define FSInput_texcoord1 v_uv1\n#else\n  #define FSInput_texcoord1 vec2(0.0, 0.0)\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define FSInput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define FSInput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define FSInput_reflectionProbeId v_shadowBiasAndProbeId.z\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define FSInput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define FSInput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define FSInput_clipPos v_clipPos\n#endif\nuniform mediump vec4 cc_debug_view_mode;\nuniform mediump vec4 cc_surfaceTransform;\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_IOR CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_IOR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FRESNEL CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_FRESNEL + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRT_DIRECT CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_TRT_ENVIRONMENT CC_SURFACES_DEBUG_VIEW_TRT_DIRECT + 1\n#define CC_SURFACES_DEBUG_VIEW_TRT_ALL CC_SURFACES_DEBUG_VIEW_TRT_ENVIRONMENT + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_TRT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#define IS_DEBUG_VIEW_ENABLE_WITH_CAMERA (cc_surfaceTransform.y != 3.0)\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (UnpackBitFromFloat(cc_debug_view_mode.w, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (UnpackBitFromFloat(cc_debug_view_mode.w, 7) && IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (UnpackBitFromFloat(cc_debug_view_mode.y, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (UnpackBitFromFloat(cc_debug_view_mode.y, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (UnpackBitFromFloat(cc_debug_view_mode.y, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (UnpackBitFromFloat(cc_debug_view_mode.y, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (UnpackBitFromFloat(cc_debug_view_mode.z, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (UnpackBitFromFloat(cc_debug_view_mode.z, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (UnpackBitFromFloat(cc_debug_view_mode.z, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (UnpackBitFromFloat(cc_debug_view_mode.z, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL (UnpackBitFromFloat(cc_debug_view_mode.z, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.z, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRT (UnpackBitFromFloat(cc_debug_view_mode.z, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT (UnpackBitFromFloat(cc_debug_view_mode.w, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    #if CC_PIPELINE_TYPE == 0\n      #define LIGHTS_PER_PASS 1\n    #else\n      #define LIGHTS_PER_PASS 10\n    #endif\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n    #endif\n  #endif\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if !USE_INSTANCING\n    #endif\n#endif\nuniform highp mat4 cc_matLightView;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #endif\nuniform samplerCube cc_environment;\n#if CC_USE_IBL\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform samplerCube cc_reflectionProbeCubemap;\n  uniform sampler2D cc_reflectionProbePlanarMap;\n  uniform sampler2D cc_reflectionProbeDataMap;\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_POINT 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_SPHERE 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n#endif\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\n#if CC_USE_FOG != 4\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if CC_USE_LIGHT_PROBE\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  uniform sampler2D cc_lightingMap;\n#endif\n    uniform vec4 baseColor;\n    uniform vec4 colorScaleAndCutoff;\n#if USE_BASE_COLOR_MAP\n  uniform sampler2D baseColorMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#if USE_1ST_SHADE_MAP\n  uniform sampler2D shadeMap1;\n#endif\n#if USE_2ND_SHADE_MAP\n  uniform sampler2D shadeMap2;\n#endif\n#if USE_SPECULAR_MAP\n  uniform sampler2D specularMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\n#define CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TOONSHADE\n#define CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\nvoid SurfacesFragmentAlphaClipOnly()\n{\n  #if USE_ALPHA_TEST\n    float alpha = baseColor.ALPHA_TEST_CHANNEL;\n    #if USE_BASE_COLOR_MAP\n      alpha = texture2D(baseColorMap, FSInput_texcoord).ALPHA_TEST_CHANNEL;\n    #endif\n    if (alpha < colorScaleAndCutoff.w) discard;\n  #endif\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\n#define CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\n#define CC_SURFACES_FRAGMENT_MODIFY_TOON_STEP_AND_FEATHER\n#define CC_SURFACES_FRAGMENT_MODIFY_TOON_SHADOW_COVER\n#define CC_SURFACES_FRAGMENT_MODIFY_TOON_SPECULAR\nvarying highp vec2 v_clip_depth;\nvoid main () {\n  SurfacesFragmentAlphaClipOnly();\n  highp float clipDepth = v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5;\n  if(cc_shadowLPNNInfo.x > EPSILON && cc_shadowLPNNInfo.x < 1.999999) {\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      clipDepth = CCGetLinearDepth(FSInput_worldPos.xyz);\n    #endif\n  }\n  #if CC_SHADOWMAP_FORMAT == 1\n    gl_FragColor = packDepthToRGBA(clipDepth);\n  #else\n    gl_FragColor = vec4(clipDepth, 1.0, 1.0, 1.0);\n  #endif\n}"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]},{"name":"CCCSM","defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_environment","defines":[]},{"name":"cc_diffuseMap","defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]},{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":["!USE_INSTANCING"]},{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CCSH","defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeDataMap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":98,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":128}},"defines":[{"name":"USE_INSTANCING","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"boolean"},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_LIGHT_PROBE","type":"boolean","default":0},{"name":"CC_USE_MORPH","type":"boolean"},{"name":"CC_FORWARD_ADD","type":"boolean"},{"name":"CC_USE_FOG","type":"number","range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean"},{"name":"CC_USE_REFLECTION_PROBE","type":"boolean"},{"name":"CC_MORPH_TARGET_COUNT","type":"number","range":[2,8]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean"},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean"},{"name":"CC_USE_REAL_TIME_JOINT_TEXTURE","type":"boolean"},{"name":"CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER","type":"number","range":[0,1]},{"name":"CC_PIPELINE_TYPE","type":"number","range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean"},{"name":"CC_SUPPORT_CASCADED_SHADOW_MAP","type":"boolean"},{"name":"CC_USE_IBL","type":"number","range":[0,2]},{"name":"CC_USE_DIFFUSEMAP","type":"number","range":[0,2]},{"name":"USE_BASE_COLOR_MAP","type":"boolean"},{"name":"USE_NORMAL_MAP","type":"boolean"},{"name":"USE_1ST_SHADE_MAP","type":"boolean"},{"name":"USE_2ND_SHADE_MAP","type":"boolean"},{"name":"USE_SPECULAR_MAP","type":"boolean"},{"name":"USE_EMISSIVE_MAP","type":"boolean"},{"name":"USE_ALPHA_TEST","type":"boolean"},{"name":"ALPHA_TEST_CHANNEL","type":"string","options":["a","r","g","b"]},{"name":"CC_SHADOWMAP_USE_LINEAR_DEPTH","type":"boolean"},{"name":"CC_SHADOWMAP_FORMAT","type":"number","range":[0,3]}]}],[{"passes":[{"program":"builtin-toon|silhouette-edge-vs|silhouette-edge-fs","switch":"USE_OUTLINE_PASS","rasterizerState":{"cullMode":1},"depthStencilState":{"depthFunc":3,"depthTest":true,"depthWrite":true},"properties":{"lineWidth":{"type":13,"value":[10],"handleInfo":["outlineParams",0,13]},"depthBias":{"type":13,"value":[0],"handleInfo":["outlineParams",1,13]},"baseColor":{"type":16},"baseColorMap":{"value":"grey","type":28},"outlineParams":{"type":16,"value":[10,0,0,0]}}},{"program":"builtin-toon|toon-vs|toon-fs","properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[0.6,0.6,0.6,1],"handleInfo":["baseColor",0,16]},"colorScale":{"type":15,"value":[1,1,1],"handleInfo":["colorScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"handleInfo":["colorScaleAndCutoff",3,13]},"shadeColor1":{"linear":true,"type":16,"value":[0.4,0.4,0.4,1]},"shadeColor2":{"linear":true,"type":16,"value":[0.2,0.2,0.2,1]},"specular":{"linear":true,"type":16,"value":[1,1,1,0.3]},"baseStep":{"type":13,"value":[0.8],"handleInfo":["shadeParams",0,13]},"baseFeather":{"type":13,"value":[0.001],"handleInfo":["shadeParams",1,13]},"shadeStep":{"type":13,"value":[0.5],"handleInfo":["shadeParams",2,13]},"shadeFeather":{"type":13,"value":[0.001],"handleInfo":["shadeParams",3,13]},"shadowCover":{"type":13,"value":[0.5],"handleInfo":["miscParams",0,13]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1]},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleAndStrenth",0,15]},"normalStrength":{"slide":true,"step":0.001,"type":13,"value":[1],"range":[0,5],"handleInfo":["emissiveScaleAndStrenth",3,13]},"normalMap":{"value":"normal","type":28},"mainTexture":{"value":"white","type":28,"handleInfo":["baseColorMap",0,28]},"shadeMap1":{"value":"white","type":28},"shadeMap2":{"value":"white","type":28},"specularMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"baseColor":{"type":16,"value":[0.6,0.6,0.6,1]},"colorScaleAndCutoff":{"type":16,"value":[1,1,1,0.5]},"shadeParams":{"type":16,"value":[0.8,0.001,0.5,0.001]},"miscParams":{"type":16,"value":[0.5,0,0,0]},"emissiveScaleAndStrenth":{"type":16,"value":[1,1,1,1]},"baseColorMap":{"type":28,"value":"white"}}},{"phase":"forward-add","propertyIndex":1,"program":"builtin-toon|toon-vs|toon-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[0.6,0.6,0.6,1],"handleInfo":["baseColor",0,16]},"colorScale":{"type":15,"value":[1,1,1],"handleInfo":["colorScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"handleInfo":["colorScaleAndCutoff",3,13]},"shadeColor1":{"linear":true,"type":16,"value":[0.4,0.4,0.4,1]},"shadeColor2":{"linear":true,"type":16,"value":[0.2,0.2,0.2,1]},"specular":{"linear":true,"type":16,"value":[1,1,1,0.3]},"baseStep":{"type":13,"value":[0.8],"handleInfo":["shadeParams",0,13]},"baseFeather":{"type":13,"value":[0.001],"handleInfo":["shadeParams",1,13]},"shadeStep":{"type":13,"value":[0.5],"handleInfo":["shadeParams",2,13]},"shadeFeather":{"type":13,"value":[0.001],"handleInfo":["shadeParams",3,13]},"shadowCover":{"type":13,"value":[0.5],"handleInfo":["miscParams",0,13]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1]},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleAndStrenth",0,15]},"normalStrength":{"slide":true,"step":0.001,"type":13,"value":[1],"range":[0,5],"handleInfo":["emissiveScaleAndStrenth",3,13]},"normalMap":{"value":"normal","type":28},"mainTexture":{"value":"white","type":28,"handleInfo":["baseColorMap",0,28]},"shadeMap1":{"value":"white","type":28},"shadeMap2":{"value":"white","type":28},"specularMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"baseColor":{"type":16,"value":[0.6,0.6,0.6,1]},"colorScaleAndCutoff":{"type":16,"value":[1,1,1,0.5]},"shadeParams":{"type":16,"value":[0.8,0.001,0.5,0.001]},"miscParams":{"type":16,"value":[0.5,0,0,0]},"emissiveScaleAndStrenth":{"type":16,"value":[1,1,1,1]},"baseColorMap":{"type":28,"value":"white"}}},{"phase":"shadow-caster","propertyIndex":1,"program":"builtin-toon|shadow-caster-vs|shadow-caster-fs","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[0.6,0.6,0.6,1],"handleInfo":["baseColor",0,16]},"colorScale":{"type":15,"value":[1,1,1],"handleInfo":["colorScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"handleInfo":["colorScaleAndCutoff",3,13]},"shadeColor1":{"type":16,"value":[0.4,0.4,0.4,1]},"shadeColor2":{"type":16,"value":[0.2,0.2,0.2,1]},"specular":{"type":16,"value":[1,1,1,0.3]},"baseStep":{"type":13,"value":[0.8],"handleInfo":["shadeParams",0,13]},"baseFeather":{"type":13,"value":[0.001],"handleInfo":["shadeParams",1,13]},"shadeStep":{"type":13,"value":[0.5],"handleInfo":["shadeParams",2,13]},"shadeFeather":{"type":13,"value":[0.001],"handleInfo":["shadeParams",3,13]},"emissive":{"type":16,"value":[0,0,0,1]},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleAndStrenth",0,15]},"normalStrenth":{"type":13,"value":[1],"handleInfo":["emissiveScaleAndStrenth",3,13]},"mainTexture":{"value":"white","type":28,"handleInfo":["baseColorMap",0,28]},"baseColor":{"type":16,"value":[0.6,0.6,0.6,1]},"colorScaleAndCutoff":{"type":16,"value":[1,1,1,0.5]},"shadeParams":{"type":16,"value":[0.8,0.001,0.5,0.001]},"emissiveScaleAndStrenth":{"type":16,"value":[1,1,1,1]},"baseColorMap":{"type":28,"value":"white"}}}]}]]],0,0,[],[],[]],[[[22,"ground",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"USE_ALBEDO_MAP":true},{},{},{}],[[[{"roughness":0,"metallic":0.3},"mainTexture",6,0],{},{},{}],11,0,0,0]]],0,0,[0,0],[7,6],[52,24]],[[[22,"hotAirBalloonFish",[{"rasterizerState":{"cullMode":0},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"USE_ALBEDO_MAP":true,"USE_NORMAL_MAP":true,"USE_PBR_MAP":true,"USE_OCCLUSION_MAP":true},{},{},{}],[[[{"occlusion":0.75,"roughness":0.85,"metallic":0.6,"normalStrength":0.8},"mainTexture",6,0,"normalMap",6,1,"pbrMap",6,2,"occlusionMap",6,3],{},{},{}],11,0,0,0]]],0,0,[0,0,0,0,0],[7,15,16,17,6],[53,54,33,33,24]],[[[24,".bin",3319153620,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":46512,"length":7596,"count":3798,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":46512,"count":969,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.8507847785949707,-0.8676518797874451,-0.18031197786331177],"maxPosition",8,[1,0.8507842421531677,0.8676515221595764,1.0177552700042725]]],-1],0,0,[],[],[]],[[[29,"scene"],[27,"scene",[-2],[23,"bf4CEPZVpZAbOIxEUDmEgQ",null,null,null,-1,0]],[30,"RootNode",1,[-3],[23,"7ffJKm5fpW3ZCNSyyI2pAs",null,null,null,1,0]],[42,"scene",2,[[18,-4,[2,"9dUon3BC1X4YVl/5hgRKRH"],[0],[0],1]],[23,"4afZzZEvRQS4QJGOsJEsyM",null,null,null,1,0],[3,-0.7071067811865475,0,0,0.7071067811865476],[1,-90,0,0]]],0,[0,2,1,0,-1,2,0,-1,3,0,0,3,0,10,1,4],[0,0],[-1,1],[34,55]],[[[24,".bin",1429976259,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":96,"count":48,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-162.68284606933594,-0.00002086256426991895,-159.09327697753906],"maxPosition",8,[1,162.68284606933594,0.00003477093923720531,159.09327697753906]]],-1],0,0,[],[],[]],[[[24,".bin",4091364801,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":26832,"length":5760,"count":2880,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":26832,"count":559,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-13877.09375,-13877.09375,-13877.09375],"maxPosition",8,[1,13877.09375,13877.09375,13877.09375]]],-1],0,0,[],[],[]],[[[29,"fishBoneGroup"],[27,"fishBoneGroup",[-6,-7,-8,-9],[50,"f6kpByWxdIZIwPkw5K8lyS",null,null,-5,0,[-1,-2,-3,-4]]],[8,["dbOPg73aZd84HLIpJi6hXs"]],[8,["dbOPg73aZd84HLIpJi6hXs"]],[8,["dbOPg73aZd84HLIpJi6hXs"]],[8,["dbOPg73aZd84HLIpJi6hXs"]],[10,0,null,1,[11,"dbOPg73aZd84HLIpJi6hXs",null,null,-14,[28,"49jmB0AJBONLNA3PEnzANk",1,[[7,"fishBone01",["_name"],2],[4,["_lpos"],2,[1,-43.394,0,41.737]],[4,["_lrot"],2,[3,0,0,0,1]],[4,["_euler"],2,[1,0,0,0]],[4,["_lscale"],2,[1,4,4,4]],[26,["_materials","0"],-10,1],[4,["_lpos"],-11,[1,0,0,0]],[4,["_lscale"],-12,[1,1,1,1]],[7,1,["_shadowCastingMode"],-13]]],0]],[10,0,null,1,[11,"dbOPg73aZd84HLIpJi6hXs",null,null,-19,[28,"ccsg/q7CFNNZGm+PVBzoI5",1,[[7,"fishBone02",["_name"],3],[4,["_lpos"],3,[1,-40.134,0,44.041]],[4,["_lrot"],3,[3,0,0.25881904510252074,0,0.9659258262890683]],[4,["_euler"],3,[1,0,30,0]],[4,["_lscale"],3,[1,6,6,6]],[26,["_materials","0"],-15,3],[4,["_lpos"],-16,[1,0,0,0]],[4,["_lscale"],-17,[1,1,1,1]],[7,1,["_shadowCastingMode"],-18]]],2]],[10,0,null,1,[11,"dbOPg73aZd84HLIpJi6hXs",null,null,-24,[28,"1f08yXxcdEWb4Oq6FnQrjD",1,[[7,"fishBone03",["_name"],4],[4,["_lpos"],4,[1,17.69,0,42.034]],[4,["_lrot"],4,[3,0,0.25881904510252074,0,0.9659258262890683]],[4,["_euler"],4,[1,0,30,0]],[4,["_lscale"],4,[1,7,7,7]],[26,["_materials","0"],-20,5],[4,["_lpos"],-21,[1,0,0,0]],[4,["_lscale"],-22,[1,1,1,1]],[7,1,["_shadowCastingMode"],-23]]],4]],[10,0,null,1,[11,"dbOPg73aZd84HLIpJi6hXs",null,null,-29,[28,"e8kn2QEW5OB4kjhR5HCOr9",1,[[7,"fishBone04",["_name"],5],[4,["_lpos"],5,[1,47.659,0,35.485]],[4,["_lrot"],5,[3,0,-0.9524011203840098,0,0.30484767653909217]],[4,["_euler"],5,[1,0,-144.502,0]],[4,["_lscale"],5,[1,5,5,5]],[26,["_materials","0"],-25,7],[4,["_lpos"],-26,[1,0,0,0]],[4,["_lscale"],-27,[1,1,1,1]],[7,1,["_shadowCastingMode"],-28]]],6]],[8,["35RWGfmqZQcIYfCKtpCCRe"]],[8,["f4X4WSWoJSuKFuGMmLhDyC"]],[8,["35RWGfmqZQcIYfCKtpCCRe"]],[8,["f4X4WSWoJSuKFuGMmLhDyC"]],[8,["35RWGfmqZQcIYfCKtpCCRe"]],[8,["f4X4WSWoJSuKFuGMmLhDyC"]],[8,["35RWGfmqZQcIYfCKtpCCRe"]],[8,["f4X4WSWoJSuKFuGMmLhDyC"]]],0,[0,-1,9,0,-2,8,0,-3,7,0,-4,6,0,2,1,0,-1,6,0,-2,7,0,-3,8,0,-4,9,0,4,10,0,4,11,0,4,11,0,4,10,0,2,6,0,4,12,0,4,13,0,4,13,0,4,12,0,2,7,0,4,14,0,4,15,0,4,15,0,4,14,0,2,8,0,4,16,0,4,17,0,4,17,0,4,16,0,2,9,0,10,1,29],[0,0,0,0,0,0,0,0],[3,11,3,11,3,11,3,11],[17,18,17,18,17,18,17,18]],[[[52,"Skin-0",1207045088,["Dummy001","Dummy001/Bone002","Dummy001/Bone004","Dummy001/Bone003","Dummy001/Bone001","Dummy001/Bone004/Dummy002"],[[[7,1,0,0,0,0,-1.6292068494294654e-7,-1,0,0,1,-1.6292068494294654e-7,0,-0.2497023344039917,-3.1770753860473633,3.787369280416897e-7,1],[7,-1.795635853341082e-7,-1,4.3711398944878965e-8,0,-1,1.795635853341082e-7,-7.787743736833389e-15,0,6.123234262925839e-17,4.3711398944878965e-8,1,0,-1.6400002241134644,0.3130861818790436,-2.716092348098755,1],[7,2.3040463759116392e-7,1,-0.00001756747587933205,0,-6.123234262925839e-17,-0.00001756747587933205,-1,0,-1,2.3040463759116392e-7,-4.047566969089811e-12,0,2.562795639038086,-0.29146435856819153,0.000004776321929966798,1],[7,-1,-4.76837158203125e-7,-8.742273394091171e-8,0,8.742269841377492e-8,7.549790836947068e-8,-1,0,4.76837158203125e-7,-1,-7.549786573690653e-8,0,-1.6127876043319702,3.1737923622131348,-3.4489494282752275e-7,1],[7,3.5762786865234375e-7,-1,-1.6292068494294654e-7,0,1,3.5762786865234375e-7,5.832620763321708e-14,0,-6.123234262925839e-17,-1.6292068494294654e-7,1,0,-1.6404372453689575,0.31308603286743164,-2.716092586517334,1],[7,1,4.371031536720693e-8,1.4481852530522413e-15,0,-4.371031536720693e-8,1,2.8563817977556027e-12,0,-1.4480604215716397e-15,-2.8563817977556027e-12,1,0,1.430519700050354,0.001986427465453744,-0.539130687713623,1]],8,8,8,8,8,8]]],0,0,[],[],[]],[[[24,".bin",1584729718,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":34560,"length":2700,"count":1350,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":34560,"count":480,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.05042251572012901,-0.9282926917076111,-0.6663276553153992],"maxPosition",8,[1,0.050422362983226776,0.9009165167808533,1.0004234313964844]]],-1],0,0,[],[],[]],[[[24,".bin",622658799,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":363816,"length":41628,"count":20814,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":363816,"count":5053,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}],"jointMaps":[[0,1,2,3,4,5]]},"minPosition",8,[1,-2.8539648056030273,-2.6991729736328125,3.0517577442878974e-7],"maxPosition",8,[1,2.189321279525757,2.6991729736328125,4.806542873382568]]],-1],0,0,[],[],[]],[[[52,"Skin-1",478914448,["Dummy001/Bone004/Dummy002"],[[[7,1,4.371031536720693e-8,1.4481852530522413e-15,0,-4.371031536720693e-8,1,2.8563817977556027e-12,0,-1.4480604215716397e-15,-2.8563817977556027e-12,1,0,1.5258790142524958e-7,-1.1965632040755736e-7,-6.484985419774603e-7,1]],8]]],0,0,[],[],[]],[[[80,"fight"],[58,"stoneGroup001",512,[-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86],[3,0,0.7071067811865475,0,0.7071067811865477],[1,0,89.99999999999999,0]],[37,"obstacleGroup",512,[-88,-89,-90,-91,-92,-93,-94,-95,-96,-97,-98,-99,-100,-101,-102,-103,-104,-105,-106,-107,-108,-109,-110,-111,-112,-113,-114,-115,-116,-117,-118,-119,-120,-121,-122,-123,-124,-125,-126,-127,-128,-129,-130,-131],[[81,false,-87]]],[44,"boxGroup142",512,[-132,-133,-134,-135,-136,-137,-138,-139,-140,-141,-142,-143,-144,-145,-146,-147,-148,-149,-150,-151,-152,-153,-154,-155,-156,-157,-158,-159,-160,-161,-162,-163,-164,-165,-166],[1,0,0,-29]],[44,"boxGroup143",512,[-167,-168,-169,-170,-171,-172,-173,-174,-175,-176,-177,-178,-179,-180,-181,-182,-183,-184,-185,-186,-187,-188,-189,-190,-191,-192,-193,-194,-195,-196,-197,-198,-199],[1,0,0,26.5]],[45,"aiPos",512,"3arHTf6CdLaI1TH+40aXso",[-200,-201,-202,-203,-204,-205,-206,-207,-208,-209,-210,-211,-212,-213,-214,-215,-216,-217,-218,-219,-220,-221,-222,-223,-224,-225,-226,-227]],[31,"grassrGroup06",512,[-228,-229,-230,-231,-232,-233,-234,-235,-236,-237,-238,-239,-240,-241,-242,-243,-244,-245,-246]],[31,"grassrGroup05",512,[-247,-248,-249,-250,-251,-252,-253,-254,-255,-256,-257,-258,-259,-260,-261,-262,-263,-264]],[45,"map",512,"4deOB7jU5M9KShULJnY6lL",[-265,-266,-267,-268,-269,-270,-271,-272,-273,-274,-275,-276]],[1,"treeGroup",512,8,[-277,-278,-279,-280,-281,-282,-283,-284,-285,-286,-287]],[31,"boxGroup",512,[-288,-289,-290,-291,-292,-293,3,4,1]],[82,"fight",[-336,8,-337,-338,-339,-340,-341,-342,5],[78,null,null,"d281f908-3f41-4e03-8fff-eda9ad3432cd",null,null,[-294,-295,-296,-297,-298,-299,-300,-301,-302,-303,-304,-305,-306,-307,-308,-309,-310,-311,-312,-313,-314,-315,-316,-317,-318,-319,-320,-321,-322,-323,-324,-325,-326,-327,-328,-329,-330,-331,-332,-333,-334,-335]],[83,[84,21000,0.78125,[2,1,1,1,0.54687478125],[2,1,1,1,1],[2,0.7058823529411764,0.9411764705882353,1,0.520833125]],[85,true,1,[0,2048,2048]],[86],[87,[4,4292993505]],[88],[89]]],[1,"boxGroup141",512,10,[-343,-344,-345,-346,-347,-348,-349]],[1,"boxGroup141",512,10,[-350,-351,-352,-353,-354,-355,-356]],[1,"boxGroup141",512,10,[-357,-358,-359,-360,-361,-362,-363]],[31,"grassrGroup02",512,[-364,-365,-366,-367,-368,-369,-370]],[1,"boxGroup142",512,10,[-371,-372,-373,-374,-375,-376]],[1,"boxGroup142",512,10,[-377,-378,-379,-380,-381,-382]],[1,"grassGroup",512,8,[-383,15,-384,-385,7,6]],[1,"grassrGroup04",512,18,[-386,-387,-388,-389,-390,-391]],[1,"flowers_group_1",512,8,[-392,-393,-394,-395,-396,-397]],[59,"Canvas",512,524288,"e26uRLxrNJCZFTEOve/UFw",11,[-402,-403,-404],[[53,"Canvas<UITransform>",-398,[5,1280,720]],[90,"Canvas<Canvas>",-400,-399],[91,45,null,null,null,null,-401]],[1,640,360,0]],[60,"hotAirBalloonFishAni1",512,[-406,-407,-408],[[93,true,-405,[671],672]],[1,0,13.028,4.376],[1,3.5,3.5,3.5]],[31,"vatGroup001",512,[-409,-410,-411,-412]],[1,"grassrGroup01",512,18,[-413,-414,-415,-416,-417]],[1,"grassrGroup03",512,18,[-418,-419,-420,-421,-422]],[8,["8cfqruozpbl42VHWNYSqGv"]],[8,["8cfqruozpbl42VHWNYSqGv"]],[8,["8cfqruozpbl42VHWNYSqGv"]],[8,["8cfqruozpbl42VHWNYSqGv"]],[8,["8cfqruozpbl42VHWNYSqGv"]],[8,["8cfqruozpbl42VHWNYSqGv"]],[8,["8cfqruozpbl42VHWNYSqGv"]],[8,["8cfqruozpbl42VHWNYSqGv"]],[8,["8cfqruozpbl42VHWNYSqGv"]],[8,["8cfqruozpbl42VHWNYSqGv"]],[8,["8cfqruozpbl42VHWNYSqGv"]],[8,["8cfqruozpbl42VHWNYSqGv"]],[8,["8cfqruozpbl42VHWNYSqGv"]],[8,["8cfqruozpbl42VHWNYSqGv"]],[8,["8cfqruozpbl42VHWNYSqGv"]],[8,["8cfqruozpbl42VHWNYSqGv"]],[8,["8cfqruozpbl42VHWNYSqGv"]],[8,["8cfqruozpbl42VHWNYSqGv"]],[8,["8cfqruozpbl42VHWNYSqGv"]],[8,["8cfqruozpbl42VHWNYSqGv"]],[8,["8cfqruozpbl42VHWNYSqGv"]],[8,["8cfqruozpbl42VHWNYSqGv"]],[8,["8cfqruozpbl42VHWNYSqGv"]],[8,["8cfqruozpbl42VHWNYSqGv"]],[8,["8cfqruozpbl42VHWNYSqGv"]],[8,["8cfqruozpbl42VHWNYSqGv"]],[8,["8cfqruozpbl42VHWNYSqGv"]],[8,["8cfqruozpbl42VHWNYSqGv"]],[8,["8cfqruozpbl42VHWNYSqGv"]],[8,["8cfqruozpbl42VHWNYSqGv"]],[8,["8cfqruozpbl42VHWNYSqGv"]],[8,["8cfqruozpbl42VHWNYSqGv"]],[8,["8cfqruozpbl42VHWNYSqGv"]],[8,["8cfqruozpbl42VHWNYSqGv"]],[8,["8cfqruozpbl42VHWNYSqGv"]],[1,"boxGroup141",512,10,[-423,-424,-425,-426]],[8,["bf4CEPZVpZAbOIxEUDmEgQ"]],[8,["40Omc9e0ZDk69G+gmoWuGO"]],[8,["f8/ovBRwtez4dn95UVWJl2"]],[70,"display",512,"582TM7JCZMMIlwZ/tR4ER/",11,[[-432,-433,[33,"stoneGroup",512,-434]],1,1,4],[[94,-431,-430,-429,-428,-427,5,604,605]]],[72,"logic",512,"e3Sisq2UhEMp7B01zpPRKk",11,[-436,-437,2],[-435]],[61,"ui",512,524288,21,[-440,-441],[[39,-438,[5,1280,720]],[40,45,100,100,-439]]],[71,"Dummy001",512,22,[[[62,"Bone002",512,-442,[1,0.06338367611169815,-0.4609829783439636,1.6400001049041748],[3,0.5000000074505806,0.4999999776482576,-0.5000000074505805,0.5000000074505805],[1,-1,-1,-1],[1,90.0000017075473,89.99999829245269,-0.000001707547343392063]],[38,"Bone001",512,-443,[1,0.06338382512331009,-0.4609832763671875,-1.640437364578247],[3,-0.5000000670552236,0.4999999180436093,0.5000000074505778,0.5000000074505779],[1,-90.00000853773646,89.99999146226352,0.0000017075479540585618]],[38,"Bone003",512,-444,[1,-1.8624883890151978,-0.0032826096285134554,3.051758312722086e-7],[3,-4.371137748226838e-8,4.371139879855553e-8,0.9999999999999696,2.384185648907006e-7],[1,-179.99999499104146,179.9999949910439,0.000027320754832657967]],-445],4,4,4,1]],[8,["9dUon3BC1X4YVl/5hgRKRH"]],[8,["0dbpdUWKdV57/5BohZgCIy"]],[8,["f6kpByWxdIZIwPkw5K8lyS"]],[75,"Node",512,"6eHv6J0hhNBqzqbmv4F+9i",11,[-448],[[-446,[95,-447,[606],607]],1,4],[1,0,35,35],[3,7.992424175358916e-18,0.9914448613738104,-0.13052619222005157,6.070848880062641e-17],[1,15,180,0]],[63,"coinTipsGroup",512,524288,21,[[96,"coinTipsGroup<coinTipsManager>",-449,664],[53,"coinTipsGroup<UITransform>",-450,[5,1280,720]],[92,"coinTipsGroup<Widget>",45,100,100,1,-451]],[1,0,0,-1]],[1,"obstacle",512,8,[23,10]],[10,512,{},8,[11,"bf4CEPZVpZAbOIxEUDmEgQ",null,null,-455,[13,"06OTf4/r1BfKKiIf8ztOEU",null,[[7,"scene",["_name"],62],[4,["_lpos"],62,[1,0,0,0]],[4,["_lrot"],62,[3,0,0,0,1]],[4,["_euler"],62,[1,0,0,0]],[4,["_lrot"],-452,[3,-0.7071067811865475,0,0,0.7071067811865476]],[4,["_euler"],-453,[1,-90,0,0]],[26,["_materials","0"],69,393],[7,1,["_shadowCastingMode"],69],[7,true,["_active"],-454],[7,true,["_enabled"],69],[7,true,["_active"],62],[7,1,["_shadowReceivingMode"],69]]],392]],[8,["4afZzZEvRQS4QJGOsJEsyM"]],[10,512,{},8,[11,"0dbpdUWKdV57/5BohZgCIy",null,null,-459,[13,"aeN1u9WJFM6JVSX8wL+u0t",null,[[7,"ground",["_name"],70],[4,["_lpos"],70,[1,0,0,0]],[4,["_lrot"],70,[3,0,0,0,1]],[4,["_euler"],70,[1,0,0,0]],[26,["_materials","0"],-456,395],[7,1,["_shadowCastingMode"],-457],[32,true,["_active"],[8,["b4RNNQ3CtW5IuAonPy9jyt"]]],[7,true,["_enabled"],-458]]],394]],[8,["eepWTEwpRTvLhgYPeKaNWU"]],[10,512,{},7,[11,"8cfqruozpbl42VHWNYSqGv",null,null,-460,[13,"14Pt3tWTlG1aaDKfJXosbx",null,[[7,"grass09",["_name"],26],[4,["_lpos"],26,[1,44,0,-18]],[4,["_lrot"],26,[3,0,0,0,1]],[4,["_euler"],26,[1,0,0,0]],[4,["_lscale"],26,[1,2,2,2]],[7,true,["_active"],26]]],442]],[10,512,{},7,[11,"8cfqruozpbl42VHWNYSqGv",null,null,-461,[13,"4965F5OehAxa2B5+tRwUuU",null,[[7,"grass10",["_name"],27],[4,["_lpos"],27,[1,41,0,-12.5]],[4,["_lrot"],27,[3,0,0,0,1]],[4,["_euler"],27,[1,0,0,0]],[4,["_lscale"],27,[1,2,2,2]],[7,true,["_active"],27]]],443]],[10,512,{},7,[11,"8cfqruozpbl42VHWNYSqGv",null,null,-462,[13,"32g1hlt89ICZVIyHwiL45v",null,[[7,"grass11",["_name"],28],[4,["_lpos"],28,[1,44,0,-9.5]],[4,["_lrot"],28,[3,0,0,0,1]],[4,["_euler"],28,[1,0,0,0]],[4,["_lscale"],28,[1,2,2,2]],[7,true,["_active"],28]]],444]],[10,512,{},7,[11,"8cfqruozpbl42VHWNYSqGv",null,null,-463,[13,"17pwTKPEhLXqVWrt4R3khq",null,[[7,"grass13",["_name"],29],[4,["_lpos"],29,[1,41,0,-6.5]],[4,["_lrot"],29,[3,0,0,0,1]],[4,["_euler"],29,[1,0,0,0]],[4,["_lscale"],29,[1,2,2,2]],[7,true,["_active"],29]]],445]],[10,512,{},7,[11,"8cfqruozpbl42VHWNYSqGv",null,null,-464,[13,"82WEFoNf9FuIkWULawpKUR",null,[[7,"grass14",["_name"],30],[4,["_lpos"],30,[1,44,0,-3.5]],[4,["_lrot"],30,[3,0,0,0,1]],[4,["_euler"],30,[1,0,0,0]],[4,["_lscale"],30,[1,2,2,2]],[7,true,["_active"],30]]],446]],[10,512,{},7,[11,"8cfqruozpbl42VHWNYSqGv",null,null,-465,[13,"cbyriDMI9KLJDumQxuweX5",null,[[7,"grass15",["_name"],31],[4,["_lpos"],31,[1,41,0,-0.5]],[4,["_lrot"],31,[3,0,0,0,1]],[4,["_euler"],31,[1,0,0,0]],[4,["_lscale"],31,[1,2,2,2]],[7,true,["_active"],31]]],447]],[10,512,{},7,[11,"8cfqruozpbl42VHWNYSqGv",null,null,-466,[13,"4aZRS2TZBGXqSs3ox+xDB9",null,[[7,"grass16",["_name"],32],[4,["_lpos"],32,[1,44,0,2.5]],[4,["_lrot"],32,[3,0,0,0,1]],[4,["_euler"],32,[1,0,0,0]],[4,["_lscale"],32,[1,2,2,2]],[7,true,["_active"],32]]],448]],[10,512,{},7,[11,"8cfqruozpbl42VHWNYSqGv",null,null,-467,[13,"70FRkD8OJAVZnWGnocBrTA",null,[[32,"grass17",["_name"],[8,["8cfqruozpbl42VHWNYSqGv"]]],[21,["_lpos"],[8,["8cfqruozpbl42VHWNYSqGv"]],[1,41,0,5.5]],[21,["_lrot"],[8,["8cfqruozpbl42VHWNYSqGv"]],[3,0,0,0,1]],[21,["_euler"],[8,["8cfqruozpbl42VHWNYSqGv"]],[1,0,0,0]],[21,["_lscale"],[8,["8cfqruozpbl42VHWNYSqGv"]],[1,2,2,2]],[32,true,["_active"],[8,["8cfqruozpbl42VHWNYSqGv"]]]]],449]],[10,512,{},7,[11,"8cfqruozpbl42VHWNYSqGv",null,null,-468,[13,"688jF10hhG3Y8eq6pSe8cu",null,[[7,"grass18",["_name"],33],[4,["_lpos"],33,[1,44,0,8.5]],[4,["_lrot"],33,[3,0,0,0,1]],[4,["_euler"],33,[1,0,0,0]],[4,["_lscale"],33,[1,2,2,2]],[7,true,["_active"],33]]],450]],[10,512,{},7,[11,"8cfqruozpbl42VHWNYSqGv",null,null,-469,[13,"04a0BjUclN7bsjYptDg2D2",null,[[7,"grass19",["_name"],34],[4,["_lpos"],34,[1,41,0,12]],[4,["_lrot"],34,[3,0,0,0,1]],[4,["_euler"],34,[1,0,0,0]],[4,["_lscale"],34,[1,2,2,2]],[7,true,["_active"],34]]],451]],[10,512,{},7,[11,"8cfqruozpbl42VHWNYSqGv",null,null,-470,[13,"40riYwpRdFBKfJ+PwfP9Bx",null,[[7,"grass20",["_name"],35],[4,["_lpos"],35,[1,44.663,0,16.418]],[4,["_lrot"],35,[3,0,0,0,1]],[4,["_euler"],35,[1,0,0,0]],[4,["_lscale"],35,[1,2,2,2]],[7,true,["_active"],35]]],452]],[10,512,{},7,[11,"8cfqruozpbl42VHWNYSqGv",null,null,-471,[13,"b2gnJt2f5IjZPPCSCIN+f8",null,[[7,"grass21",["_name"],36],[4,["_lpos"],36,[1,60,0,-7.5]],[4,["_lrot"],36,[3,0,0,0,1]],[4,["_euler"],36,[1,0,0,0]],[4,["_lscale"],36,[1,2,2,2]],[7,true,["_active"],36],[21,["_lpos"],[8,["b8S7FZZCJawIrCo8wtFxHH"]],[1,-0.264,0,0]]]],453]],[10,512,{},7,[11,"8cfqruozpbl42VHWNYSqGv",null,null,-472,[13,"27rJ6efgxJJLkhp3dCR0zV",null,[[7,"grass22",["_name"],37],[4,["_lpos"],37,[1,33.9,0,23.26]],[4,["_lrot"],37,[3,0,0,0,1]],[4,["_euler"],37,[1,0,0,0]],[4,["_lscale"],37,[1,2,2,2]],[7,true,["_active"],37]]],454]],[10,512,{},7,[11,"8cfqruozpbl42VHWNYSqGv",null,null,-473,[13,"f95UZ/iwBJcIOv29GipNMC",null,[[7,"grass23",["_name"],38],[4,["_lpos"],38,[1,31.5,0,26.5]],[4,["_lrot"],38,[3,0,0,0,1]],[4,["_euler"],38,[1,0,0,0]],[4,["_lscale"],38,[1,2,2,2]],[7,true,["_active"],38]]],455]],[10,512,{},7,[11,"8cfqruozpbl42VHWNYSqGv",null,null,-474,[13,"e4Nfh+1AJLhZkFgODD9Igc",null,[[7,"grass24",["_name"],39],[4,["_lpos"],39,[1,60,0,-20]],[4,["_lrot"],39,[3,0,0,0,1]],[4,["_euler"],39,[1,0,0,0]],[4,["_lscale"],39,[1,2,2,2]],[7,true,["_active"],39],[21,["_lpos"],[8,["b8S7FZZCJawIrCo8wtFxHH"]],[1,-0.264,0,0]]]],456]],[10,512,{},7,[11,"8cfqruozpbl42VHWNYSqGv",null,null,-475,[13,"66KNHoy8lJOYBo7TLLYQ8z",null,[[7,"grass25",["_name"],40],[4,["_lpos"],40,[1,61,0,0]],[4,["_lrot"],40,[3,0,0,0,1]],[4,["_euler"],40,[1,0,0,0]],[4,["_lscale"],40,[1,2,2,2]],[7,true,["_active"],40],[21,["_lpos"],[8,["b8S7FZZCJawIrCo8wtFxHH"]],[1,-0.264,0,0]]]],457]],[10,512,{},7,[11,"8cfqruozpbl42VHWNYSqGv",null,null,-476,[13,"027yehW2tCtpZEj8bg8BjM",null,[[7,"grass26",["_name"],41],[4,["_lpos"],41,[1,61,0,4]],[4,["_lrot"],41,[3,0,0,0,1]],[4,["_euler"],41,[1,0,0,0]],[4,["_lscale"],41,[1,2,2,2]],[7,true,["_active"],41],[21,["_lpos"],[8,["b8S7FZZCJawIrCo8wtFxHH"]],[1,-0.264,0,0]]]],458]],[10,512,{},7,[11,"8cfqruozpbl42VHWNYSqGv",null,null,-477,[13,"14fg6E2Y9NnYf+5aWrWHej",null,[[7,"grass27",["_name"],42],[4,["_lpos"],42,[1,62,0,7.5]],[4,["_lrot"],42,[3,0,0,0,1]],[4,["_euler"],42,[1,0,0,0]],[4,["_lscale"],42,[1,2,2,2]],[7,true,["_active"],42],[21,["_lpos"],[8,["b8S7FZZCJawIrCo8wtFxHH"]],[1,-0.264,0,0]]]],459]],[10,512,{},6,[11,"8cfqruozpbl42VHWNYSqGv",null,null,-478,[13,"edoxiOfFRDY6H5ndi1Ahyg",null,[[7,"grass10",["_name"],43],[4,["_lpos"],43,[1,-60,0,-20]],[4,["_lrot"],43,[3,0,0,0,1]],[4,["_euler"],43,[1,0,0,0]],[4,["_lscale"],43,[1,2,2,2]],[7,true,["_active"],43]]],460]],[10,512,{},6,[11,"8cfqruozpbl42VHWNYSqGv",null,null,-479,[13,"01qy+Yv6dA/4HRFurnxUpf",null,[[7,"grass11",["_name"],44],[4,["_lpos"],44,[1,-44,0,-18]],[4,["_lrot"],44,[3,0,0,0,1]],[4,["_euler"],44,[1,0,0,0]],[4,["_lscale"],44,[1,2,2,2]],[7,true,["_active"],44]]],461]],[10,512,{},6,[11,"8cfqruozpbl42VHWNYSqGv",null,null,-480,[13,"ceQPsqOGFP7obhmSklgq3d",null,[[7,"grass12",["_name"],45],[4,["_lpos"],45,[1,-44,0,-9.5]],[4,["_lrot"],45,[3,0,0,0,1]],[4,["_euler"],45,[1,0,0,0]],[4,["_lscale"],45,[1,2,2,2]],[7,true,["_active"],45]]],462]],[10,512,{},6,[11,"8cfqruozpbl42VHWNYSqGv",null,null,-481,[13,"0dprbhFNtBFbsEr5F78nYj",null,[[32,"grass13",["_name"],[8,["8cfqruozpbl42VHWNYSqGv"]]],[21,["_lpos"],[8,["8cfqruozpbl42VHWNYSqGv"]],[1,-41,0,-6.5]],[21,["_lrot"],[8,["8cfqruozpbl42VHWNYSqGv"]],[3,0,0,0,1]],[21,["_euler"],[8,["8cfqruozpbl42VHWNYSqGv"]],[1,0,0,0]],[21,["_lscale"],[8,["8cfqruozpbl42VHWNYSqGv"]],[1,2,2,2]],[32,true,["_active"],[8,["8cfqruozpbl42VHWNYSqGv"]]]]],463]],[10,512,{},6,[11,"8cfqruozpbl42VHWNYSqGv",null,null,-482,[13,"68xSdSnPNGnY9UHNLrcyGM",null,[[7,"grass14",["_name"],46],[4,["_lpos"],46,[1,-44,0,-3.5]],[4,["_lrot"],46,[3,0,0,0,1]],[4,["_euler"],46,[1,0,0,0]],[4,["_lscale"],46,[1,2,2,2]],[7,true,["_active"],46]]],464]],[10,512,{},6,[11,"8cfqruozpbl42VHWNYSqGv",null,null,-483,[13,"84BCSEBcBAPZMmbuj+44wJ",null,[[7,"grass15",["_name"],47],[4,["_lpos"],47,[1,-41,0,-0.5]],[4,["_lrot"],47,[3,0,0,0,1]],[4,["_euler"],47,[1,0,0,0]],[4,["_lscale"],47,[1,2,2,2]],[7,true,["_active"],47]]],465]],[10,512,{},6,[11,"8cfqruozpbl42VHWNYSqGv",null,null,-484,[13,"fa++uwqS1HuI2jM60m4IF5",null,[[7,"grass16",["_name"],48],[4,["_lpos"],48,[1,-44,0,2.5]],[4,["_lrot"],48,[3,0,0,0,1]],[4,["_euler"],48,[1,0,0,0]],[4,["_lscale"],48,[1,2,2,2]],[7,true,["_active"],48]]],466]],[10,512,{},6,[11,"8cfqruozpbl42VHWNYSqGv",null,null,-485,[13,"1caBjeiN1D9JwS3gbFaScS",null,[[7,"grass17",["_name"],49],[4,["_lpos"],49,[1,-41,0,5.5]],[4,["_lrot"],49,[3,0,0,0,1]],[4,["_euler"],49,[1,0,0,0]],[4,["_lscale"],49,[1,2,2,2]],[7,true,["_active"],49]]],467]],[10,512,{},6,[11,"8cfqruozpbl42VHWNYSqGv",null,null,-486,[13,"a5vgtRWDZFFaV/nucwP2BJ",null,[[7,"grass18",["_name"],50],[4,["_lpos"],50,[1,-61,0,-7.5]],[4,["_lrot"],50,[3,0,0,0,1]],[4,["_euler"],50,[1,0,0,0]],[4,["_lscale"],50,[1,2,2,2]],[7,true,["_active"],50]]],468]],[10,512,{},6,[11,"8cfqruozpbl42VHWNYSqGv",null,null,-487,[13,"61V26srrRNx4kYBXUSWzr5",null,[[7,"grass19",["_name"],51],[4,["_lpos"],51,[1,-44,0,8.5]],[4,["_lrot"],51,[3,0,0,0,1]],[4,["_euler"],51,[1,0,0,0]],[4,["_lscale"],51,[1,2,2,2]],[7,true,["_active"],51]]],469]],[10,512,{},6,[11,"8cfqruozpbl42VHWNYSqGv",null,null,-488,[13,"c4f944pr9AnpDc44J41Mzb",null,[[7,"grass20",["_name"],52],[4,["_lpos"],52,[1,-41,0,12]],[4,["_lrot"],52,[3,0,0,0,1]],[4,["_euler"],52,[1,0,0,0]],[4,["_lscale"],52,[1,2,2,2]],[7,true,["_active"],52]]],470]],[10,512,{},6,[11,"8cfqruozpbl42VHWNYSqGv",null,null,-489,[13,"c0SOztzLNJk5Ju0WYMWB6g",null,[[7,"grass22",["_name"],53],[4,["_lpos"],53,[1,-38,0,23]],[4,["_lrot"],53,[3,0,0,0,1]],[4,["_euler"],53,[1,0,0,0]],[4,["_lscale"],53,[1,2,2,2]],[7,true,["_active"],53]]],471]],[10,512,{},6,[11,"8cfqruozpbl42VHWNYSqGv",null,null,-490,[13,"d4CIuHB/9DbpNecCKZK5lI",null,[[7,"grass23",["_name"],54],[4,["_lpos"],54,[1,-44,0,17.5]],[4,["_lrot"],54,[3,0,0,0,1]],[4,["_euler"],54,[1,0,0,0]],[4,["_lscale"],54,[1,2,2,2]],[7,true,["_active"],54]]],472]],[10,512,{},6,[11,"8cfqruozpbl42VHWNYSqGv",null,null,-491,[13,"273V17aydJ2KLshEMHZELq",null,[[7,"grass27",["_name"],55],[4,["_lpos"],55,[1,-38,0,-25.5]],[4,["_lrot"],55,[3,0,0,0,1]],[4,["_euler"],55,[1,0,0,0]],[4,["_lscale"],55,[1,2,2,2]],[7,true,["_active"],55]]],473]],[10,512,{},6,[11,"8cfqruozpbl42VHWNYSqGv",null,null,-492,[13,"20iV8g7QtMo5smkBZoDSMA",null,[[7,"grass28",["_name"],56],[4,["_lpos"],56,[1,-41,0,-12.5]],[4,["_lrot"],56,[3,0,0,0,1]],[4,["_euler"],56,[1,0,0,0]],[4,["_lscale"],56,[1,2,2,2]],[7,true,["_active"],56]]],474]],[10,512,{},6,[11,"8cfqruozpbl42VHWNYSqGv",null,null,-493,[13,"02RMbAt/NFTZzpIFmne8Ff",null,[[7,"grass29",["_name"],57],[4,["_lpos"],57,[1,38,0,-25.5]],[4,["_lrot"],57,[3,0,0,0,1]],[4,["_euler"],57,[1,0,0,0]],[4,["_lscale"],57,[1,2,2,2]],[7,true,["_active"],57]]],475]],[10,512,{},6,[11,"8cfqruozpbl42VHWNYSqGv",null,null,-494,[13,"8ft80gDlhJe6FsSJawc9zS",null,[[7,"grass21",["_name"],58],[4,["_lpos"],58,[1,-56.058,0,8.983]],[4,["_lrot"],58,[3,0,0,0,1]],[4,["_euler"],58,[1,0,0,0]],[4,["_lscale"],58,[1,2,2,2]],[7,true,["_active"],58]]],476]],[10,512,{},6,[11,"8cfqruozpbl42VHWNYSqGv",null,null,-495,[13,"73+eo5qnNCO50eZjY8Xg4a",null,[[7,"grass24",["_name"],59],[4,["_lpos"],59,[1,-57.5,0,0.6]],[4,["_lrot"],59,[3,0,0,0,1]],[4,["_euler"],59,[1,0,0,0]],[4,["_lscale"],59,[1,2,2,2]],[7,true,["_active"],59]]],477]],[10,512,{},6,[11,"8cfqruozpbl42VHWNYSqGv",null,null,-496,[13,"f6faL8M6VPQ4ocmhEvcjqg",null,[[7,"grass25",["_name"],60],[4,["_lpos"],60,[1,-57.5,0,4]],[4,["_lrot"],60,[3,0,0,0,1]],[4,["_euler"],60,[1,0,0,0]],[4,["_lscale"],60,[1,2,2,2]],[7,true,["_active"],60]]],478]],[10,512,{},8,[11,"40Omc9e0ZDk69G+gmoWuGO",null,null,-497,[13,"92jG2a7NNAeJVPAh6sH680",null,[[7,"busSignGroup",["_name"],63],[4,["_lpos"],63,[1,0,0,0]],[4,["_lrot"],63,[3,0,0,0,1]],[4,["_euler"],63,[1,0,0,0]],[21,["_lpos"],[8,["1ekCiRoXhDj5eSaKQtVgpC","f8bVItO3RZWL0ob30d0xnq"]],[1,40.354,0,-36.131]],[21,["_lpos"],[8,["7aE3F20M5NE57e9d+pYSSJ","f8bVItO3RZWL0ob30d0xnq"]],[1,-49.01,0,-31.57]],[7,true,["_active"],63]]],501]],[10,512,{},8,[11,"f8/ovBRwtez4dn95UVWJl2",null,null,-500,[13,"02u1CoH5xHU44sbUi7mdYX",null,[[7,"fishBox",["_name"],64],[4,["_lpos"],64,[1,-47.77,6.782,-45.275]],[4,["_lrot"],64,[3,0,0.7071067811865475,0,0.7071067811865476]],[4,["_euler"],64,[1,0,90,0]],[7,true,["_active"],64],[7,0,["_shadowCastingMode"],-498],[7,1,["_shadowReceivingMode"],-499]]],502]],[10,512,{},8,[11,"f6kpByWxdIZIwPkw5K8lyS",null,null,-501,[13,"07daT42ZtIT4Qhmi5A5bwR",null,[[7,"fishBoneGroup",["_name"],71],[4,["_lpos"],71,[1,0,0,0]],[4,["_lrot"],71,[3,0,0,0,1]],[4,["_euler"],71,[1,0,0,0]],[21,["_lpos"],[8,["49jmB0AJBONLNA3PEnzANk","dbOPg73aZd84HLIpJi6hXs"]],[1,-49.933,0,45.519]],[21,["_lpos"],[8,["ccsg/q7CFNNZGm+PVBzoI5","dbOPg73aZd84HLIpJi6hXs"]],[1,-45.939,0,47.331]],[21,["_lpos"],[8,["1f08yXxcdEWb4Oq6FnQrjD","dbOPg73aZd84HLIpJi6hXs"]],[1,17.863,0,43.942]]]],503]],[46,"dislog",512,33554432,67,[[39,-502,[5,1280,720]],[40,45,100,100,-503]]],[46,"tip",512,33554432,67,[[39,-504,[5,1280,720]],[40,45,100,100,-505]]],[37,"RootNode",512,[22],[[54,true,-506,[673],674]]],[37,"RootNode",512,[-508],[[54,true,-507,[677],678]]],[64,"Main Light",512,"b420yRSR1CfZKMcdM4V1Pc",11,[[97,6500,51000,3.6458333333333335,true,3,0.0001,85,1,300,30,-509,[98]]],[1,-10.003,45,-17.706],[3,-0.573210904327122,-0.02931994106066347,0.020533604153610434,0.8186256600651761],[1,-69.953,-1.405,3.855]],[6,"vat1",512,23,[-510],[1,-47,-0.151,-6],[1,1.6,1.6,1.6]],[1,"RootNode",512,124,[-511]],[25,"vat1",512,125,[[14,1,-512,[0],[35,true,true,true],1]],[1,0.144378006458282,0.144378006458282,0.144378006458282],[1,0.000009334667642611398,0,0]],[6,"vat1",512,23,[-513],[1,-47,-0.151,5.5],[1,1.6,1.6,1.6]],[1,"RootNode",512,127,[-514]],[25,"vat1",512,128,[[14,1,-515,[2],[35,true,true,true],3]],[1,0.144378006458282,0.144378006458282,0.144378006458282],[1,0.000009334667642611398,0,0]],[6,"vat1",512,23,[-516],[1,47,-0.151,-6],[1,1.6,1.6,1.6]],[1,"RootNode",512,130,[-517]],[25,"vat1",512,131,[[14,1,-518,[4],[35,true,true,true],5]],[1,0.144378006458282,0.144378006458282,0.144378006458282],[1,0.000009334667642611398,0,0]],[6,"vat1",512,23,[-519],[1,47,-0.151,5.5],[1,1.6,1.6,1.6]],[1,"RootNode",512,133,[-520]],[25,"vat1",512,134,[[14,1,-521,[6],[35,true,true,true],7]],[1,0.144378006458282,0.144378006458282,0.144378006458282],[1,0.000009334667642611398,0,0]],[6,"box",512,12,[-522],[1,-24,-0.25,4.2],[1,1.8,1.8,1.8]],[1,"RootNode",512,136,[-523]],[3,"box",512,137,[[5,1,-524,[2,"13AVcqg7ZYobsY61MC/B4/"],[8],[0],9]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,12,[-525],[1,-24,-0.25,2.4],[1,1.8,1.8,1.8]],[1,"RootNode",512,139,[-526]],[3,"box",512,140,[[5,1,-527,[2,"13AVcqg7ZYobsY61MC/B4/"],[10],[0],11]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,12,[-528],[1,-24,-0.25,0.6],[1,1.8,1.8,1.8]],[1,"RootNode",512,142,[-529]],[3,"box",512,143,[[5,1,-530,[2,"13AVcqg7ZYobsY61MC/B4/"],[12],[0],13]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,12,[-531],[1,-24,-0.25,-1.2],[1,1.8,1.8,1.8]],[1,"RootNode",512,145,[-532]],[3,"box",512,146,[[5,1,-533,[2,"13AVcqg7ZYobsY61MC/B4/"],[14],[0],15]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,12,[-534],[1,-24,-0.25,-3],[1,1.8,1.8,1.8]],[1,"RootNode",512,148,[-535]],[3,"box",512,149,[[5,1,-536,[2,"13AVcqg7ZYobsY61MC/B4/"],[16],[0],17]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,12,[-537],[1,-24,-0.25,-4.8],[1,1.8,1.8,1.8]],[1,"RootNode",512,151,[-538]],[3,"box",512,152,[[18,-539,[2,"13AVcqg7ZYobsY61MC/B4/"],[18],[0],19]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,12,[-540],[1,-24,-0.25,6.029],[1,1.8,1.8,1.8]],[1,"RootNode",512,154,[-541]],[3,"box",512,155,[[5,1,-542,[2,"13AVcqg7ZYobsY61MC/B4/"],[20],[0],21]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,13,[-543],[1,24,-0.25,4.2],[1,1.8,1.8,1.8]],[1,"RootNode",512,157,[-544]],[3,"box",512,158,[[5,1,-545,[2,"13AVcqg7ZYobsY61MC/B4/"],[22],[0],23]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,13,[-546],[1,24,-0.25,2.4],[1,1.8,1.8,1.8]],[1,"RootNode",512,160,[-547]],[3,"box",512,161,[[5,1,-548,[2,"13AVcqg7ZYobsY61MC/B4/"],[24],[0],25]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,13,[-549],[1,24,-0.25,0.6],[1,1.8,1.8,1.8]],[1,"RootNode",512,163,[-550]],[3,"box",512,164,[[5,1,-551,[2,"13AVcqg7ZYobsY61MC/B4/"],[26],[0],27]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,13,[-552],[1,24,-0.25,-1.2],[1,1.8,1.8,1.8]],[1,"RootNode",512,166,[-553]],[3,"box",512,167,[[5,1,-554,[2,"13AVcqg7ZYobsY61MC/B4/"],[28],[0],29]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,13,[-555],[1,24,-0.25,-3],[1,1.8,1.8,1.8]],[1,"RootNode",512,169,[-556]],[3,"box",512,170,[[5,1,-557,[2,"13AVcqg7ZYobsY61MC/B4/"],[30],[0],31]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,13,[-558],[1,24,-0.25,-4.8],[1,1.8,1.8,1.8]],[1,"RootNode",512,172,[-559]],[3,"box",512,173,[[18,-560,[2,"13AVcqg7ZYobsY61MC/B4/"],[32],[0],33]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,13,[-561],[1,24,-0.25,6.029],[1,1.8,1.8,1.8]],[1,"RootNode",512,175,[-562]],[3,"box",512,176,[[5,1,-563,[2,"13AVcqg7ZYobsY61MC/B4/"],[34],[0],35]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[76,"box",512,14,[[33,"RootNode",512,-564]],[1,9.187,-0.25,-20.8],[1,1.8,1.8,1.8]],[6,"box",512,14,[-565],[1,10,-0.25,-20.8],[1,1.8,1.8,1.8]],[1,"RootNode",512,179,[-566]],[3,"box",512,180,[[18,-567,[2,"13AVcqg7ZYobsY61MC/B4/"],[36],[0],37]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,14,[-568],[1,13.6,-0.25,-20.8],[1,1.8,1.8,1.8]],[1,"RootNode",512,182,[-569]],[3,"box",512,183,[[18,-570,[2,"13AVcqg7ZYobsY61MC/B4/"],[38],[0],39]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,14,[-571],[1,-10,-0.25,-20.8],[1,1.8,1.8,1.8]],[1,"RootNode",512,185,[-572]],[3,"box",512,186,[[5,1,-573,[2,"13AVcqg7ZYobsY61MC/B4/"],[40],[0],41]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,14,[-574],[1,-11.8,-0.25,-20.8],[1,1.8,1.8,1.8]],[1,"RootNode",512,188,[-575]],[3,"box",512,189,[[5,1,-576,[2,"13AVcqg7ZYobsY61MC/B4/"],[42],[0],43]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,14,[-577],[1,-13.6,-0.25,-20.8],[1,1.8,1.8,1.8]],[1,"RootNode",512,191,[-578]],[3,"box",512,192,[[5,1,-579,[2,"13AVcqg7ZYobsY61MC/B4/"],[44],[0],45]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,14,[-580],[1,11.8,-0.25,-20.8],[1,1.8,1.8,1.8]],[1,"RootNode",512,194,[-581]],[3,"box",512,195,[[18,-582,[2,"13AVcqg7ZYobsY61MC/B4/"],[46],[0],47]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,61,[-583],[1,11.8,-0.25,18.6],[1,1.8,1.8,1.8]],[1,"RootNode",512,197,[-584]],[3,"box",512,198,[[18,-585,[2,"13AVcqg7ZYobsY61MC/B4/"],[48],[0],49]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,61,[-586],[1,10.002,-0.25,18.6],[1,1.8,1.8,1.8]],[1,"RootNode",512,200,[-587]],[3,"box",512,201,[[18,-588,[2,"13AVcqg7ZYobsY61MC/B4/"],[50],[0],51]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,61,[-589],[1,-10,-0.25,18.6],[1,1.8,1.8,1.8]],[1,"RootNode",512,203,[-590]],[3,"box",512,204,[[5,1,-591,[2,"13AVcqg7ZYobsY61MC/B4/"],[52],[0],53]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,61,[-592],[1,-11.8,-0.25,18.6],[1,1.8,1.8,1.8]],[1,"RootNode",512,206,[-593]],[3,"box",512,207,[[5,1,-594,[2,"13AVcqg7ZYobsY61MC/B4/"],[54],[0],55]],[3,-0.7071067811865477,0,0,0.7071067811865474],[1,-90.00000000000003,0,0]],[6,"box",512,16,[-595],[1,-47,-0.25,-8],[1,1.8,1.8,1.8]],[1,"RootNode",512,209,[-596]],[3,"box",512,210,[[18,-597,[2,"13AVcqg7ZYobsY61MC/B4/"],[56],[0],57]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,16,[-598],[1,-47,-0.25,-9.8],[1,1.8,1.8,1.8]],[1,"RootNode",512,212,[-599]],[3,"box",512,213,[[18,-600,[2,"13AVcqg7ZYobsY61MC/B4/"],[58],[0],59]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,16,[-601],[1,-47,-0.25,-11.6],[1,1.8,1.8,1.8]],[1,"RootNode",512,215,[-602]],[3,"box",512,216,[[18,-603,[2,"13AVcqg7ZYobsY61MC/B4/"],[60],[0],61]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,16,[-604],[1,-47,-0.25,9.2],[1,1.8,1.8,1.8]],[1,"RootNode",512,218,[-605]],[3,"box",512,219,[[5,1,-606,[2,"13AVcqg7ZYobsY61MC/B4/"],[62],[0],63]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,16,[-607],[1,-47,-0.25,11],[1,1.8,1.8,1.8]],[1,"RootNode",512,221,[-608]],[3,"box",512,222,[[5,1,-609,[2,"13AVcqg7ZYobsY61MC/B4/"],[64],[0],65]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,16,[-610],[1,-47,-0.25,7.4],[1,1.8,1.8,1.8]],[1,"RootNode",512,224,[-611]],[3,"box",512,225,[[5,1,-612,[2,"13AVcqg7ZYobsY61MC/B4/"],[66],[0],67]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,17,[-613],[1,47,-0.25,-9.8],[1,1.8,1.8,1.8]],[1,"RootNode",512,227,[-614]],[3,"box",512,228,[[18,-615,[2,"13AVcqg7ZYobsY61MC/B4/"],[68],[0],69]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,17,[-616],[1,47,-0.25,-11.6],[1,1.8,1.8,1.8]],[1,"RootNode",512,230,[-617]],[3,"box",512,231,[[18,-618,[2,"13AVcqg7ZYobsY61MC/B4/"],[70],[0],71]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,17,[-619],[1,47,-0.25,9.2],[1,1.8,1.8,1.8]],[1,"RootNode",512,233,[-620]],[3,"box",512,234,[[5,1,-621,[2,"13AVcqg7ZYobsY61MC/B4/"],[72],[0],73]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,17,[-622],[1,47,-0.25,11],[1,1.8,1.8,1.8]],[1,"RootNode",512,236,[-623]],[3,"box",512,237,[[5,1,-624,[2,"13AVcqg7ZYobsY61MC/B4/"],[74],[0],75]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,17,[-625],[1,47,-0.25,-8],[1,1.8,1.8,1.8]],[1,"RootNode",512,239,[-626]],[3,"box",512,240,[[18,-627,[2,"13AVcqg7ZYobsY61MC/B4/"],[76],[0],77]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,17,[-628],[1,47,-0.25,7.4],[1,1.8,1.8,1.8]],[1,"RootNode",512,242,[-629]],[3,"box",512,243,[[5,1,-630,[2,"13AVcqg7ZYobsY61MC/B4/"],[78],[0],79]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,3,[-631],[1,-5.4,-0.25,0],[1,1.8,1.8,1.8]],[1,"RootNode",512,245,[-632]],[3,"box",512,246,[[5,1,-633,[2,"13AVcqg7ZYobsY61MC/B4/"],[80],[0],81]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,3,[-634],[1,-3.6,-0.25,0],[1,1.8,1.8,1.8]],[1,"RootNode",512,248,[-635]],[3,"box",512,249,[[5,1,-636,[2,"13AVcqg7ZYobsY61MC/B4/"],[82],[0],83]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,3,[-637],[1,-1.8,-0.25,0],[1,1.8,1.8,1.8]],[1,"RootNode",512,251,[-638]],[3,"box",512,252,[[5,1,-639,[2,"13AVcqg7ZYobsY61MC/B4/"],[84],[0],85]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,3,[-640],[1,0,-0.25,0],[1,1.8,1.8,1.8]],[1,"RootNode",512,254,[-641]],[3,"box",512,255,[[5,1,-642,[2,"13AVcqg7ZYobsY61MC/B4/"],[86],[0],87]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,3,[-643],[1,1.8,-0.25,0],[1,1.8,1.8,1.8]],[1,"RootNode",512,257,[-644]],[3,"box",512,258,[[5,1,-645,[2,"13AVcqg7ZYobsY61MC/B4/"],[88],[0],89]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,3,[-646],[1,3.6,-0.25,0],[1,1.8,1.8,1.8]],[1,"RootNode",512,260,[-647]],[3,"box",512,261,[[18,-648,[2,"13AVcqg7ZYobsY61MC/B4/"],[90],[0],91]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,3,[-649],[1,5.4,-0.25,0],[1,1.8,1.8,1.8]],[1,"RootNode",512,263,[-650]],[3,"box",512,264,[[18,-651,[2,"13AVcqg7ZYobsY61MC/B4/"],[92],[0],93]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,3,[-652],[1,7.2,-0.25,0],[1,1.8,1.8,1.8]],[1,"RootNode",512,266,[-653]],[3,"box",512,267,[[18,-654,[2,"13AVcqg7ZYobsY61MC/B4/"],[94],[0],95]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,3,[-655],[1,9,-0.25,-3.552713678800501e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,269,[-656]],[3,"box",512,270,[[5,1,-657,[2,"13AVcqg7ZYobsY61MC/B4/"],[96],[0],97]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,3,[-658],[1,-7.2,-0.25,0],[1,1.8,1.8,1.8]],[1,"RootNode",512,272,[-659]],[3,"box",512,273,[[5,1,-660,[2,"13AVcqg7ZYobsY61MC/B4/"],[98],[0],99]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,3,[-661],[1,-10.8,-0.25,3.552713678800501e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,275,[-662]],[3,"box",512,276,[[5,1,-663,[2,"13AVcqg7ZYobsY61MC/B4/"],[100],[0],101]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,3,[-664],[1,-12.6,-0.25,3.552713678800501e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,278,[-665]],[3,"box",512,279,[[5,1,-666,[2,"13AVcqg7ZYobsY61MC/B4/"],[102],[0],103]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,3,[-667],[1,-14.4,-0.25,3.552713678800501e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,281,[-668]],[3,"box",512,282,[[5,1,-669,[2,"13AVcqg7ZYobsY61MC/B4/"],[104],[0],105]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,3,[-670],[1,12.6,-0.25,-3.552713678800501e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,284,[-671]],[3,"box",512,285,[[5,1,-672,[2,"13AVcqg7ZYobsY61MC/B4/"],[106],[0],107]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,3,[-673],[1,14.4,-0.25,-3.552713678800501e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,287,[-674]],[3,"box",512,288,[[5,1,-675,[2,"13AVcqg7ZYobsY61MC/B4/"],[108],[0],109]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,3,[-676],[1,16.2,-0.25,-3.552713678800501e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,290,[-677]],[3,"box",512,291,[[5,1,-678,[2,"13AVcqg7ZYobsY61MC/B4/"],[110],[0],111]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,3,[-679],[1,18,-0.25,-3.552713678800501e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,293,[-680]],[3,"box",512,294,[[5,1,-681,[2,"13AVcqg7ZYobsY61MC/B4/"],[112],[0],113]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,3,[-682],[1,19.8,-0.25,-3.552713678800501e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,296,[-683]],[3,"box",512,297,[[5,1,-684,[2,"13AVcqg7ZYobsY61MC/B4/"],[114],[0],115]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,3,[-685],[1,21.6,-0.25,-3.552713678800501e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,299,[-686]],[3,"box",512,300,[[5,1,-687,[2,"13AVcqg7ZYobsY61MC/B4/"],[116],[0],117]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,3,[-688],[1,23.4,-0.25,-3.552713678800501e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,302,[-689]],[3,"box",512,303,[[5,1,-690,[2,"13AVcqg7ZYobsY61MC/B4/"],[118],[0],119]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,3,[-691],[1,25.2,-0.25,-7.105427357601002e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,305,[-692]],[3,"box",512,306,[[5,1,-693,[2,"13AVcqg7ZYobsY61MC/B4/"],[120],[0],121]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,3,[-694],[1,27,-0.25,-7.105427357601002e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,308,[-695]],[3,"box",512,309,[[5,1,-696,[2,"13AVcqg7ZYobsY61MC/B4/"],[122],[0],123]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,3,[-697],[1,-16.2,-0.25,3.552713678800501e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,311,[-698]],[3,"box",512,312,[[5,1,-699,[2,"13AVcqg7ZYobsY61MC/B4/"],[124],[0],125]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,3,[-700],[1,-18,-0.25,3.552713678800501e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,314,[-701]],[3,"box",512,315,[[5,1,-702,[2,"13AVcqg7ZYobsY61MC/B4/"],[126],[0],127]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,3,[-703],[1,-19.8,-0.25,3.552713678800501e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,317,[-704]],[3,"box",512,318,[[5,1,-705,[2,"13AVcqg7ZYobsY61MC/B4/"],[128],[0],129]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,3,[-706],[1,-21.6,-0.25,3.552713678800501e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,320,[-707]],[3,"box",512,321,[[5,1,-708,[2,"13AVcqg7ZYobsY61MC/B4/"],[130],[0],131]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,3,[-709],[1,-23.4,-0.25,3.552713678800501e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,323,[-710]],[3,"box",512,324,[[5,1,-711,[2,"13AVcqg7ZYobsY61MC/B4/"],[132],[0],133]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,3,[-712],[1,-25.2,-0.25,7.105427357601002e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,326,[-713]],[3,"box",512,327,[[5,1,-714,[2,"13AVcqg7ZYobsY61MC/B4/"],[134],[0],135]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,3,[-715],[1,-27,-0.25,7.105427357601002e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,329,[-716]],[3,"box",512,330,[[5,1,-717,[2,"13AVcqg7ZYobsY61MC/B4/"],[136],[0],137]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,3,[-718],[1,-28.8,-0.25,7.105427357601002e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,332,[-719]],[3,"box",512,333,[[5,1,-720,[2,"13AVcqg7ZYobsY61MC/B4/"],[138],[0],139]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,3,[-721],[1,-30.6,-0.25,7.105427357601002e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,335,[-722]],[3,"box",512,336,[[5,1,-723,[2,"13AVcqg7ZYobsY61MC/B4/"],[140],[0],141]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,3,[-724],[1,-9,-0.25,3.552713678800501e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,338,[-725]],[3,"box",512,339,[[5,1,-726,[2,"13AVcqg7ZYobsY61MC/B4/"],[142],[0],143]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,3,[-727],[1,10.8,-0.25,-3.552713678800501e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,341,[-728]],[3,"box",512,342,[[5,1,-729,[2,"13AVcqg7ZYobsY61MC/B4/"],[144],[0],145]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,3,[-730],[1,28.8,-0.25,0],[1,1.8,1.8,1.8]],[1,"RootNode",512,344,[-731]],[3,"box",512,345,[[5,1,-732,[2,"13AVcqg7ZYobsY61MC/B4/"],[146],[0],147]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box-001",512,3,[-733],[1,30.6,-0.25,0],[1,1.8,1.8,1.8]],[1,"RootNode",512,347,[-734]],[3,"box",512,348,[[5,1,-735,[2,"13AVcqg7ZYobsY61MC/B4/"],[148],[0],149]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,4,[-736],[1,-5.4,-0.25,0],[1,1.8,1.8,1.8]],[1,"RootNode",512,350,[-737]],[3,"box",512,351,[[5,1,-738,[2,"13AVcqg7ZYobsY61MC/B4/"],[150],[0],151]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,4,[-739],[1,-3.6,-0.25,0],[1,1.8,1.8,1.8]],[1,"RootNode",512,353,[-740]],[3,"box",512,354,[[5,1,-741,[2,"13AVcqg7ZYobsY61MC/B4/"],[152],[0],153]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,4,[-742],[1,-1.8,-0.25,0],[1,1.8,1.8,1.8]],[1,"RootNode",512,356,[-743]],[3,"box",512,357,[[5,1,-744,[2,"13AVcqg7ZYobsY61MC/B4/"],[154],[0],155]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,4,[-745],[1,0,-0.25,0],[1,1.8,1.8,1.8]],[1,"RootNode",512,359,[-746]],[3,"box",512,360,[[5,1,-747,[2,"13AVcqg7ZYobsY61MC/B4/"],[156],[0],157]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,4,[-748],[1,1.8,-0.25,0],[1,1.8,1.8,1.8]],[1,"RootNode",512,362,[-749]],[3,"box",512,363,[[5,1,-750,[2,"13AVcqg7ZYobsY61MC/B4/"],[158],[0],159]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,4,[-751],[1,3.6,-0.25,0],[1,1.8,1.8,1.8]],[1,"RootNode",512,365,[-752]],[3,"box",512,366,[[18,-753,[2,"13AVcqg7ZYobsY61MC/B4/"],[160],[0],161]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,4,[-754],[1,5.4,-0.25,0],[1,1.8,1.8,1.8]],[1,"RootNode",512,368,[-755]],[3,"box",512,369,[[18,-756,[2,"13AVcqg7ZYobsY61MC/B4/"],[162],[0],163]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,4,[-757],[1,7.2,-0.25,0],[1,1.8,1.8,1.8]],[1,"RootNode",512,371,[-758]],[3,"box",512,372,[[18,-759,[2,"13AVcqg7ZYobsY61MC/B4/"],[164],[0],165]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,4,[-760],[1,9,-0.25,-3.552713678800501e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,374,[-761]],[3,"box",512,375,[[5,1,-762,[2,"13AVcqg7ZYobsY61MC/B4/"],[166],[0],167]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,4,[-763],[1,-7.2,-0.25,0],[1,1.8,1.8,1.8]],[1,"RootNode",512,377,[-764]],[3,"box",512,378,[[5,1,-765,[2,"13AVcqg7ZYobsY61MC/B4/"],[168],[0],169]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,4,[-766],[1,-10.8,-0.25,3.552713678800501e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,380,[-767]],[3,"box",512,381,[[5,1,-768,[2,"13AVcqg7ZYobsY61MC/B4/"],[170],[0],171]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,4,[-769],[1,-12.6,-0.25,3.552713678800501e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,383,[-770]],[3,"box",512,384,[[5,1,-771,[2,"13AVcqg7ZYobsY61MC/B4/"],[172],[0],173]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,4,[-772],[1,-14.4,-0.25,3.552713678800501e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,386,[-773]],[3,"box",512,387,[[5,1,-774,[2,"13AVcqg7ZYobsY61MC/B4/"],[174],[0],175]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,4,[-775],[1,12.6,-0.25,-3.552713678800501e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,389,[-776]],[3,"box",512,390,[[5,1,-777,[2,"13AVcqg7ZYobsY61MC/B4/"],[176],[0],177]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,4,[-778],[1,14.4,-0.25,-3.552713678800501e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,392,[-779]],[3,"box",512,393,[[5,1,-780,[2,"13AVcqg7ZYobsY61MC/B4/"],[178],[0],179]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,4,[-781],[1,16.2,-0.25,-3.552713678800501e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,395,[-782]],[3,"box",512,396,[[5,1,-783,[2,"13AVcqg7ZYobsY61MC/B4/"],[180],[0],181]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,4,[-784],[1,18,-0.25,-3.552713678800501e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,398,[-785]],[3,"box",512,399,[[5,1,-786,[2,"13AVcqg7ZYobsY61MC/B4/"],[182],[0],183]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,4,[-787],[1,19.8,-0.25,-3.552713678800501e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,401,[-788]],[3,"box",512,402,[[5,1,-789,[2,"13AVcqg7ZYobsY61MC/B4/"],[184],[0],185]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,4,[-790],[1,21.6,-0.25,-3.552713678800501e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,404,[-791]],[3,"box",512,405,[[5,1,-792,[2,"13AVcqg7ZYobsY61MC/B4/"],[186],[0],187]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,4,[-793],[1,23.4,-0.25,-3.552713678800501e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,407,[-794]],[3,"box",512,408,[[5,1,-795,[2,"13AVcqg7ZYobsY61MC/B4/"],[188],[0],189]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,4,[-796],[1,25.2,-0.25,-7.105427357601002e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,410,[-797]],[3,"box",512,411,[[5,1,-798,[2,"13AVcqg7ZYobsY61MC/B4/"],[190],[0],191]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,4,[-799],[1,27,-0.25,-7.105427357601002e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,413,[-800]],[3,"box",512,414,[[5,1,-801,[2,"13AVcqg7ZYobsY61MC/B4/"],[192],[0],193]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,4,[-802],[1,-16.2,-0.25,3.552713678800501e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,416,[-803]],[3,"box",512,417,[[5,1,-804,[2,"13AVcqg7ZYobsY61MC/B4/"],[194],[0],195]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,4,[-805],[1,-18,-0.25,3.552713678800501e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,419,[-806]],[3,"box",512,420,[[5,1,-807,[2,"13AVcqg7ZYobsY61MC/B4/"],[196],[0],197]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,4,[-808],[1,-19.8,-0.25,3.552713678800501e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,422,[-809]],[3,"box",512,423,[[5,1,-810,[2,"13AVcqg7ZYobsY61MC/B4/"],[198],[0],199]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,4,[-811],[1,-21.6,-0.25,3.552713678800501e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,425,[-812]],[3,"box",512,426,[[5,1,-813,[2,"13AVcqg7ZYobsY61MC/B4/"],[200],[0],201]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,4,[-814],[1,-23.4,-0.25,3.552713678800501e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,428,[-815]],[3,"box",512,429,[[5,1,-816,[2,"13AVcqg7ZYobsY61MC/B4/"],[202],[0],203]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,4,[-817],[1,-25.2,-0.25,7.105427357601002e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,431,[-818]],[3,"box",512,432,[[5,1,-819,[2,"13AVcqg7ZYobsY61MC/B4/"],[204],[0],205]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,4,[-820],[1,-27,-0.25,7.105427357601002e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,434,[-821]],[3,"box",512,435,[[5,1,-822,[2,"13AVcqg7ZYobsY61MC/B4/"],[206],[0],207]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,4,[-823],[1,-28.8,-0.25,7.105427357601002e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,437,[-824]],[3,"box",512,438,[[5,1,-825,[2,"13AVcqg7ZYobsY61MC/B4/"],[208],[0],209]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,4,[-826],[1,-30.6,-0.25,7.105427357601002e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,440,[-827]],[3,"box",512,441,[[5,1,-828,[2,"13AVcqg7ZYobsY61MC/B4/"],[210],[0],211]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,4,[-829],[1,-9,-0.25,3.552713678800501e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,443,[-830]],[3,"box",512,444,[[5,1,-831,[2,"13AVcqg7ZYobsY61MC/B4/"],[212],[0],213]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"box",512,4,[-832],[1,10.8,-0.25,-3.552713678800501e-15],[1,1.8,1.8,1.8]],[1,"RootNode",512,446,[-833]],[3,"box",512,447,[[5,1,-834,[2,"13AVcqg7ZYobsY61MC/B4/"],[214],[0],215]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-835],[1,-18.6,0,-6],[3,0,1,0,-2.2204460492503128e-16],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-179.99999999999997,0]],[1,"RootNode",512,449,[-836]],[3,"stone",512,450,[[5,1,-837,[2,"750CzYu+lfVL2quXBrUJJL"],[216],[0],217]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-838],[1,-18.6,0,-4],[3,0,1,0,-2.2204460492503128e-16],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-179.99999999999997,0]],[1,"RootNode",512,452,[-839]],[3,"stone",512,453,[[5,1,-840,[2,"750CzYu+lfVL2quXBrUJJL"],[218],[0],219]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-841],[1,-18.6,0,-2],[3,0,1,0,-2.2204460492503128e-16],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-179.99999999999997,0]],[1,"RootNode",512,455,[-842]],[3,"stone",512,456,[[5,1,-843,[2,"750CzYu+lfVL2quXBrUJJL"],[220],[0],221]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-844],[1,-18.6,0,0],[3,0,-1,0,2.83276944882399e-16],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-179.99999999999997,0]],[1,"RootNode",512,458,[-845]],[3,"stone",512,459,[[5,1,-846,[2,"750CzYu+lfVL2quXBrUJJL"],[222],[0],223]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-847],[1,-18.6,0,-8],[3,0,1,0,-2.2204460492503128e-16],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-179.99999999999997,0]],[1,"RootNode",512,461,[-848]],[3,"stone",512,462,[[5,1,-849,[2,"750CzYu+lfVL2quXBrUJJL"],[224],[0],225]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-850],[1,-18.6,0,2],[3,0,1,0,-2.2204460492503128e-16],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-179.99999999999997,0]],[1,"RootNode",512,464,[-851]],[3,"stone",512,465,[[5,1,-852,[2,"750CzYu+lfVL2quXBrUJJL"],[226],[0],227]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-853],[1,-18.6,0,4],[3,0,1,0,-2.2204460492503128e-16],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-179.99999999999997,0]],[1,"RootNode",512,467,[-854]],[3,"stone",512,468,[[5,1,-855,[2,"750CzYu+lfVL2quXBrUJJL"],[228],[0],229]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-856],[1,-18.6,0,6],[3,0,1,0,-2.2204460492503128e-16],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-179.99999999999997,0]],[1,"RootNode",512,470,[-857]],[3,"stone",512,471,[[5,1,-858,[2,"750CzYu+lfVL2quXBrUJJL"],[230],[0],231]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-859],[1,20.8,0,-8],[3,0,1,0,-2.2204460492503128e-16],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-179.99999999999997,0]],[1,"RootNode",512,473,[-860]],[3,"stone",512,474,[[5,1,-861,[2,"750CzYu+lfVL2quXBrUJJL"],[232],[0],233]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-862],[1,20.8,0,-6],[3,0,1,0,-2.2204460492503128e-16],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-179.99999999999997,0]],[1,"RootNode",512,476,[-863]],[3,"stone",512,477,[[5,1,-864,[2,"750CzYu+lfVL2quXBrUJJL"],[234],[0],235]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-865],[1,20.8,0,-4],[3,0,1,0,-2.2204460492503128e-16],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-179.99999999999997,0]],[1,"RootNode",512,479,[-866]],[3,"stone",512,480,[[5,1,-867,[2,"750CzYu+lfVL2quXBrUJJL"],[236],[0],237]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-868],[1,20.8,0,-2],[3,0,1,0,-2.2204460492503128e-16],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-179.99999999999997,0]],[1,"RootNode",512,482,[-869]],[3,"stone",512,483,[[5,1,-870,[2,"750CzYu+lfVL2quXBrUJJL"],[238],[0],239]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-871],[1,20.8,0,0],[3,0,1,0,-2.2204460492503128e-16],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-179.99999999999997,0]],[1,"RootNode",512,485,[-872]],[3,"stone",512,486,[[5,1,-873,[2,"750CzYu+lfVL2quXBrUJJL"],[240],[0],241]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-874],[1,20.8,0,2],[3,0,1,0,-2.2204460492503128e-16],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-179.99999999999997,0]],[1,"RootNode",512,488,[-875]],[3,"stone",512,489,[[5,1,-876,[2,"750CzYu+lfVL2quXBrUJJL"],[242],[0],243]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-877],[1,20.8,0,4],[3,0,1,0,-2.2204460492503128e-16],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-179.99999999999997,0]],[1,"RootNode",512,491,[-878]],[3,"stone",512,492,[[5,1,-879,[2,"750CzYu+lfVL2quXBrUJJL"],[244],[0],245]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-880],[1,20.8,0,6],[3,0,1,0,-2.2204460492503128e-16],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-179.99999999999997,0]],[1,"RootNode",512,494,[-881]],[3,"stone",512,495,[[5,1,-882,[2,"750CzYu+lfVL2quXBrUJJL"],[246],[0],247]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-883],[1,25.199999999999985,5.551115123125783e-17,-35],[3,0,-0.7071067811865475,0,0.7071067811865477],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,497,[-884]],[3,"stone",512,498,[[5,1,-885,[2,"750CzYu+lfVL2quXBrUJJL"],[248],[0],249]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-886],[1,27.199999999999985,5.551115123125783e-17,-35],[3,0,-0.7071067811865475,0,0.7071067811865477],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,500,[-887]],[3,"stone",512,501,[[5,1,-888,[2,"750CzYu+lfVL2quXBrUJJL"],[250],[0],251]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"stone",512,1,[-889],[1,12.4,-0.25,-11],[1,1.8,1.8,1.8]],[1,"RootNode",512,503,[-890]],[3,"stone",512,504,[[5,1,-891,[2,"750CzYu+lfVL2quXBrUJJL"],[252],[0],253]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"stone",512,1,[-892],[1,12.4,-0.25,-9],[1,1.8,1.8,1.8]],[1,"RootNode",512,506,[-893]],[3,"stone",512,507,[[5,1,-894,[2,"750CzYu+lfVL2quXBrUJJL"],[254],[0],255]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"stone",512,1,[-895],[1,12.4,-0.25,-7],[1,1.8,1.8,1.8]],[1,"RootNode",512,509,[-896]],[3,"stone",512,510,[[5,1,-897,[2,"750CzYu+lfVL2quXBrUJJL"],[256],[0],257]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"stone",512,1,[-898],[1,12.4,-0.25,7],[1,1.8,1.8,1.8]],[1,"RootNode",512,512,[-899]],[3,"stone",512,513,[[5,1,-900,[2,"750CzYu+lfVL2quXBrUJJL"],[258],[0],259]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"stone",512,1,[-901],[1,12.4,-0.25,9],[1,1.8,1.8,1.8]],[1,"RootNode",512,515,[-902]],[3,"stone",512,516,[[5,1,-903,[2,"750CzYu+lfVL2quXBrUJJL"],[260],[0],261]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"stone",512,1,[-904],[1,12.4,-0.25,11],[1,1.8,1.8,1.8]],[1,"RootNode",512,518,[-905]],[3,"stone",512,519,[[5,1,-906,[2,"750CzYu+lfVL2quXBrUJJL"],[262],[0],263]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"stone",512,1,[-907],[1,-9.2,-0.25,-11],[1,1.8,1.8,1.8]],[1,"RootNode",512,521,[-908]],[3,"stone",512,522,[[5,1,-909,[2,"750CzYu+lfVL2quXBrUJJL"],[264],[0],265]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"stone",512,1,[-910],[1,-9.2,-0.25,-9],[1,1.8,1.8,1.8]],[1,"RootNode",512,524,[-911]],[3,"stone",512,525,[[5,1,-912,[2,"750CzYu+lfVL2quXBrUJJL"],[266],[0],267]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"stone",512,1,[-913],[1,-9.2,-0.25,-7],[1,1.8,1.8,1.8]],[1,"RootNode",512,527,[-914]],[3,"stone",512,528,[[5,1,-915,[2,"750CzYu+lfVL2quXBrUJJL"],[268],[0],269]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"stone",512,1,[-916],[1,-9.2,-0.25,7],[1,1.8,1.8,1.8]],[1,"RootNode",512,530,[-917]],[3,"stone",512,531,[[5,1,-918,[2,"750CzYu+lfVL2quXBrUJJL"],[270],[0],271]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"stone",512,1,[-919],[1,-9.2,-0.25,9],[1,1.8,1.8,1.8]],[1,"RootNode",512,533,[-920]],[3,"stone",512,534,[[5,1,-921,[2,"750CzYu+lfVL2quXBrUJJL"],[272],[0],273]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"stone",512,1,[-922],[1,-9.2,-0.25,11],[1,1.8,1.8,1.8]],[1,"RootNode",512,536,[-923]],[3,"stone",512,537,[[5,1,-924,[2,"750CzYu+lfVL2quXBrUJJL"],[274],[0],275]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-925],[1,11,-0.24999999999999994,13],[3,0,-0.7071067811865475,0,0.7071067811865476],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,539,[-926]],[3,"stone",512,540,[[5,1,-927,[2,"750CzYu+lfVL2quXBrUJJL"],[276],[0],277]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-928],[1,9,-0.24999999999999994,13],[3,0,-0.7071067811865475,0,0.7071067811865476],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,542,[-929]],[3,"stone",512,543,[[5,1,-930,[2,"750CzYu+lfVL2quXBrUJJL"],[278],[0],279]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-931],[1,7.000000000000001,-0.24999999999999994,13],[3,0,-0.7071067811865475,0,0.7071067811865476],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,545,[-932]],[3,"stone",512,546,[[5,1,-933,[2,"750CzYu+lfVL2quXBrUJJL"],[280],[0],281]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-934],[1,-3.999999999999997,-0.24999999999999994,13],[3,0,-0.7071067811865475,0,0.7071067811865476],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,548,[-935]],[3,"stone",512,549,[[5,1,-936,[2,"750CzYu+lfVL2quXBrUJJL"],[282],[0],283]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-937],[1,-5.999999999999996,-0.24999999999999994,13],[3,0,-0.7071067811865475,0,0.7071067811865476],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,551,[-938]],[3,"stone",512,552,[[5,1,-939,[2,"750CzYu+lfVL2quXBrUJJL"],[284],[0],285]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-940],[1,-7.999999999999996,-0.24999999999999994,13],[3,0,-0.7071067811865475,0,0.7071067811865476],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,554,[-941]],[3,"stone",512,555,[[5,1,-942,[2,"750CzYu+lfVL2quXBrUJJL"],[286],[0],287]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-943],[1,10.999999999999995,-0.24999999999999994,-13],[3,0,-0.7071067811865475,0,0.7071067811865477],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,557,[-944]],[3,"stone",512,558,[[5,1,-945,[2,"750CzYu+lfVL2quXBrUJJL"],[288],[0],289]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-946],[1,8.999999999999995,-0.24999999999999994,-13],[3,0,-0.7071067811865475,0,0.7071067811865476],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,560,[-947]],[3,"stone",512,561,[[5,1,-948,[2,"750CzYu+lfVL2quXBrUJJL"],[290],[0],291]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-949],[1,6.999999999999996,-0.24999999999999994,-13],[3,0,-0.7071067811865475,0,0.7071067811865476],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,563,[-950]],[3,"stone",512,564,[[5,1,-951,[2,"750CzYu+lfVL2quXBrUJJL"],[292],[0],293]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-952],[1,-4.000000000000002,-0.24999999999999994,-13],[3,0,-0.7071067811865475,0,0.7071067811865476],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,566,[-953]],[3,"stone",512,567,[[5,1,-954,[2,"750CzYu+lfVL2quXBrUJJL"],[294],[0],295]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-955],[1,-6.000000000000001,-0.24999999999999994,-13],[3,0,-0.7071067811865475,0,0.7071067811865476],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,569,[-956]],[3,"stone",512,570,[[5,1,-957,[2,"750CzYu+lfVL2quXBrUJJL"],[296],[0],297]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-958],[1,-8.000000000000002,-0.24999999999999994,-13],[3,0,-0.7071067811865475,0,0.7071067811865476],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,572,[-959]],[3,"stone",512,573,[[5,1,-960,[2,"750CzYu+lfVL2quXBrUJJL"],[298],[0],299]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-961],[1,-22,0,-35],[3,0,-0.7071067811865475,0,0.7071067811865476],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,575,[-962]],[3,"stone",512,576,[[5,1,-963,[2,"750CzYu+lfVL2quXBrUJJL"],[300],[0],301]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-964],[1,-24,0,-35],[3,0,-0.7071067811865475,0,0.7071067811865476],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,578,[-965]],[3,"stone",512,579,[[5,1,-966,[2,"750CzYu+lfVL2quXBrUJJL"],[302],[0],303]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-967],[1,25.2,0,35],[3,0,-0.7071067811865475,0,0.7071067811865477],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,581,[-968]],[3,"stone",512,582,[[5,1,-969,[2,"750CzYu+lfVL2quXBrUJJL"],[304],[0],305]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-970],[1,27.2,0,35],[3,0,-0.7071067811865475,0,0.7071067811865477],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,584,[-971]],[3,"stone",512,585,[[5,1,-972,[2,"750CzYu+lfVL2quXBrUJJL"],[306],[0],307]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-973],[1,-22,0,31.4],[3,0,-0.7071067811865475,0,0.7071067811865476],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,587,[-974]],[3,"stone",512,588,[[5,1,-975,[2,"750CzYu+lfVL2quXBrUJJL"],[308],[0],309]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-976],[1,-24,0,31.4],[3,0,-0.7071067811865475,0,0.7071067811865476],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,590,[-977]],[3,"stone",512,591,[[5,1,-978,[2,"750CzYu+lfVL2quXBrUJJL"],[310],[0],311]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-979],[1,29,0,-32.6],[3,0,-0.7071067811865475,0,0.7071067811865477],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,593,[-980]],[3,"stone",512,594,[[5,1,-981,[2,"750CzYu+lfVL2quXBrUJJL"],[312],[0],313]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-982],[1,29,0,32.6],[3,0,-0.7071067811865475,0,0.7071067811865477],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,596,[-983]],[3,"stone",512,597,[[5,1,-984,[2,"750CzYu+lfVL2quXBrUJJL"],[314],[0],315]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-985],[1,-26.5,0,29],[3,0,-0.7071067811865475,0,0.7071067811865477],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,599,[-986]],[3,"stone",512,600,[[5,1,-987,[2,"750CzYu+lfVL2quXBrUJJL"],[316],[0],317]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-988],[1,-26.5,0,-32.6],[3,0,-0.7071067811865475,0,0.7071067811865477],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,602,[-989]],[3,"stone",512,603,[[5,1,-990,[2,"750CzYu+lfVL2quXBrUJJL"],[318],[0],319]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-991],[1,6.8,-0.25,-24],[3,0,-0.7071067811865475,0,0.7071067811865476],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,605,[-992]],[3,"stone",512,606,[[5,1,-993,[2,"750CzYu+lfVL2quXBrUJJL"],[320],[0],321]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-994],[1,-8,-0.25,-24],[3,0,-0.7071067811865475,0,0.7071067811865476],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,608,[-995]],[3,"stone",512,609,[[5,1,-996,[2,"750CzYu+lfVL2quXBrUJJL"],[322],[0],323]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-997],[1,-8,-0.25,24],[3,0,-0.7071067811865475,0,0.7071067811865476],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,611,[-998]],[3,"stone",512,612,[[5,1,-999,[2,"750CzYu+lfVL2quXBrUJJL"],[324],[0],325]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-1000],[1,6.8,-0.25,24],[3,0,-0.7071067811865475,0,0.7071067811865476],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,614,[-1001]],[3,"stone",512,615,[[5,1,-1002,[2,"750CzYu+lfVL2quXBrUJJL"],[326],[0],327]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-1003],[1,20.8,0,-15.6],[3,0,1,0,-2.2204460492503128e-16],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-179.99999999999997,0]],[1,"RootNode",512,617,[-1004]],[3,"stone",512,618,[[5,1,-1005,[2,"750CzYu+lfVL2quXBrUJJL"],[328],[0],329]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-1006],[1,20.8,0,15.6],[3,0,-1,0,2.83276944882399e-16],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-179.99999999999997,0]],[1,"RootNode",512,620,[-1007]],[3,"stone",512,621,[[5,1,-1008,[2,"750CzYu+lfVL2quXBrUJJL"],[330],[0],331]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-1009],[1,14.4,-0.25,-24],[3,0,-0.7071067811865475,0,0.7071067811865476],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,623,[-1010]],[3,"stone",512,624,[[5,1,-1011,[2,"750CzYu+lfVL2quXBrUJJL"],[332],[0],333]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-1012],[1,-15,-0.25,-24],[3,0,-0.7071067811865475,0,0.7071067811865477],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,626,[-1013]],[3,"stone",512,627,[[5,1,-1014,[2,"750CzYu+lfVL2quXBrUJJL"],[334],[0],335]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-1015],[1,14.4,-0.25,24],[3,0,-0.7071067811865475,0,0.7071067811865476],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,629,[-1016]],[3,"stone",512,630,[[5,1,-1017,[2,"750CzYu+lfVL2quXBrUJJL"],[336],[0],337]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-1018],[1,-15,-0.25,24],[3,0,-0.7071067811865475,0,0.7071067811865476],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,632,[-1019]],[3,"stone",512,633,[[5,1,-1020,[2,"750CzYu+lfVL2quXBrUJJL"],[338],[0],339]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-1021],[1,-18.6,0,-13.8],[3,0,1,0,-2.2204460492503128e-16],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-179.99999999999997,0]],[1,"RootNode",512,635,[-1022]],[3,"stone",512,636,[[5,1,-1023,[2,"750CzYu+lfVL2quXBrUJJL"],[340],[0],341]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-1024],[1,-18.6,0,13.8],[3,0,-1,0,2.83276944882399e-16],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-179.99999999999997,0]],[1,"RootNode",512,638,[-1025]],[3,"stone",512,639,[[5,1,-1026,[2,"750CzYu+lfVL2quXBrUJJL"],[342],[0],343]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-1027],[1,15.5,0,-45],[3,0,-0.7071067811865475,0,0.7071067811865477],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,641,[-1028]],[3,"stone",512,642,[[5,1,-1029,[2,"750CzYu+lfVL2quXBrUJJL"],[344],[0],345]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-1030],[1,15.5,0,-43],[3,0,-0.7071067811865475,0,0.7071067811865477],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,644,[-1031]],[3,"stone",512,645,[[5,1,-1032,[2,"750CzYu+lfVL2quXBrUJJL"],[346],[0],347]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-1033],[1,13.5,0,-47],[3,0,-0.7071067811865475,0,0.7071067811865477],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,647,[-1034]],[3,"stone",512,648,[[5,1,-1035,[2,"750CzYu+lfVL2quXBrUJJL"],[348],[0],349]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-1036],[1,-12.9,0,-47],[3,0,-0.7071067811865475,0,0.7071067811865477],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,650,[-1037]],[3,"stone",512,651,[[5,1,-1038,[2,"750CzYu+lfVL2quXBrUJJL"],[350],[0],351]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-1039],[1,-14.9,0,-45],[3,0,-0.7071067811865475,0,0.7071067811865477],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,653,[-1040]],[3,"stone",512,654,[[5,1,-1041,[2,"750CzYu+lfVL2quXBrUJJL"],[352],[0],353]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-1042],[1,-14.9,0,-43],[3,0,-0.7071067811865475,0,0.7071067811865477],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,656,[-1043]],[3,"stone",512,657,[[5,1,-1044,[2,"750CzYu+lfVL2quXBrUJJL"],[354],[0],355]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-1045],[1,15.5,0,45],[3,0,-0.7071067811865475,0,0.7071067811865477],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,659,[-1046]],[3,"stone",512,660,[[5,1,-1047,[2,"750CzYu+lfVL2quXBrUJJL"],[356],[0],357]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-1048],[1,15.5,0,43],[3,0,-0.7071067811865475,0,0.7071067811865477],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,662,[-1049]],[3,"stone",512,663,[[5,1,-1050,[2,"750CzYu+lfVL2quXBrUJJL"],[358],[0],359]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-1051],[1,20.8,0,8],[3,0,1,0,-2.2204460492503128e-16],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-179.99999999999997,0]],[1,"RootNode",512,665,[-1052]],[3,"stone",512,666,[[5,1,-1053,[2,"750CzYu+lfVL2quXBrUJJL"],[360],[0],361]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-1054],[1,14.4,-0.25,-26],[3,0,-0.7071067811865475,0,0.7071067811865476],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,668,[-1055]],[3,"stone",512,669,[[5,1,-1056,[2,"750CzYu+lfVL2quXBrUJJL"],[362],[0],363]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-1057],[1,14.4,-0.25,-28],[3,0,-0.7071067811865475,0,0.7071067811865476],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,671,[-1058]],[3,"stone",512,672,[[5,1,-1059,[2,"750CzYu+lfVL2quXBrUJJL"],[364],[0],365]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-1060],[1,14.4,-0.25,26],[3,0,-0.7071067811865475,0,0.7071067811865476],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,674,[-1061]],[3,"stone",512,675,[[5,1,-1062,[2,"750CzYu+lfVL2quXBrUJJL"],[366],[0],367]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-1063],[1,14.4,-0.25,28],[3,0,-0.7071067811865475,0,0.7071067811865476],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,677,[-1064]],[3,"stone",512,678,[[5,1,-1065,[2,"750CzYu+lfVL2quXBrUJJL"],[368],[0],369]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-1066],[1,-15,-0.25,28],[3,0,-0.7071067811865475,0,0.7071067811865476],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,680,[-1067]],[3,"stone",512,681,[[5,1,-1068,[2,"750CzYu+lfVL2quXBrUJJL"],[370],[0],371]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-1069],[1,-15,-0.25,26],[3,0,-0.7071067811865475,0,0.7071067811865476],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,683,[-1070]],[3,"stone",512,684,[[5,1,-1071,[2,"750CzYu+lfVL2quXBrUJJL"],[372],[0],373]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-1072],[1,-15,-0.25,-28],[3,0,-0.7071067811865475,0,0.7071067811865476],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,686,[-1073]],[3,"stone",512,687,[[5,1,-1074,[2,"750CzYu+lfVL2quXBrUJJL"],[374],[0],375]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-1075],[1,-15,-0.25,-26],[3,0,-0.7071067811865475,0,0.7071067811865476],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,689,[-1076]],[3,"stone",512,690,[[5,1,-1077,[2,"750CzYu+lfVL2quXBrUJJL"],[376],[0],377]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-1078],[1,-14.9,0,43],[3,0,-0.7071067811865475,0,0.7071067811865477],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,692,[-1079]],[3,"stone",512,693,[[5,1,-1080,[2,"750CzYu+lfVL2quXBrUJJL"],[378],[0],379]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-1081],[1,-14.9,0,45],[3,0,-0.7071067811865475,0,0.7071067811865477],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,695,[-1082]],[3,"stone",512,696,[[5,1,-1083,[2,"750CzYu+lfVL2quXBrUJJL"],[380],[0],381]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-1084],[1,13.5,0,47],[3,0,-0.7071067811865475,0,0.7071067811865477],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,698,[-1085]],[3,"stone",512,699,[[5,1,-1086,[2,"750CzYu+lfVL2quXBrUJJL"],[382],[0],383]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone",512,1,[-1087],[1,-12.9,0,47],[3,0,-0.7071067811865475,0,0.7071067811865477],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-89.99999999999999,0]],[1,"RootNode",512,701,[-1088]],[3,"stone",512,702,[[5,1,-1089,[2,"750CzYu+lfVL2quXBrUJJL"],[384],[0],385]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,"stone-001",512,1,[-1090],[1,-18.6,0,8],[3,0,1,0,-2.2204460492503128e-16],[1,1.7999999999999996,1.8,1.7999999999999996],[1,0,-179.99999999999997,0]],[1,"RootNode",512,704,[-1091]],[3,"stone",512,705,[[5,1,-1092,[2,"750CzYu+lfVL2quXBrUJJL"],[386],[0],387]],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[47,"staticBatch",512,8,[[99,"staticBatch<StaticBatch>",-1093,[23,10]]]],[48,"sea",512,8,[-1094],[1,-1.45,-0.5,-1.6]],[1,"RootNode",512,708,[-1095]],[47,"sea",512,709,[[5,1,-1096,[2,"80UNkJ9ZtVmpDKWc4mCLAO"],[388],[0],389]]],[65,"skyBox",512,8,[-1097],[1,0.5,0.5,0.5]],[17,"skyBox",512,711,[[18,-1098,[2,"f4bm6zrYJFZrjY1uGAuUhM"],[390],[0],391]],[1,0,-70,0],[3,-0.7071067811865477,0,0,0.7071067811865474],[1,0.034,0.034,0.034],[1,-90.00000000000003,0,0]],[6,"grass01",512,24,[-1099],[1,-36.857,0,-42.585],[1,2.5,3,2.5]],[1,"RootNode",512,713,[-1100]],[19,"grass",512,714,[[14,1,-1101,[396],[0],397]],[1,0.00000250447806548767,0,0]],[6,"grass02",512,24,[-1102],[1,-32.466,0,-44],[1,2.5,3,2.5]],[1,"RootNode",512,716,[-1103]],[19,"grass",512,717,[[14,1,-1104,[398],[0],399]],[1,0.00000250447806548767,0,0]],[6,"grass03",512,24,[-1105],[1,-28.284,0,-42.585],[1,2.5,3,2.5]],[1,"RootNode",512,719,[-1106]],[19,"grass",512,720,[[14,1,-1107,[400],[0],401]],[1,0.00000250447806548767,0,0]],[6,"grass04",512,24,[-1108],[1,-23.893,0,-44],[1,2.5,3,2.5]],[1,"RootNode",512,722,[-1109]],[19,"grass",512,723,[[14,1,-1110,[402],[0],403]],[1,0.00000250447806548767,0,0]],[6,"grass05",512,24,[-1111],[1,-20,0,-42.585],[1,2.5,3,2.5]],[1,"RootNode",512,725,[-1112]],[19,"grass",512,726,[[14,1,-1113,[404],[0],405]],[1,0.00000250447806548767,0,0]],[6,"grass03",512,15,[-1114],[1,7.433,0,-42.367],[1,2.5,3,2.5]],[1,"RootNode",512,728,[-1115]],[19,"grass",512,729,[[14,1,-1116,[406],[0],407]],[1,0.00000250447806548767,0,0]],[6,"grass04",512,15,[-1117],[1,11.201,0,-44],[1,2.5,3,2.5]],[1,"RootNode",512,731,[-1118]],[19,"grass",512,732,[[14,1,-1119,[408],[0],409]],[1,0.00000250447806548767,0,0]],[6,"grass05",512,15,[-1120],[1,15.025,0,-42.367],[1,2.5,3,2.5]],[1,"RootNode",512,734,[-1121]],[19,"grass",512,735,[[14,1,-1122,[410],[0],411]],[1,0.00000250447806548767,0,0]],[6,"grass06",512,15,[-1123],[1,18.906,0,-44],[1,2.5,3,2.5]],[1,"RootNode",512,737,[-1124]],[19,"grass",512,738,[[14,1,-1125,[412],[0],413]],[1,0.00000250447806548767,0,0]],[6,"grass07",512,15,[-1126],[1,26.608,0,-44],[1,2.5,3,2.5]],[1,"RootNode",512,740,[-1127]],[19,"grass",512,741,[[14,1,-1128,[414],[0],415]],[1,0.00000250447806548767,0,0]],[6,"grass08",512,15,[-1129],[1,22.727,0,-42.367],[1,2.5,3,2.5]],[1,"RootNode",512,743,[-1130]],[19,"grass",512,744,[[14,1,-1131,[416],[0],417]],[1,0.00000250447806548767,0,0]],[6,"grass09",512,15,[-1132],[1,30.5,0,-43],[1,2.5,3,2.5]],[1,"RootNode",512,746,[-1133]],[19,"grass",512,747,[[14,1,-1134,[418],[0],419]],[1,0.00000250447806548767,0,0]],[6,"grass07",512,25,[-1135],[1,68.5,0,-15.5],[1,2.5,3,2.5]],[1,"RootNode",512,749,[-1136]],[19,"grass",512,750,[[14,1,-1137,[420],[0],421]],[1,0.00000250447806548767,0,0]],[6,"grass08",512,25,[-1138],[1,67.5,0,-11.061],[1,2.5,3,2.5]],[1,"RootNode",512,752,[-1139]],[19,"grass",512,753,[[14,1,-1140,[422],[0],423]],[1,0.00000250447806548767,0,0]],[6,"grass09",512,25,[-1141],[1,68,0,-6.5],[1,2.5,3,2.5]],[1,"RootNode",512,755,[-1142]],[19,"grass",512,756,[[14,1,-1143,[424],[0],425]],[1,0.00000250447806548767,0,0]],[6,"grass10",512,25,[-1144],[1,63.902,0,-13.866],[1,2.5,3,2.5]],[1,"RootNode",512,758,[-1145]],[19,"grass",512,759,[[14,1,-1146,[426],[0],427]],[1,0.00000250447806548767,0,0]],[6,"grass11",512,25,[-1147],[1,63.902,0,-8.977],[1,2.5,3,2.5]],[1,"RootNode",512,761,[-1148]],[19,"grass",512,762,[[14,1,-1149,[428],[0],429]],[1,0.00000250447806548767,0,0]],[6,"grass07",512,19,[-1150],[1,-67.5,0,-6.946],[1,2.5,3,2.5]],[1,"RootNode",512,764,[-1151]],[19,"grass",512,765,[[14,1,-1152,[430],[0],431]],[1,0.00000250447806548767,0,0]],[6,"grass08",512,19,[-1153],[1,-68,0,-11],[1,2.5,3,2.5]],[1,"RootNode",512,767,[-1154]],[19,"grass",512,768,[[14,1,-1155,[432],[0],433]],[1,0.00000250447806548767,0,0]],[6,"grass09",512,19,[-1156],[1,-67.5,0,-15],[1,2.5,3,2.5]],[1,"RootNode",512,770,[-1157]],[19,"grass",512,771,[[14,1,-1158,[434],[0],435]],[1,0.00000250447806548767,0,0]],[6,"grass10",512,19,[-1159],[1,-68.5,0,-19.5],[1,2.5,3,2.5]],[1,"RootNode",512,773,[-1160]],[19,"grass",512,774,[[14,1,-1161,[436],[0],437]],[1,0.00000250447806548767,0,0]],[6,"grass11",512,19,[-1162],[1,-64.237,0,-17.273],[1,2.5,3,2.5]],[1,"RootNode",512,776,[-1163]],[19,"grass",512,777,[[14,1,-1164,[438],[0],439]],[1,0.00000250447806548767,0,0]],[6,"grass12",512,19,[-1165],[1,-64.237,0,-11.654],[1,2.5,3,2.5]],[1,"RootNode",512,779,[-1166]],[19,"grass",512,780,[[14,1,-1167,[440],[0],441]],[1,0.00000250447806548767,0,0]],[6,"tree01",512,9,[-1168],[1,45.455,0,-36.986],[1,0.8,0.8,0.8]],[1,"RootNode",512,782,[-1169]],[25,"tree",512,783,[[14,1,-1170,[479],[0],480]],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,0.00000250447806548767,0,0]],[48,"tree02",512,9,[-1171],[1,50.283,0,-32.301]],[1,"RootNode",512,785,[-1172]],[25,"tree",512,786,[[14,1,-1173,[481],[0],482]],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,0.00000250447806548767,0,0]],[6,"tree03",512,9,[-1174],[1,54.526,0,-24.773],[1,0.8,0.8,0.8]],[1,"RootNode",512,788,[-1175]],[25,"tree",512,789,[[14,1,-1176,[483],[0],484]],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,0.00000250447806548767,0,0]],[6,"tree04",512,9,[-1177],[1,58.369,0,21.579],[1,0.7,0.9,0.7]],[1,"RootNode",512,791,[-1178]],[25,"tree",512,792,[[14,1,-1179,[485],[0],486]],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,0.00000250447806548767,0,0]],[6,"tree05",512,9,[-1180],[1,-57.044,0,18.563],[1,0.7,0.9,0.7]],[1,"RootNode",512,794,[-1181]],[25,"tree",512,795,[[14,1,-1182,[487],[0],488]],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,0.00000250447806548767,0,0]],[6,"tree06",512,9,[-1183],[1,-48.275,0,27.686],[1,0.45,0.6,0.45]],[1,"RootNode",512,797,[-1184]],[25,"tree",512,798,[[14,1,-1185,[489],[0],490]],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,0.00000250447806548767,0,0]],[6,"tree07",512,9,[-1186],[1,-55.412,0,-30.29],[1,0.8,1,0.8]],[1,"RootNode",512,800,[-1187]],[25,"tree",512,801,[[14,1,-1188,[491],[0],492]],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,0.00000250447806548767,0,0]],[6,"tree08",512,9,[-1189],[1,-59.22,0,-24.917],[1,0.7,0.7,0.7]],[1,"RootNode",512,803,[-1190]],[25,"tree",512,804,[[14,1,-1191,[493],[0],494]],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,0.00000250447806548767,0,0]],[6,"tree09",512,9,[-1192],[1,-41.941,0,-37.327],[1,0.7,0.7,0.7]],[1,"RootNode",512,806,[-1193]],[25,"tree",512,807,[[14,1,-1194,[495],[0],496]],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,0.00000250447806548767,0,0]],[6,"tree10",512,9,[-1195],[1,35.874,0,30.146],[1,0.7,0.7,0.7]],[1,"RootNode",512,809,[-1196]],[25,"tree",512,810,[[14,1,-1197,[497],[0],498]],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,0.00000250447806548767,0,0]],[6,"tree11",512,9,[-1198],[1,53.662,0,25.489],[1,0.45,0.6,0.45]],[1,"RootNode",512,812,[-1199]],[25,"tree",512,813,[[14,1,-1200,[499],[0],500]],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,0.00000250447806548767,0,0]],[8,["f9IUNB1C9X5ZktPa2dkzM8"]],[9,"flowers_1",512,20,[-1201],[1,-61,0,-17],[3,0,0.17364817766693033,0,0.984807753012208],[1,2,2,2],[1,0,20,0]],[3,"flowers_1",512,816,[[34,-1202,[504],[0],505]],[3,-0.7071067811865477,0,0,0.7071067811865474],[1,-90.00000000000003,0,0]],[6,"flowers_2",512,20,[-1203],[1,-61,0,-13.8],[1,2,2,2]],[3,"flowers_1",512,818,[[34,-1204,[506],[0],507]],[3,-0.7071067811865477,0,0,0.7071067811865474],[1,-90.00000000000003,0,0]],[9,"flowers_3",512,20,[-1205],[1,-61,0,-10.5],[3,0,0.17364817766693033,0,0.984807753012208],[1,2,2,2],[1,0,20,0]],[3,"flowers_1",512,820,[[14,1,-1206,[508],[0],509]],[3,-0.7071067811865477,0,0,0.7071067811865474],[1,-90.00000000000003,0,0]],[9,"flowers_4",512,20,[-1207],[1,61,0,-10.5],[3,0,-0.17364817766693033,0,0.984807753012208],[1,2,2,2],[1,0,-20,0]],[3,"flowers_1",512,822,[[14,1,-1208,[510],[0],511]],[3,-0.7071067811865477,0,0,0.7071067811865474],[1,-90.00000000000003,0,0]],[6,"flowers_5",512,20,[-1209],[1,61,0,-13.8],[1,2,2,2]],[3,"flowers_1",512,824,[[34,-1210,[512],[0],513]],[3,-0.7071067811865477,0,0,0.7071067811865474],[1,-90.00000000000003,0,0]],[9,"flowers_6",512,20,[-1211],[1,61,0,-17],[3,0,-0.17364817766693033,0,0.984807753012208],[1,2,2,2],[1,0,-20,0]],[3,"flowers_1",512,826,[[34,-1212,[514],[0],515]],[3,-0.7071067811865477,0,0,0.7071067811865474],[1,-90.00000000000003,0,0]],[33,"fighterGroup",512,65],[33,"propGroup",512,65],[100,66],[49,"fighterGroup",512,66,[-1213]],[101,831,2],[17,"cube2",512,2,[[12,"Cube<ModelComponent>",false,-1214,[2,"e8DOT5UJ1F/ZgplWYyCxRs"],[516],[0],517]],[1,-0.086,0.88,-29.111],[3,0,0.7071067811865475,0,0.7071067811865476],[1,2,2,66.7],[1,0,90,0]],[20,"cube3",512,2,[[12,"Cube<ModelComponent>",false,-1215,[2,"e8DOT5UJ1F/ZgplWYyCxRs"],[518],[0],519]],[1,62.692,0.847,-1.663],[1,2,2,80]],[17,"cube4",512,2,[[12,"Cube<ModelComponent>",false,-1216,[2,"e8DOT5UJ1F/ZgplWYyCxRs"],[520],[0],521]],[1,-3.5,0.846,26.293],[3,0,0.7071067811865475,0,0.7071067811865476],[1,2,2,112.9],[1,0,90,0]],[17,"cube5",512,2,[[12,"Cube<ModelComponent>",false,-1217,[2,"e8DOT5UJ1F/ZgplWYyCxRs"],[522],[0],523]],[1,0.051,0.846,18.621],[3,0,0.7071067811865475,0,0.7071067811865476],[1,2,2,30],[1,0,90,0]],[17,"cube6",512,2,[[12,"Cube<ModelComponent>",false,-1218,[2,"e8DOT5UJ1F/ZgplWYyCxRs"],[524],[0],525]],[1,-0.069,0.846,-20.797],[3,0,0.7071067811865475,0,0.7071067811865476],[1,2,2,32.7],[1,0,90,0]],[20,"cube7",512,2,[[12,"Cube<ModelComponent>",false,-1219,[2,"e8DOT5UJ1F/ZgplWYyCxRs"],[526],[0],527]],[1,-24.062,0.846,0.642],[1,2,2,16]],[20,"cube8",512,2,[[12,"Cube<ModelComponent>",false,-1220,[2,"e8DOT5UJ1F/ZgplWYyCxRs"],[528],[0],529]],[1,24.037,0.846,0.562],[1,2,2,16]],[20,"cube9",512,2,[[12,"Cube<ModelComponent>",false,-1221,[2,"e8DOT5UJ1F/ZgplWYyCxRs"],[530],[0],531]],[1,12.911,0.846,-8.937],[1,1.8,2,5.5]],[17,"cube10",512,2,[[12,"Cube<ModelComponent>",false,-1222,[2,"e8DOT5UJ1F/ZgplWYyCxRs"],[532],[0],533]],[1,8.944,0.846,-12.375],[3,0,0.7071067811865475,0,0.7071067811865476],[1,1.8,2,5.3],[1,0,90,0]],[20,"cube11",512,2,[[12,"Cube<ModelComponent>",false,-1223,[2,"e8DOT5UJ1F/ZgplWYyCxRs"],[534],[0],535]],[1,-12.971,0.846,-9.023],[1,1.8,2,5.4]],[17,"cube12",512,2,[[12,"Cube<ModelComponent>",false,-1224,[2,"e8DOT5UJ1F/ZgplWYyCxRs"],[536],[0],537]],[1,-8.953,0.846,-12.375],[3,0,0.7071067811865475,0,0.7071067811865476],[1,1.8,2,5.5],[1,0,90,0]],[20,"cube13",512,2,[[12,"Cube<ModelComponent>",false,-1225,[2,"e8DOT5UJ1F/ZgplWYyCxRs"],[538],[0],539]],[1,12.983,0.85,6.013],[1,1.85,2,5.5]],[17,"cube14",512,2,[[12,"Cube<ModelComponent>",false,-1226,[2,"e8DOT5UJ1F/ZgplWYyCxRs"],[540],[0],541]],[1,8.971,0.85,9.2],[3,0,0.7071067811865475,0,0.7071067811865476],[1,1.85,2,5.5],[1,0,90,0]],[20,"cube15",512,2,[[12,"Cube<ModelComponent>",false,-1227,[2,"e8DOT5UJ1F/ZgplWYyCxRs"],[542],[0],543]],[1,-12.99,0.85,6.013],[1,1.85,2,5.5]],[17,"cube16",512,2,[[12,"Cube<ModelComponent>",false,-1228,[2,"e8DOT5UJ1F/ZgplWYyCxRs"],[544],[0],545]],[1,-8.978,0.85,9.2],[3,0,0.7071067811865475,0,0.7071067811865476],[1,1.85,2,5.5],[1,0,90,0]],[17,"cube17",512,2,[[12,"Cube<ModelComponent>",false,-1229,[2,"e8DOT5UJ1F/ZgplWYyCxRs"],[546],[0],547]],[1,-26.087,0.85,15.017],[3,0,0.7071067811865475,0,0.7071067811865476],[1,1.85,2,6],[1,0,90,0]],[17,"cube18",512,2,[[12,"Cube<ModelComponent>",false,-1230,[2,"e8DOT5UJ1F/ZgplWYyCxRs"],[548],[0],549]],[1,25.95,0.85,15.017],[3,0,0.7071067811865475,0,0.7071067811865476],[1,1.85,2,5.5],[1,0,90,0]],[17,"cube19",512,2,[[12,"Cube<ModelComponent>",false,-1231,[2,"e8DOT5UJ1F/ZgplWYyCxRs"],[550],[0],551]],[1,25.95,0.85,-14.346],[3,0,0.7071067811865475,0,0.7071067811865476],[1,1.85,2,5.3],[1,0,90,0]],[17,"cube20",512,2,[[12,"Cube<ModelComponent>",false,-1232,[2,"e8DOT5UJ1F/ZgplWYyCxRs"],[552],[0],553]],[1,-26.128,0.85,-14.346],[3,0,0.7071067811865475,0,0.7071067811865476],[1,1.85,2,5.4],[1,0,90,0]],[20,"cube21",512,2,[[12,"Cube<ModelComponent>",false,-1233,[2,"e8DOT5UJ1F/ZgplWYyCxRs"],[554],[0],555]],[1,31.321,0.85,24.076],[1,1.85,2,6]],[20,"cube22",512,2,[[12,"Cube<ModelComponent>",false,-1234,[2,"e8DOT5UJ1F/ZgplWYyCxRs"],[556],[0],557]],[1,-34.885,0.85,24.076],[1,1.85,2,6]],[20,"cube23",512,2,[[12,"Cube<ModelComponent>",false,-1235,[2,"e8DOT5UJ1F/ZgplWYyCxRs"],[558],[0],559]],[1,-34.885,0.85,-26.132],[1,1.85,2,4.1]],[20,"cube24",512,2,[[12,"Cube<ModelComponent>",false,-1236,[2,"e8DOT5UJ1F/ZgplWYyCxRs"],[560],[0],561]],[1,34.897,0.85,-26.306],[1,1.85,2,3.5]],[17,"cube26",512,2,[[12,"Cube<ModelComponent>",false,-1237,[2,"e8DOT5UJ1F/ZgplWYyCxRs"],[562],[0],563]],[1,-0.905,0.85,-39.218],[3,0,0.7071067811865475,0,0.7071067811865476],[1,1.85,2,120],[1,0,90,0]],[17,"cube27",512,2,[[12,"Cube<ModelComponent>",false,-1238,[2,"e8DOT5UJ1F/ZgplWYyCxRs"],[564],[0],565]],[1,-66.285,0.85,26.868],[3,0,0.7071067811865475,0,0.7071067811865476],[1,1.85,2,6],[1,0,90,0]],[17,"cube25",512,2,[[12,"Cube<ModelComponent>",false,-1239,[2,"e8DOT5UJ1F/ZgplWYyCxRs"],[566],[0],567]],[1,44.001,0.85,15.017],[3,0,0.7071067811865475,0,0.7071067811865476],[1,1.85,2,4],[1,0,90,0]],[20,"cube28",512,2,[[12,"Cube<ModelComponent>",false,-1240,[2,"e8DOT5UJ1F/ZgplWYyCxRs"],[568],[0],569]],[1,46.975,0.85,9.347],[1,1.85,2,9]],[20,"cube29",512,2,[[12,"Cube<ModelComponent>",false,-1241,[2,"e8DOT5UJ1F/ZgplWYyCxRs"],[570],[0],571]],[1,46.975,0.85,-9.964],[1,1.85,2,9]],[17,"cube30",512,2,[[12,"Cube<ModelComponent>",false,-1242,[2,"e8DOT5UJ1F/ZgplWYyCxRs"],[572],[0],573]],[1,44.001,0.85,-15.363],[3,0,0.7071067811865475,0,0.7071067811865476],[1,1.85,2,4],[1,0,90,0]],[20,"cube31",512,2,[[12,"Cube<ModelComponent>",false,-1243,[2,"e8DOT5UJ1F/ZgplWYyCxRs"],[574],[0],575]],[1,-47.049,0.85,9.293],[1,1.85,2,9.5]],[20,"cube32",512,2,[[12,"Cube<ModelComponent>",false,-1244,[2,"e8DOT5UJ1F/ZgplWYyCxRs"],[576],[0],577]],[1,-47.049,0.85,-9.805],[1,1.85,2,9.5]],[17,"cube33",512,2,[[12,"Cube<ModelComponent>",false,-1245,[2,"e8DOT5UJ1F/ZgplWYyCxRs"],[578],[0],579]],[1,-43.956,0.85,15.017],[3,0,0.7071067811865475,0,0.7071067811865476],[1,1.85,2,4],[1,0,90,0]],[17,"cube34",512,2,[[12,"Cube<ModelComponent>",false,-1246,[2,"e8DOT5UJ1F/ZgplWYyCxRs"],[580],[0],581]],[1,-43.956,0.85,-15.44],[3,0,0.7071067811865475,0,0.7071067811865476],[1,1.85,2,4],[1,0,90,0]],[17,"cube35",512,2,[[12,"Cube<ModelComponent>",false,-1247,[2,"e8DOT5UJ1F/ZgplWYyCxRs"],[582],[0],583]],[1,42.2,0.847,-35.607],[3,0,0.5490228179981317,0,0.8358073613682703],[1,2,2,20],[1,0,66.6,0]],[17,"cube36",512,2,[[12,"Cube<ModelComponent>",false,-1248,[2,"e8DOT5UJ1F/ZgplWYyCxRs"],[584],[0],585]],[1,52.913,0.847,-28.397],[3,0,0.16762912696898857,0,0.9858501284635585],[1,2,2,10],[1,0,19.3,0]],[17,"cube37",512,2,[[12,"Cube<ModelComponent>",false,-1249,[2,"e8DOT5UJ1F/ZgplWYyCxRs"],[586],[0],587]],[1,58.596,0.847,-24.414],[3,0,0.7071067811865475,0,0.7071067811865476],[1,2,2,10],[1,0,90,0]],[17,"cube38",512,2,[[12,"Cube<ModelComponent>",false,-1250,[2,"e8DOT5UJ1F/ZgplWYyCxRs"],[588],[0],589]],[1,59.961,0.847,18.572],[3,0,0.7071067811865475,0,0.7071067811865476],[1,2,2,10],[1,0,90,0]],[17,"cube39",512,2,[[12,"Cube<ModelComponent>",false,-1251,[2,"e8DOT5UJ1F/ZgplWYyCxRs"],[590],[0],591]],[1,53.819,0.847,23.046],[3,0,-0.19594614424251772,0,0.980614658546613],[1,2,2,10],[1,0,-22.6,0]],[20,"cube40",512,2,[[12,"Cube<ModelComponent>",false,-1252,[2,"e8DOT5UJ1F/ZgplWYyCxRs"],[592],[0],593]],[1,-57.266,0.847,12.369],[1,2,2,32.9]],[20,"cube41",512,2,[[12,"Cube<ModelComponent>",false,-1253,[2,"e8DOT5UJ1F/ZgplWYyCxRs"],[594],[0],595]],[1,-59.013,0.85,-15.098],[1,1.85,2,24]],[20,"cube42",512,2,[[12,"Cube<ModelComponent>",false,-1254,[2,"e8DOT5UJ1F/ZgplWYyCxRs"],[596],[0],597]],[1,-48.507,0.85,-34.975],[1,1.85,2,9.5]],[17,"cube43",512,2,[[12,"Cube<ModelComponent>",false,-1255,[2,"e8DOT5UJ1F/ZgplWYyCxRs"],[598],[0],599]],[1,-54.201,0.85,-29.553],[3,0,-0.5757190033240687,0,0.8176476192171913],[1,1.85,2,13.5],[1,0,-70.3,0]],[17,"cube44",512,2,[[12,"Cube<ModelComponent>",false,-1256,[2,"e8DOT5UJ1F/ZgplWYyCxRs"],[600],[0],601]],[1,-44.653,0.85,-35.011],[3,0,-0.706489444943837,0,0.7077235789366842],[1,1.85,2,7.7],[1,0,-89.9,0]],[20,"cube45",512,2,[[12,"Cube<ModelComponent>",false,-1257,[2,"e8DOT5UJ1F/ZgplWYyCxRs"],[602],[0],603]],[1,-41.779,0.85,-36.598],[1,1.85,2,4]],[49,"propGroup",512,66,[-1258]],[102,877],[103,72],[73,"Camera",512,72,[-1259],[1,0,84,-50],[3,-2.0837927609538095e-18,-0.9063077870366499,-0.42261826174069944,6.659072331292345e-17],[1,-50,-180,-3.008475117086485e-15]],[104,"Camera<Camera>",52,1820327937,880,[4,4286073907]],[15,"Cube-001",512,false,5,[[16,"Cube<ModelComponent>",-1260,[608],[0],609]],[1,36,0,-20]],[15,"Cube-002",512,false,5,[[16,"Cube<ModelComponent>",-1261,[610],[0],611]],[1,30,0,-25]],[15,"Cube-003",512,false,5,[[16,"Cube<ModelComponent>",-1262,[612],[0],613]],[1,-30,0,-25]],[15,"Cube-004",512,false,5,[[16,"Cube<ModelComponent>",-1263,[614],[0],615]],[1,-36,0,-20.34]],[15,"Cube-005",512,false,5,[[16,"Cube<ModelComponent>",-1264,[616],[0],617]],[1,-36,0,16]],[15,"Cube-006",512,false,5,[[16,"Cube<ModelComponent>",-1265,[618],[0],619]],[1,-30,0,23]],[15,"Cube-007",512,false,5,[[16,"Cube<ModelComponent>",-1266,[620],[0],621]],[1,-18,0,14.146]],[15,"Cube-008",512,false,5,[[16,"Cube<ModelComponent>",-1267,[622],[0],623]],[1,-17.023,0,-1]],[15,"Cube-009",512,false,5,[[16,"Cube<ModelComponent>",-1268,[624],[0],625]],[1,0.017,0,-15.71]],[15,"Cube-010",512,false,5,[[16,"Cube<ModelComponent>",-1269,[626],[0],627]],[1,-9,0,-9]],[15,"Cube-011",512,false,5,[[16,"Cube<ModelComponent>",-1270,[628],[0],629]],[1,-9,0,5]],[15,"Cube-012",512,false,5,[[16,"Cube<ModelComponent>",-1271,[630],[0],631]],[1,8.765,0,5]],[15,"Cube-013",512,false,5,[[16,"Cube<ModelComponent>",-1272,[632],[0],633]],[1,9.42,0,-8.858]],[15,"Cube-014",512,false,5,[[16,"Cube<ModelComponent>",-1273,[634],[0],635]],[1,18.353,0,-1.37]],[15,"Cube-015",512,false,5,[[16,"Cube<ModelComponent>",-1274,[636],[0],637]],[1,5.771,0,-6.024]],[15,"Cube-016",512,false,5,[[16,"Cube<ModelComponent>",-1275,[638],[0],639]],[1,5.771,0,2.377]],[15,"Cube-017",512,false,5,[[16,"Cube<ModelComponent>",-1276,[640],[0],641]],[1,-4.955,0,2.377]],[15,"Cube-018",512,false,5,[[16,"Cube<ModelComponent>",-1277,[642],[0],643]],[1,-4.955,0,-6.198]],[15,"Cube-019",512,false,5,[[16,"Cube<ModelComponent>",-1278,[644],[0],645]],[1,36,0,17.682]],[15,"Cube-020",512,false,5,[[16,"Cube<ModelComponent>",-1279,[646],[0],647]],[1,25,0,22.5]],[15,"Cube-021",512,false,5,[[16,"Cube<ModelComponent>",-1280,[648],[0],649]],[1,18.724,0,13.765]],[15,"Cube-022",512,false,5,[[16,"Cube<ModelComponent>",-1281,[650],[0],651]],[1,18.724,0,-14.885]],[15,"Cube-023",512,false,5,[[16,"Cube<ModelComponent>",-1282,[652],[0],653]],[1,-17.363,0,-16.854]],[15,"Cube-024",512,false,5,[[16,"Cube<ModelComponent>",-1283,[654],[0],655]],[1,-29,0,-10.486]],[15,"Cube-025",512,false,5,[[16,"Cube<ModelComponent>",-1284,[656],[0],657]],[1,-29,0,9.265]],[15,"Cube-026",512,false,5,[[16,"Cube<ModelComponent>",-1285,[658],[0],659]],[1,29,0,-10.011]],[15,"Cube-027",512,false,5,[[16,"Cube<ModelComponent>",-1286,[660],[0],661]],[1,29,0,9.07]],[15,"Cube-028",512,false,5,[[16,"Cube<ModelComponent>",-1287,[662],[0],663]],[1,-0.11,0,12.31]],[74,"UICamera_Canvas",512,524288,21,[-1288],[1,0,0,1000]],[105,0,1073741824,483.3755274261604,2000,0,42467328,910,[4,0]],[66,"hotAirBalloonFishAni",512,"b2fDtkra9C2JOTpnJsawI0",11,[121],[1,-42.3,0,-23.832],[3,0,-0.20154806033491765,0,0.9794786262983141],[1,0.6,0.6,0.6],[1,0,-23.255,0]],[3,"hotAirBalloonFish",512,22,[[106,1,0,-1289,[665],[0],22,666,667]],[3,-0.7071067811865477,0,0,0.7071067811865474],[1,-90.00000000000003,0,0]],[67,"hotAirBalloonFish_propeller",512,22,[[107,-1290,[668],[0],22,669,670]],[1,-1.4305195808410645,0.5391300320625305,0.001986484508961439],[3,-0.7071067811865477,0,0,0.7071067811865474],[1,-90.00000000000003,0,0]],[77,"Bone004",512,68,[[38,"Dummy002",512,-1291,[1,2.023665428161621,-1.7219830751419067,0.002016601385548711],[3,-0.5000044107247844,-0.5000044107247845,0.4999955892363062,0.49999558923630627],[1,0,-90.00101086811766,90]]],[1,0.04176143556833267,-0.6142799258232117,3.0517577442878974e-7],[3,0.000006211040901928658,-0.0000062110409019286585,-0.7071067811592694,0.7071067811592695],[1,0,-0.0010065422635915366,-90]],[68,"hotAirBalloonRed",512,"a9r+nP05tDpJ/sVXRlwoC+",11,[122],[1,41.024,6,-20.352]],[69,"hotAirBalloonRed",512,122,[[79,1,0,-1292,[675],[0],676]],[1,0,-5.079,0],[1,0.00000250447806548767,0,0]]],0,[0,-1,449,0,-2,452,0,-3,455,0,-4,458,0,-5,461,0,-6,464,0,-7,467,0,-8,470,0,-9,473,0,-10,476,0,-11,479,0,-12,482,0,-13,485,0,-14,488,0,-15,491,0,-16,494,0,-17,497,0,-18,500,0,-19,503,0,-20,506,0,-21,509,0,-22,512,0,-23,515,0,-24,518,0,-25,521,0,-26,524,0,-27,527,0,-28,530,0,-29,533,0,-30,536,0,-31,539,0,-32,542,0,-33,545,0,-34,548,0,-35,551,0,-36,554,0,-37,557,0,-38,560,0,-39,563,0,-40,566,0,-41,569,0,-42,572,0,-43,575,0,-44,578,0,-45,581,0,-46,584,0,-47,587,0,-48,590,0,-49,593,0,-50,596,0,-51,599,0,-52,602,0,-53,605,0,-54,608,0,-55,611,0,-56,614,0,-57,617,0,-58,620,0,-59,623,0,-60,626,0,-61,629,0,-62,632,0,-63,635,0,-64,638,0,-65,641,0,-66,644,0,-67,647,0,-68,650,0,-69,653,0,-70,656,0,-71,659,0,-72,662,0,-73,665,0,-74,668,0,-75,671,0,-76,674,0,-77,677,0,-78,680,0,-79,683,0,-80,686,0,-81,689,0,-82,692,0,-83,695,0,-84,698,0,-85,701,0,-86,704,0,0,2,0,-1,833,0,-2,834,0,-3,835,0,-4,836,0,-5,837,0,-6,838,0,-7,839,0,-8,840,0,-9,841,0,-10,842,0,-11,843,0,-12,844,0,-13,845,0,-14,846,0,-15,847,0,-16,848,0,-17,849,0,-18,850,0,-19,851,0,-20,852,0,-21,853,0,-22,854,0,-23,855,0,-24,856,0,-25,857,0,-26,858,0,-27,859,0,-28,860,0,-29,861,0,-30,862,0,-31,863,0,-32,864,0,-33,865,0,-34,866,0,-35,867,0,-36,868,0,-37,869,0,-38,870,0,-39,871,0,-40,872,0,-41,873,0,-42,874,0,-43,875,0,-44,876,0,-1,245,0,-2,248,0,-3,251,0,-4,254,0,-5,257,0,-6,260,0,-7,263,0,-8,266,0,-9,269,0,-10,272,0,-11,275,0,-12,278,0,-13,281,0,-14,284,0,-15,287,0,-16,290,0,-17,293,0,-18,296,0,-19,299,0,-20,302,0,-21,305,0,-22,308,0,-23,311,0,-24,314,0,-25,317,0,-26,320,0,-27,323,0,-28,326,0,-29,329,0,-30,332,0,-31,335,0,-32,338,0,-33,341,0,-34,344,0,-35,347,0,-1,350,0,-2,353,0,-3,356,0,-4,359,0,-5,362,0,-6,365,0,-7,368,0,-8,371,0,-9,374,0,-10,377,0,-11,380,0,-12,383,0,-13,386,0,-14,389,0,-15,392,0,-16,395,0,-17,398,0,-18,401,0,-19,404,0,-20,407,0,-21,410,0,-22,413,0,-23,416,0,-24,419,0,-25,422,0,-26,425,0,-27,428,0,-28,431,0,-29,434,0,-30,437,0,-31,440,0,-32,443,0,-33,446,0,-1,882,0,-2,883,0,-3,884,0,-4,885,0,-5,886,0,-6,887,0,-7,888,0,-8,889,0,-9,890,0,-10,891,0,-11,892,0,-12,893,0,-13,894,0,-14,895,0,-15,896,0,-16,897,0,-17,898,0,-18,899,0,-19,900,0,-20,901,0,-21,902,0,-22,903,0,-23,904,0,-24,905,0,-25,906,0,-26,907,0,-27,908,0,-28,909,0,-1,97,0,-2,98,0,-3,99,0,-4,100,0,-5,101,0,-6,102,0,-7,103,0,-8,104,0,-9,105,0,-10,106,0,-11,107,0,-12,108,0,-13,109,0,-14,110,0,-15,111,0,-16,112,0,-17,113,0,-18,114,0,-19,115,0,-1,79,0,-2,80,0,-3,81,0,-4,82,0,-5,83,0,-6,84,0,-7,85,0,-8,86,0,-9,87,0,-10,88,0,-11,89,0,-12,90,0,-13,91,0,-14,92,0,-15,93,0,-16,94,0,-17,95,0,-18,96,0,-1,74,0,-2,707,0,-3,708,0,-4,711,0,-5,75,0,-6,77,0,-7,18,0,-8,9,0,-9,116,0,-10,117,0,-11,118,0,-12,20,0,-1,782,0,-2,785,0,-3,788,0,-4,791,0,-5,794,0,-6,797,0,-7,800,0,-8,803,0,-9,806,0,-10,809,0,-11,812,0,-1,12,0,-2,13,0,-3,14,0,-4,61,0,-5,16,0,-6,17,0,-1,75,0,-2,77,0,-3,79,0,-4,80,0,-5,81,0,-6,82,0,-7,83,0,-8,84,0,-9,85,0,-10,86,0,-11,87,0,-12,88,0,-13,89,0,-14,90,0,-15,91,0,-16,92,0,-17,93,0,-18,94,0,-19,95,0,-20,96,0,-21,97,0,-22,98,0,-23,99,0,-24,100,0,-25,101,0,-26,102,0,-27,103,0,-28,104,0,-29,105,0,-30,106,0,-31,107,0,-32,108,0,-33,109,0,-34,110,0,-35,111,0,-36,112,0,-37,113,0,-38,114,0,-39,115,0,-40,116,0,-41,117,0,-42,118,0,-1,123,0,-3,65,0,-4,21,0,-5,66,0,-6,912,0,-7,916,0,-8,72,0,-1,136,0,-2,139,0,-3,142,0,-4,145,0,-5,148,0,-6,151,0,-7,154,0,-1,157,0,-2,160,0,-3,163,0,-4,166,0,-5,169,0,-6,172,0,-7,175,0,-1,178,0,-2,179,0,-3,182,0,-4,185,0,-5,188,0,-6,191,0,-7,194,0,-1,728,0,-2,731,0,-3,734,0,-4,737,0,-5,740,0,-6,743,0,-7,746,0,-1,209,0,-2,212,0,-3,215,0,-4,218,0,-5,221,0,-6,224,0,-1,227,0,-2,230,0,-3,233,0,-4,236,0,-5,239,0,-6,242,0,-1,24,0,-3,25,0,-4,19,0,-1,764,0,-2,767,0,-3,770,0,-4,773,0,-5,776,0,-6,779,0,-1,816,0,-2,818,0,-3,820,0,-4,822,0,-5,824,0,-6,826,0,0,21,0,18,911,0,0,21,0,0,21,0,-1,73,0,-2,910,0,-3,67,0,0,22,0,-1,913,0,-2,914,0,-3,68,0,-1,124,0,-2,127,0,-3,130,0,-4,133,0,-1,713,0,-2,716,0,-3,719,0,-4,722,0,-5,725,0,-1,749,0,-2,752,0,-3,755,0,-4,758,0,-5,761,0,-1,197,0,-2,200,0,-3,203,0,-4,206,0,19,879,0,20,829,0,21,828,0,22,830,0,0,65,0,-1,828,0,-2,829,0,5,65,0,-1,830,0,-1,831,0,-2,877,0,0,67,0,0,67,0,-1,119,0,-2,120,0,5,68,0,5,68,0,5,68,0,-4,915,0,-1,879,0,0,72,0,-1,880,0,0,73,0,0,73,0,0,73,0,4,76,0,4,76,0,4,76,0,2,75,0,4,78,0,4,78,0,4,78,0,2,77,0,2,79,0,2,80,0,2,81,0,2,82,0,2,83,0,2,84,0,2,85,0,2,86,0,2,87,0,2,88,0,2,89,0,2,90,0,2,91,0,2,92,0,2,93,0,2,94,0,2,95,0,2,96,0,2,97,0,2,98,0,2,99,0,2,100,0,2,101,0,2,102,0,2,103,0,2,104,0,2,105,0,2,106,0,2,107,0,2,108,0,2,109,0,2,110,0,2,111,0,2,112,0,2,113,0,2,114,0,2,115,0,2,116,0,4,815,0,4,815,0,2,117,0,2,118,0,0,119,0,0,119,0,0,120,0,0,120,0,0,121,0,0,122,0,-1,917,0,0,123,0,-1,125,0,-1,126,0,0,126,0,-1,128,0,-1,129,0,0,129,0,-1,131,0,-1,132,0,0,132,0,-1,134,0,-1,135,0,0,135,0,-1,137,0,-1,138,0,0,138,0,-1,140,0,-1,141,0,0,141,0,-1,143,0,-1,144,0,0,144,0,-1,146,0,-1,147,0,0,147,0,-1,149,0,-1,150,0,0,150,0,-1,152,0,-1,153,0,0,153,0,-1,155,0,-1,156,0,0,156,0,-1,158,0,-1,159,0,0,159,0,-1,161,0,-1,162,0,0,162,0,-1,164,0,-1,165,0,0,165,0,-1,167,0,-1,168,0,0,168,0,-1,170,0,-1,171,0,0,171,0,-1,173,0,-1,174,0,0,174,0,-1,176,0,-1,177,0,0,177,0,5,178,0,-1,180,0,-1,181,0,0,181,0,-1,183,0,-1,184,0,0,184,0,-1,186,0,-1,187,0,0,187,0,-1,189,0,-1,190,0,0,190,0,-1,192,0,-1,193,0,0,193,0,-1,195,0,-1,196,0,0,196,0,-1,198,0,-1,199,0,0,199,0,-1,201,0,-1,202,0,0,202,0,-1,204,0,-1,205,0,0,205,0,-1,207,0,-1,208,0,0,208,0,-1,210,0,-1,211,0,0,211,0,-1,213,0,-1,214,0,0,214,0,-1,216,0,-1,217,0,0,217,0,-1,219,0,-1,220,0,0,220,0,-1,222,0,-1,223,0,0,223,0,-1,225,0,-1,226,0,0,226,0,-1,228,0,-1,229,0,0,229,0,-1,231,0,-1,232,0,0,232,0,-1,234,0,-1,235,0,0,235,0,-1,237,0,-1,238,0,0,238,0,-1,240,0,-1,241,0,0,241,0,-1,243,0,-1,244,0,0,244,0,-1,246,0,-1,247,0,0,247,0,-1,249,0,-1,250,0,0,250,0,-1,252,0,-1,253,0,0,253,0,-1,255,0,-1,256,0,0,256,0,-1,258,0,-1,259,0,0,259,0,-1,261,0,-1,262,0,0,262,0,-1,264,0,-1,265,0,0,265,0,-1,267,0,-1,268,0,0,268,0,-1,270,0,-1,271,0,0,271,0,-1,273,0,-1,274,0,0,274,0,-1,276,0,-1,277,0,0,277,0,-1,279,0,-1,280,0,0,280,0,-1,282,0,-1,283,0,0,283,0,-1,285,0,-1,286,0,0,286,0,-1,288,0,-1,289,0,0,289,0,-1,291,0,-1,292,0,0,292,0,-1,294,0,-1,295,0,0,295,0,-1,297,0,-1,298,0,0,298,0,-1,300,0,-1,301,0,0,301,0,-1,303,0,-1,304,0,0,304,0,-1,306,0,-1,307,0,0,307,0,-1,309,0,-1,310,0,0,310,0,-1,312,0,-1,313,0,0,313,0,-1,315,0,-1,316,0,0,316,0,-1,318,0,-1,319,0,0,319,0,-1,321,0,-1,322,0,0,322,0,-1,324,0,-1,325,0,0,325,0,-1,327,0,-1,328,0,0,328,0,-1,330,0,-1,331,0,0,331,0,-1,333,0,-1,334,0,0,334,0,-1,336,0,-1,337,0,0,337,0,-1,339,0,-1,340,0,0,340,0,-1,342,0,-1,343,0,0,343,0,-1,345,0,-1,346,0,0,346,0,-1,348,0,-1,349,0,0,349,0,-1,351,0,-1,352,0,0,352,0,-1,354,0,-1,355,0,0,355,0,-1,357,0,-1,358,0,0,358,0,-1,360,0,-1,361,0,0,361,0,-1,363,0,-1,364,0,0,364,0,-1,366,0,-1,367,0,0,367,0,-1,369,0,-1,370,0,0,370,0,-1,372,0,-1,373,0,0,373,0,-1,375,0,-1,376,0,0,376,0,-1,378,0,-1,379,0,0,379,0,-1,381,0,-1,382,0,0,382,0,-1,384,0,-1,385,0,0,385,0,-1,387,0,-1,388,0,0,388,0,-1,390,0,-1,391,0,0,391,0,-1,393,0,-1,394,0,0,394,0,-1,396,0,-1,397,0,0,397,0,-1,399,0,-1,400,0,0,400,0,-1,402,0,-1,403,0,0,403,0,-1,405,0,-1,406,0,0,406,0,-1,408,0,-1,409,0,0,409,0,-1,411,0,-1,412,0,0,412,0,-1,414,0,-1,415,0,0,415,0,-1,417,0,-1,418,0,0,418,0,-1,420,0,-1,421,0,0,421,0,-1,423,0,-1,424,0,0,424,0,-1,426,0,-1,427,0,0,427,0,-1,429,0,-1,430,0,0,430,0,-1,432,0,-1,433,0,0,433,0,-1,435,0,-1,436,0,0,436,0,-1,438,0,-1,439,0,0,439,0,-1,441,0,-1,442,0,0,442,0,-1,444,0,-1,445,0,0,445,0,-1,447,0,-1,448,0,0,448,0,-1,450,0,-1,451,0,0,451,0,-1,453,0,-1,454,0,0,454,0,-1,456,0,-1,457,0,0,457,0,-1,459,0,-1,460,0,0,460,0,-1,462,0,-1,463,0,0,463,0,-1,465,0,-1,466,0,0,466,0,-1,468,0,-1,469,0,0,469,0,-1,471,0,-1,472,0,0,472,0,-1,474,0,-1,475,0,0,475,0,-1,477,0,-1,478,0,0,478,0,-1,480,0,-1,481,0,0,481,0,-1,483,0,-1,484,0,0,484,0,-1,486,0,-1,487,0,0,487,0,-1,489,0,-1,490,0,0,490,0,-1,492,0,-1,493,0,0,493,0,-1,495,0,-1,496,0,0,496,0,-1,498,0,-1,499,0,0,499,0,-1,501,0,-1,502,0,0,502,0,-1,504,0,-1,505,0,0,505,0,-1,507,0,-1,508,0,0,508,0,-1,510,0,-1,511,0,0,511,0,-1,513,0,-1,514,0,0,514,0,-1,516,0,-1,517,0,0,517,0,-1,519,0,-1,520,0,0,520,0,-1,522,0,-1,523,0,0,523,0,-1,525,0,-1,526,0,0,526,0,-1,528,0,-1,529,0,0,529,0,-1,531,0,-1,532,0,0,532,0,-1,534,0,-1,535,0,0,535,0,-1,537,0,-1,538,0,0,538,0,-1,540,0,-1,541,0,0,541,0,-1,543,0,-1,544,0,0,544,0,-1,546,0,-1,547,0,0,547,0,-1,549,0,-1,550,0,0,550,0,-1,552,0,-1,553,0,0,553,0,-1,555,0,-1,556,0,0,556,0,-1,558,0,-1,559,0,0,559,0,-1,561,0,-1,562,0,0,562,0,-1,564,0,-1,565,0,0,565,0,-1,567,0,-1,568,0,0,568,0,-1,570,0,-1,571,0,0,571,0,-1,573,0,-1,574,0,0,574,0,-1,576,0,-1,577,0,0,577,0,-1,579,0,-1,580,0,0,580,0,-1,582,0,-1,583,0,0,583,0,-1,585,0,-1,586,0,0,586,0,-1,588,0,-1,589,0,0,589,0,-1,591,0,-1,592,0,0,592,0,-1,594,0,-1,595,0,0,595,0,-1,597,0,-1,598,0,0,598,0,-1,600,0,-1,601,0,0,601,0,-1,603,0,-1,604,0,0,604,0,-1,606,0,-1,607,0,0,607,0,-1,609,0,-1,610,0,0,610,0,-1,612,0,-1,613,0,0,613,0,-1,615,0,-1,616,0,0,616,0,-1,618,0,-1,619,0,0,619,0,-1,621,0,-1,622,0,0,622,0,-1,624,0,-1,625,0,0,625,0,-1,627,0,-1,628,0,0,628,0,-1,630,0,-1,631,0,0,631,0,-1,633,0,-1,634,0,0,634,0,-1,636,0,-1,637,0,0,637,0,-1,639,0,-1,640,0,0,640,0,-1,642,0,-1,643,0,0,643,0,-1,645,0,-1,646,0,0,646,0,-1,648,0,-1,649,0,0,649,0,-1,651,0,-1,652,0,0,652,0,-1,654,0,-1,655,0,0,655,0,-1,657,0,-1,658,0,0,658,0,-1,660,0,-1,661,0,0,661,0,-1,663,0,-1,664,0,0,664,0,-1,666,0,-1,667,0,0,667,0,-1,669,0,-1,670,0,0,670,0,-1,672,0,-1,673,0,0,673,0,-1,675,0,-1,676,0,0,676,0,-1,678,0,-1,679,0,0,679,0,-1,681,0,-1,682,0,0,682,0,-1,684,0,-1,685,0,0,685,0,-1,687,0,-1,688,0,0,688,0,-1,690,0,-1,691,0,0,691,0,-1,693,0,-1,694,0,0,694,0,-1,696,0,-1,697,0,0,697,0,-1,699,0,-1,700,0,0,700,0,-1,702,0,-1,703,0,0,703,0,-1,705,0,-1,706,0,0,706,0,0,707,0,-1,709,0,-1,710,0,0,710,0,-1,712,0,0,712,0,-1,714,0,-1,715,0,0,715,0,-1,717,0,-1,718,0,0,718,0,-1,720,0,-1,721,0,0,721,0,-1,723,0,-1,724,0,0,724,0,-1,726,0,-1,727,0,0,727,0,-1,729,0,-1,730,0,0,730,0,-1,732,0,-1,733,0,0,733,0,-1,735,0,-1,736,0,0,736,0,-1,738,0,-1,739,0,0,739,0,-1,741,0,-1,742,0,0,742,0,-1,744,0,-1,745,0,0,745,0,-1,747,0,-1,748,0,0,748,0,-1,750,0,-1,751,0,0,751,0,-1,753,0,-1,754,0,0,754,0,-1,756,0,-1,757,0,0,757,0,-1,759,0,-1,760,0,0,760,0,-1,762,0,-1,763,0,0,763,0,-1,765,0,-1,766,0,0,766,0,-1,768,0,-1,769,0,0,769,0,-1,771,0,-1,772,0,0,772,0,-1,774,0,-1,775,0,0,775,0,-1,777,0,-1,778,0,0,778,0,-1,780,0,-1,781,0,0,781,0,-1,783,0,-1,784,0,0,784,0,-1,786,0,-1,787,0,0,787,0,-1,789,0,-1,790,0,0,790,0,-1,792,0,-1,793,0,0,793,0,-1,795,0,-1,796,0,0,796,0,-1,798,0,-1,799,0,0,799,0,-1,801,0,-1,802,0,0,802,0,-1,804,0,-1,805,0,0,805,0,-1,807,0,-1,808,0,0,808,0,-1,810,0,-1,811,0,0,811,0,-1,813,0,-1,814,0,0,814,0,-1,817,0,0,817,0,-1,819,0,0,819,0,-1,821,0,0,821,0,-1,823,0,0,823,0,-1,825,0,0,825,0,-1,827,0,0,827,0,-1,832,0,0,833,0,0,834,0,0,835,0,0,836,0,0,837,0,0,838,0,0,839,0,0,840,0,0,841,0,0,842,0,0,843,0,0,844,0,0,845,0,0,846,0,0,847,0,0,848,0,0,849,0,0,850,0,0,851,0,0,852,0,0,853,0,0,854,0,0,855,0,0,856,0,0,857,0,0,858,0,0,859,0,0,860,0,0,861,0,0,862,0,0,863,0,0,864,0,0,865,0,0,866,0,0,867,0,0,868,0,0,869,0,0,870,0,0,871,0,0,872,0,0,873,0,0,874,0,0,875,0,0,876,0,-1,878,0,-1,881,0,0,882,0,0,883,0,0,884,0,0,885,0,0,886,0,0,887,0,0,888,0,0,889,0,0,890,0,0,891,0,0,892,0,0,893,0,0,894,0,0,895,0,0,896,0,0,897,0,0,898,0,0,899,0,0,900,0,0,901,0,0,902,0,0,903,0,0,904,0,0,905,0,0,906,0,0,907,0,0,908,0,0,909,0,-1,911,0,0,913,0,0,914,0,5,915,0,0,917,0,23,11,1,5,10,2,5,66,3,5,10,4,5,10,5,5,11,6,5,18,7,5,18,8,5,11,10,5,74,15,5,18,22,5,121,23,5,74,121,5,912,122,5,916,830,24,878,830,25,832,879,26,881,1292],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,832,878,878],[-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,3,11,3,11,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,3,3,3,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,27,28,-1,12,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,29,-1,1,13,-1,1,13,-1,12,-1,12,-1,1,-1,12,30,31,32],[19,20,19,20,19,20,19,20,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,56,57,58,59,60,34,61,62,8,9,8,9,8,9,8,9,8,9,8,9,8,9,8,9,8,9,8,9,8,9,8,9,8,9,8,9,8,9,8,9,8,9,8,9,8,9,8,9,8,9,8,9,8,9,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,10,11,10,11,10,11,10,11,10,11,10,11,10,11,10,11,10,11,10,11,10,11,63,64,65,14,15,14,15,14,15,14,15,14,15,14,15,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,66,67,35,35,7,4,7,4,7,4,7,4,7,4,7,4,7,4,7,4,7,4,7,4,7,4,7,4,7,4,7,4,7,4,7,4,7,4,7,4,7,4,7,4,7,4,7,4,7,4,7,4,7,4,7,4,7,4,7,4,68,36,69,70,36,71,72,37,37,38,38,73,74,39,39,75,76,77]],[[[22,"boxAndStone",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_OUTLINE_PASS":true,"USE_INSTANCING":true},{"USE_INSTANCING":true,"USE_BASE_COLOR_MAP":true,"USE_1ST_SHADE_MAP":true,"USE_2ND_SHADE_MAP":true,"SHADE_MAP_1_AS_SHADE_MAP_2":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{},{}],[[[{},"baseColor",8,[4,4279447144]],[{"baseStep":0.65,"baseFeather":0.8,"shadowCover":1},"mainColor",8,[4,4294967295],"shadeColor1",8,[4,4294967295],"shadeColor2",8,[4,4294967295],"specular",8,[4,16777215],"mainTexture",6,0,"shadeMap1",6,1,"shadeMap2",6,2],{},{}],11,11,0,0]]],0,0,[0,0,0,0],[7,8,9,6],[13,13,13,12]],[[[22,"vat1",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{"USE_INSTANCING":true,"USE_BASE_COLOR_MAP":true,"USE_1ST_SHADE_MAP":true,"USE_2ND_SHADE_MAP":true,"USE_SPECULAR_MAP":true,"SHADE_MAP_1_AS_SHADE_MAP_2":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{},{}],[[{},[{"baseFeather":1},"mainColor",8,[4,4294967295],"shadeColor1",8,[4,4294967295],"shadeColor2",8,[4,4294967295],"specular",8,[4,16777215],"mainTexture",6,0,"shadeMap1",6,1,"shadeMap2",6,2,"specularMap",6,3],{},{}],0,11,0,0]]],0,0,[0,0,0,0,0],[7,8,9,33,6],[21,21,21,21,12]],[[[22,"tree",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_OUTLINE_PASS":true,"USE_INSTANCING":true},{"USE_INSTANCING":true,"USE_BASE_COLOR_MAP":true,"USE_1ST_SHADE_MAP":true,"USE_2ND_SHADE_MAP":true,"SHADE_MAP_1_AS_SHADE_MAP_2":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{},{}],[[[{"lineWidth":20},"baseColor",8,[4,4279392283]],[{"baseStep":1,"baseFeather":1.2,"shadowCover":1},"mainColor",8,[4,4294967295],"shadeColor1",8,[4,4294967295],"shadeColor2",8,[4,4294967295],"specular",8,[4,16777215],"mainTexture",6,0,"shadeMap1",6,1,"shadeMap2",6,2],{},{}],11,11,0,0]]],0,0,[0,0,0,0],[7,8,9,6],[27,27,27,12]],[[[22,"skyBox",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_TEXTURE":true}],[[[{},"mainTexture",6,0]],11]]],0,0,[0,0],[7,6],[78,79]],[[[22,"fishBox",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_OUTLINE_PASS":true,"USE_INSTANCING":true},{"USE_INSTANCING":true,"USE_BASE_COLOR_MAP":true,"USE_1ST_SHADE_MAP":true,"USE_2ND_SHADE_MAP":true,"SHADE_MAP_1_AS_SHADE_MAP_2":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{},{}],[[[{"lineWidth":5},"baseColor",8,[4,4285091653]],[{"baseFeather":1.5},"mainColor",8,[4,4294967295],"shadeColor1",8,[4,4294967295],"shadeColor2",8,[4,4294967295],"specular",8,[4,16777215],"mainTexture",6,0,"shadeMap1",6,1,"shadeMap2",6,2],{},{}],11,11,0,0]]],0,0,[0,0,0,0],[7,8,9,6],[28,28,28,12]],[[[24,".bin",4022929714,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":51168,"length":7944,"count":3972,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":51168,"count":1066,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.0175122022628784,-0.04289647191762924,-0.81142657995224],"maxPosition",8,[1,1.0175122022628784,1.1892430782318115,0.8114265203475952]]],-1],0,0,[],[],[]],[[[24,".bin",2158206181,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":154416,"length":23748,"count":11874,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":154416,"count":3217,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-74.21109008789062,-42.61375045776367,-0.3376654088497162],"maxPosition",8,[1,71.9251480102539,50.90461730957031,9.279287338256836]]],-1],0,0,[],[],[]],[[[22,"fishBone",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_OUTLINE_PASS":true,"USE_INSTANCING":true},{"USE_INSTANCING":true,"USE_BASE_COLOR_MAP":true,"USE_1ST_SHADE_MAP":true,"USE_2ND_SHADE_MAP":true,"SHADE_MAP_1_AS_SHADE_MAP_2":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{},{}],[[[{"lineWidth":5},"baseColor",8,[4,4287338135]],[{"baseFeather":1.2},"mainColor",8,[4,4294967295],"shadeColor1",8,[4,4294967295],"shadeColor2",8,[4,4294967295],"specular",8,[4,16777215],"mainTexture",6,0,"shadeMap1",6,1,"shadeMap2",6,2],{},{}],11,11,0,0]]],0,0,[0,0,0,0],[7,8,9,6],[29,29,29,12]]]]
